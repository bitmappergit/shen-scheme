"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun pr (V2382 V2383) (trap-error (shen.prh V2382 V2383 0) (lambda E V2382)))

(defun shen.prh (V2384 V2385 V2386) (shen.prh V2384 V2385 (shen.write-char-and-inc V2384 V2385 V2386)))

(defun shen.write-char-and-inc (V2387 V2388 V2389) (do (write-byte (string->n (pos V2387 V2389)) V2388) (+ V2389 1)))

(defun print (V2390) (let String (shen.insert V2390 "~S") (let Print (shen.prhush String (stoutput)) V2390)))

(defun shen.prhush (V2391 V2392) (if (value *hush*) V2391 (pr V2391 V2392)))

(defun shen.mkstr (V2393 V2394) (cond ((string? V2393) (shen.mkstr-l (shen.proc-nl V2393) V2394)) (true (shen.mkstr-r (cons shen.proc-nl (cons V2393 ())) V2394))))

(defun shen.mkstr-l (V2395 V2396) (cond ((= () V2396) V2395) ((cons? V2396) (shen.mkstr-l (shen.insert-l (hd V2396) V2395) (tl V2396))) (true (shen.f_error shen.mkstr-l))))

(defun shen.insert-l (V2399 V2400) (cond ((= "" V2400) "") ((and (shen.+string? V2400) (and (= "~" (pos V2400 0)) (and (shen.+string? (tlstr V2400)) (= "A" (pos (tlstr V2400) 0))))) (cons shen.app (cons V2399 (cons (tlstr (tlstr V2400)) (cons shen.a ()))))) ((and (shen.+string? V2400) (and (= "~" (pos V2400 0)) (and (shen.+string? (tlstr V2400)) (= "R" (pos (tlstr V2400) 0))))) (cons shen.app (cons V2399 (cons (tlstr (tlstr V2400)) (cons shen.r ()))))) ((and (shen.+string? V2400) (and (= "~" (pos V2400 0)) (and (shen.+string? (tlstr V2400)) (= "S" (pos (tlstr V2400) 0))))) (cons shen.app (cons V2399 (cons (tlstr (tlstr V2400)) (cons shen.s ()))))) ((shen.+string? V2400) (shen.factor-cn (cons cn (cons (pos V2400 0) (cons (shen.insert-l V2399 (tlstr V2400)) ()))))) ((and (cons? V2400) (and (= cn (hd V2400)) (and (cons? (tl V2400)) (and (cons? (tl (tl V2400))) (= () (tl (tl (tl V2400)))))))) (cons cn (cons (hd (tl V2400)) (cons (shen.insert-l V2399 (hd (tl (tl V2400)))) ())))) ((and (cons? V2400) (and (= shen.app (hd V2400)) (and (cons? (tl V2400)) (and (cons? (tl (tl V2400))) (and (cons? (tl (tl (tl V2400)))) (= () (tl (tl (tl (tl V2400)))))))))) (cons shen.app (cons (hd (tl V2400)) (cons (shen.insert-l V2399 (hd (tl (tl V2400)))) (tl (tl (tl V2400))))))) (true (shen.f_error shen.insert-l))))

(defun shen.factor-cn (V2401) (cond ((and (cons? V2401) (and (= cn (hd V2401)) (and (cons? (tl V2401)) (and (cons? (tl (tl V2401))) (and (cons? (hd (tl (tl V2401)))) (and (= cn (hd (hd (tl (tl V2401))))) (and (cons? (tl (hd (tl (tl V2401))))) (and (cons? (tl (tl (hd (tl (tl V2401)))))) (and (= () (tl (tl (tl (hd (tl (tl V2401))))))) (and (= () (tl (tl (tl V2401)))) (and (string? (hd (tl V2401))) (string? (hd (tl (hd (tl (tl V2401))))))))))))))))) (cons cn (cons (cn (hd (tl V2401)) (hd (tl (hd (tl (tl V2401)))))) (tl (tl (hd (tl (tl V2401)))))))) (true V2401)))

(defun shen.proc-nl (V2402) (cond ((= "" V2402) "") ((and (shen.+string? V2402) (and (= "~" (pos V2402 0)) (and (shen.+string? (tlstr V2402)) (= "%" (pos (tlstr V2402) 0))))) (cn (n->string 10) (shen.proc-nl (tlstr (tlstr V2402))))) ((shen.+string? V2402) (cn (pos V2402 0) (shen.proc-nl (tlstr V2402)))) (true (shen.f_error shen.proc-nl))))

(defun shen.mkstr-r (V2403 V2404) (cond ((= () V2404) V2403) ((cons? V2404) (shen.mkstr-r (cons shen.insert (cons (hd V2404) (cons V2403 ()))) (tl V2404))) (true (shen.f_error shen.mkstr-r))))

(defun shen.insert (V2405 V2406) (shen.insert-h V2405 V2406 ""))

(defun shen.insert-h (V2409 V2410 V2411) (cond ((= "" V2410) V2411) ((and (shen.+string? V2410) (and (= "~" (pos V2410 0)) (and (shen.+string? (tlstr V2410)) (= "A" (pos (tlstr V2410) 0))))) (cn V2411 (shen.app V2409 (tlstr (tlstr V2410)) shen.a))) ((and (shen.+string? V2410) (and (= "~" (pos V2410 0)) (and (shen.+string? (tlstr V2410)) (= "R" (pos (tlstr V2410) 0))))) (cn V2411 (shen.app V2409 (tlstr (tlstr V2410)) shen.r))) ((and (shen.+string? V2410) (and (= "~" (pos V2410 0)) (and (shen.+string? (tlstr V2410)) (= "S" (pos (tlstr V2410) 0))))) (cn V2411 (shen.app V2409 (tlstr (tlstr V2410)) shen.s))) ((shen.+string? V2410) (shen.insert-h V2409 (tlstr V2410) (cn V2411 (pos V2410 0)))) (true (shen.f_error shen.insert-h))))

(defun shen.app (V2412 V2413 V2414) (cn (shen.arg->str V2412 V2414) V2413))

(defun shen.arg->str (V2420 V2421) (cond ((= V2420 (fail)) "...") ((shen.list? V2420) (shen.list->str V2420 V2421)) ((string? V2420) (shen.str->str V2420 V2421)) ((absvector? V2420) (shen.vector->str V2420 V2421)) (true (shen.atom->str V2420))))

(defun shen.list->str (V2422 V2423) (cond ((= shen.r V2423) (@s "(" (@s (shen.iter-list V2422 shen.r (shen.maxseq)) ")"))) (true (@s "[" (@s (shen.iter-list V2422 V2423 (shen.maxseq)) "]")))))

(defun shen.maxseq () (value *maximum-print-sequence-size*))

(defun shen.iter-list (V2434 V2435 V2436) (cond ((= () V2434) "") ((= 0 V2436) "... etc") ((and (cons? V2434) (= () (tl V2434))) (shen.arg->str (hd V2434) V2435)) ((cons? V2434) (@s (shen.arg->str (hd V2434) V2435) (@s " " (shen.iter-list (tl V2434) V2435 (- V2436 1))))) (true (@s "|" (@s " " (shen.arg->str V2434 V2435))))))

(defun shen.str->str (V2441 V2442) (cond ((= shen.a V2442) V2441) (true (@s (n->string 34) (@s V2441 (n->string 34))))))

(defun shen.vector->str (V2443 V2444) (if (shen.print-vector? V2443) ((<-address V2443 0) V2443) (if (vector? V2443) (@s "<" (@s (shen.iter-vector V2443 1 V2444 (shen.maxseq)) ">")) (@s "<" (@s "<" (@s (shen.iter-vector V2443 0 V2444 (shen.maxseq)) ">>"))))))

(defun shen.print-vector? (V2445) (let Zero (<-address V2445 0) (if (= Zero shen.tuple) true (if (= Zero shen.pvar) true (if (not (number? Zero)) (shen.fbound? Zero) false)))))

(defun shen.fbound? (V2446) (trap-error (do (ps V2446) true) (lambda E false)))

(defun shen.tuple (V2447) (cn "(@p " (shen.app (<-address V2447 1) (cn " " (shen.app (<-address V2447 2) ")" shen.s)) shen.s)))

(defun shen.iter-vector (V2454 V2455 V2456 V2457) (cond ((= 0 V2457) "... etc") (true (let Item (trap-error (<-address V2454 V2455) (lambda E shen.out-of-bounds)) (let Next (trap-error (<-address V2454 (+ V2455 1)) (lambda E shen.out-of-bounds)) (if (= Item shen.out-of-bounds) "" (if (= Next shen.out-of-bounds) (shen.arg->str Item V2456) (@s (shen.arg->str Item V2456) (@s " " (shen.iter-vector V2454 (+ V2455 1) V2456 (- V2457 1)))))))))))

(defun shen.atom->str (V2458) (trap-error (str V2458) (lambda E (shen.funexstring))))

(defun shen.funexstring () (@s "" (@s "f" (@s "u" (@s "n" (@s "e" (@s (shen.arg->str (gensym (intern "x")) shen.a) "")))))))

(defun shen.list? (V2459) (or (empty? V2459) (cons? V2459)))



