"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V2664) (V2664))

(defun eval (V2666) (let Macroexpand (shen.walk (lambda Y (macroexpand Y)) V2666) (if (shen.packaged? Macroexpand) (map (lambda Z (shen.eval-without-macros Z)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V2668) (eval-kl (shen.elim-def (shen.proc-input+ V2668))))

(defun shen.proc-input+ (V2670) (cond ((and (cons? V2670) (and (= input+ (hd V2670)) (and (cons? (tl V2670)) (and (cons? (tl (tl V2670))) (= () (tl (tl (tl V2670)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V2670))) (tl (tl V2670))))) ((and (cons? V2670) (and (= shen.read+ (hd V2670)) (and (cons? (tl V2670)) (and (cons? (tl (tl V2670))) (= () (tl (tl (tl V2670)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V2670))) (tl (tl V2670))))) ((cons? V2670) (map (lambda Z (shen.proc-input+ Z)) V2670)) (true V2670)))

(defun shen.elim-def (V2672) (cond ((and (cons? V2672) (and (= define (hd V2672)) (cons? (tl V2672)))) (shen->kl (hd (tl V2672)) (tl (tl V2672)))) ((and (cons? V2672) (and (= defmacro (hd V2672)) (cons? (tl V2672)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V2672)) (append (tl (tl V2672)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V2672))) Def)))) ((and (cons? V2672) (and (= defcc (hd V2672)) (cons? (tl V2672)))) (shen.elim-def (shen.yacc V2672))) ((cons? V2672) (map (lambda Z (shen.elim-def Z)) V2672)) (true V2672)))

(defun shen.add-macro (V2674) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V2674 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (set *macros* (cons (function V2674) (value *macros*)))))))

(defun shen.packaged? (V2682) (cond ((and (cons? V2682) (and (= package (hd V2682)) (and (cons? (tl V2682)) (cons? (tl (tl V2682)))))) true) (true false)))

(defun external (V2684) (trap-error (get V2684 shen.external-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V2684 " has not been used.
" shen.a))))))

(defun internal (V2686) (trap-error (get V2686 shen.internal-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V2686 " has not been used.
" shen.a))))))

(defun shen.package-contents (V2690) (cond ((and (cons? V2690) (and (= package (hd V2690)) (and (cons? (tl V2690)) (and (= null (hd (tl V2690))) (cons? (tl (tl V2690))))))) (tl (tl (tl V2690)))) ((and (cons? V2690) (and (= package (hd V2690)) (and (cons? (tl V2690)) (cons? (tl (tl V2690)))))) (shen.packageh (hd (tl V2690)) (hd (tl (tl V2690))) (tl (tl (tl V2690))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V2693 V2694) (cond ((cons? V2694) (V2693 (map (lambda Z (shen.walk V2693 Z)) V2694))) (true (V2693 V2694))))

(defun compile (V2698 V2699 V2700) (let O (V2698 (cons V2699 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V2700 O) (shen.hdtl O))))

(defun fail-if (V2703 V2704) (if (V2703 V2704) (fail) V2704))

(defun @s (V2707 V2708) (cn V2707 V2708))

(defun tc? () (value shen.*tc*))

(defun ps (V2710) (trap-error (get V2710 shen.source (value *property-vector*)) (lambda E (simple-error (shen.app V2710 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun shen.+vector? (V2712) (and (absvector? V2712) (> (<-address V2712 0) 0)))

(defun vector (V2714) (let Vector (absvector (+ V2714 1)) (let ZeroStamp (address-> Vector 0 V2714) (let Standard (if (= V2714 0) ZeroStamp (shen.fillvector ZeroStamp 1 V2714 (fail))) Standard))))

(defun shen.fillvector (V2720 V2721 V2722 V2723) (cond ((= V2722 V2721) (address-> V2720 V2722 V2723)) (true (shen.fillvector (address-> V2720 V2721 V2723) (+ 1 V2721) V2722 V2723))))

(defun vector? (V2725) (and (absvector? V2725) (trap-error (>= (<-address V2725 0) 0) (lambda E false))))

(defun vector-> (V2729 V2730 V2731) (if (= V2730 0) (simple-error "cannot access 0th element of a vector
") (address-> V2729 V2730 V2731)))

(defun <-vector (V2734 V2735) (if (= V2735 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V2734 V2735) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun shen.posint? (V2737) (and (integer? V2737) (>= V2737 0)))

(defun limit (V2739) (<-address V2739 0))

(defun symbol? (V2741) (cond ((or (boolean? V2741) (or (number? V2741) (string? V2741))) false) (true (trap-error (let String (str V2741) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V2743) (cond ((shen.+string? V2743) (and (shen.alpha? (pos V2743 0)) (shen.alphanums? (tlstr V2743)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V2745) (element? V2745 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V2747) (cond ((= "" V2747) true) ((shen.+string? V2747) (and (shen.alphanum? (pos V2747 0)) (shen.alphanums? (tlstr V2747)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V2749) (or (shen.alpha? V2749) (shen.digit? V2749)))

(defun shen.digit? (V2751) (element? V2751 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V2753) (cond ((or (boolean? V2753) (or (number? V2753) (string? V2753))) false) (true (trap-error (let String (str V2753) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V2755) (cond ((shen.+string? V2755) (and (shen.uppercase? (pos V2755 0)) (shen.alphanums? (tlstr V2755)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V2757) (element? V2757 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V2759) (concat V2759 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V2762 V2763) (intern (cn (str V2762) (str V2763))))

(defun @p (V2766 V2767) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V2766) (let Snd (address-> Vector 2 V2767) Vector)))))

(defun fst (V2769) (<-address V2769 1))

(defun snd (V2771) (<-address V2771 2))

(defun tuple? (V2773) (trap-error (and (absvector? V2773) (= shen.tuple (<-address V2773 0))) (lambda E false)))

(defun append (V2776 V2777) (cond ((= () V2776) V2777) ((cons? V2776) (cons (hd V2776) (append (tl V2776) V2777))) (true (shen.f_error append))))

(defun @v (V2780 V2781) (let Limit (limit V2781) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V2780) (if (= Limit 0) X+NewVector (shen.@v-help V2781 1 Limit X+NewVector))))))

(defun shen.@v-help (V2787 V2788 V2789 V2790) (cond ((= V2789 V2788) (shen.copyfromvector V2787 V2790 V2789 (+ V2789 1))) (true (shen.@v-help V2787 (+ V2788 1) V2789 (shen.copyfromvector V2787 V2790 V2788 (+ V2788 1))))))

(defun shen.copyfromvector (V2795 V2796 V2797 V2798) (trap-error (vector-> V2796 V2798 (<-vector V2795 V2797)) (lambda E V2796)))

(defun hdv (V2800) (trap-error (<-vector V2800 1) (lambda E (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V2800 "
" shen.s))))))

(defun tlv (V2802) (let Limit (limit V2802) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V2802 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V2808 V2809 V2810 V2811) (cond ((= V2810 V2809) (shen.copyfromvector V2808 V2811 V2810 (- V2810 1))) (true (shen.tlv-help V2808 (+ V2809 1) V2810 (shen.copyfromvector V2808 V2811 V2809 (- V2809 1))))))

(defun assoc (V2823 V2824) (cond ((= () V2824) ()) ((and (cons? V2824) (and (cons? (hd V2824)) (= (hd (hd V2824)) V2823))) (hd V2824)) ((cons? V2824) (assoc V2823 (tl V2824))) (true (shen.f_error assoc))))

(defun boolean? (V2830) (cond ((= true V2830) true) ((= false V2830) true) (true false)))

(defun nl (V2832) (cond ((= 0 V2832) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V2832 1))))))

(defun difference (V2837 V2838) (cond ((= () V2837) ()) ((cons? V2837) (if (element? (hd V2837) V2838) (difference (tl V2837) V2838) (cons (hd V2837) (difference (tl V2837) V2838)))) (true (shen.f_error difference))))

(defun do (V2841 V2842) V2842)

(defun element? (V2854 V2855) (cond ((= () V2855) false) ((and (cons? V2855) (= (hd V2855) V2854)) true) ((cons? V2855) (element? V2854 (tl V2855))) (true (shen.f_error element?))))

(defun empty? (V2861) (cond ((= () V2861) true) (true false)))

(defun fix (V2864 V2865) (shen.fix-help V2864 V2865 (V2864 V2865)))

(defun shen.fix-help (V2876 V2877 V2878) (cond ((= V2878 V2877) V2878) (true (shen.fix-help V2876 V2878 (V2876 V2878)))))

(defun put (V2883 V2884 V2885 V2886) (let N (hash V2883 (limit V2886)) (let Entry (trap-error (<-vector V2886 N) (lambda E ())) (let Change (vector-> V2886 N (shen.change-pointer-value V2883 V2884 V2885 Entry)) V2885))))

(defun unput (V2890 V2891 V2892) (let N (hash V2890 (limit V2892)) (let Entry (trap-error (<-vector V2892 N) (lambda E ())) (let Change (vector-> V2892 N (shen.remove-pointer V2890 V2891 Entry)) V2890))))

(defun shen.remove-pointer (V2900 V2901 V2902) (cond ((= () V2902) ()) ((and (cons? V2902) (and (cons? (hd V2902)) (and (cons? (hd (hd V2902))) (and (cons? (tl (hd (hd V2902)))) (and (= () (tl (tl (hd (hd V2902))))) (and (= (hd (tl (hd (hd V2902)))) V2901) (= (hd (hd (hd V2902))) V2900))))))) (tl V2902)) ((cons? V2902) (cons (hd V2902) (shen.remove-pointer V2900 V2901 (tl V2902)))) (true (shen.f_error shen.remove-pointer))))

(defun shen.change-pointer-value (V2911 V2912 V2913 V2914) (cond ((= () V2914) (cons (cons (cons V2911 (cons V2912 ())) V2913) ())) ((and (cons? V2914) (and (cons? (hd V2914)) (and (cons? (hd (hd V2914))) (and (cons? (tl (hd (hd V2914)))) (and (= () (tl (tl (hd (hd V2914))))) (and (= (hd (tl (hd (hd V2914)))) V2912) (= (hd (hd (hd V2914))) V2911))))))) (cons (cons (hd (hd V2914)) V2913) (tl V2914))) ((cons? V2914) (cons (hd V2914) (shen.change-pointer-value V2911 V2912 V2913 (tl V2914)))) (true (shen.f_error shen.change-pointer-value))))

(defun get (V2918 V2919 V2920) (let N (hash V2918 (limit V2920)) (let Entry (trap-error (<-vector V2920 N) (lambda E (simple-error "pointer not found
"))) (let Result (assoc (cons V2918 (cons V2919 ())) Entry) (if (empty? Result) (simple-error "value not found
") (tl Result))))))

(defun hash (V2923 V2924) (let Hash (shen.mod (sum (map (lambda X (string->n X)) (explode V2923))) V2924) (if (= 0 Hash) 1 Hash)))

(defun shen.mod (V2927 V2928) (shen.modh V2927 (shen.multiples V2927 (cons V2928 ()))))

(defun shen.multiples (V2931 V2932) (cond ((and (cons? V2932) (> (hd V2932) V2931)) (tl V2932)) ((cons? V2932) (shen.multiples V2931 (cons (* 2 (hd V2932)) V2932))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V2937 V2938) (cond ((= 0 V2937) 0) ((= () V2938) V2937) ((and (cons? V2938) (> (hd V2938) V2937)) (if (empty? (tl V2938)) V2937 (shen.modh V2937 (tl V2938)))) ((cons? V2938) (shen.modh (- V2937 (hd V2938)) V2938)) (true (shen.f_error shen.modh))))

(defun sum (V2940) (cond ((= () V2940) 0) ((cons? V2940) (+ (hd V2940) (sum (tl V2940)))) (true (shen.f_error sum))))

(defun head (V2948) (cond ((cons? V2948) (hd V2948)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V2956) (cond ((cons? V2956) (tl V2956)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V2958) (pos V2958 0))

(defun intersection (V2963 V2964) (cond ((= () V2963) ()) ((cons? V2963) (if (element? (hd V2963) V2964) (cons (hd V2963) (intersection (tl V2963) V2964)) (intersection (tl V2963) V2964))) (true (shen.f_error intersection))))

(defun reverse (V2966) (shen.reverse_help V2966 ()))

(defun shen.reverse_help (V2969 V2970) (cond ((= () V2969) V2970) ((cons? V2969) (shen.reverse_help (tl V2969) (cons (hd V2969) V2970))) (true (shen.f_error shen.reverse_help))))

(defun union (V2973 V2974) (cond ((= () V2973) V2974) ((cons? V2973) (if (element? (hd V2973) V2974) (union (tl V2973) V2974) (cons (hd V2973) (union (tl V2973) V2974)))) (true (shen.f_error union))))

(defun y-or-n? (V2976) (let Message (shen.prhush (shen.proc-nl V2976) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V2976))))))))

(defun not (V2978) (if V2978 false true))

(defun subst (V2991 V2992 V2993) (cond ((= V2993 V2992) V2991) ((cons? V2993) (map (lambda W (subst V2991 V2992 W)) V2993)) (true V2993)))

(defun explode (V2995) (shen.explode-h (shen.app V2995 "" shen.a)))

(defun shen.explode-h (V2997) (cond ((= "" V2997) ()) ((shen.+string? V2997) (cons (pos V2997 0) (shen.explode-h (tlstr V2997)))) (true (shen.f_error shen.explode-h))))

(defun cd (V2999) (set *home-directory* (if (= V2999 "") "" (shen.app V2999 "/" shen.a))))

(defun map (V3002 V3003) (shen.map-h V3002 V3003 ()))

(defun shen.map-h (V3009 V3010 V3011) (cond ((= () V3010) (reverse V3011)) ((cons? V3010) (shen.map-h V3009 (tl V3010) (cons (V3009 (hd V3010)) V3011))) (true (shen.f_error shen.map-h))))

(defun length (V3013) (shen.length-h V3013 0))

(defun shen.length-h (V3016 V3017) (cond ((= () V3016) V3017) (true (shen.length-h (tl V3016) (+ V3017 1)))))

(defun occurrences (V3029 V3030) (cond ((= V3030 V3029) 1) ((cons? V3030) (+ (occurrences V3029 (hd V3030)) (occurrences V3029 (tl V3030)))) (true 0)))

(defun nth (V3039 V3040) (cond ((and (= 1 V3039) (cons? V3040)) (hd V3040)) ((cons? V3040) (nth (- V3039 1) (tl V3040))) (true (shen.f_error nth))))

(defun integer? (V3042) (and (number? V3042) (let Abs (shen.abs V3042) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V3044) (if (> V3044 0) V3044 (- 0 V3044)))

(defun shen.magless (V3047 V3048) (let Nx2 (* V3048 2) (if (> Nx2 V3047) V3048 (shen.magless V3047 Nx2))))

(defun shen.integer-test? (V3054 V3055) (cond ((= 0 V3054) true) ((> 1 V3054) false) (true (let Abs-N (- V3054 V3055) (if (> 0 Abs-N) (integer? V3054) (shen.integer-test? Abs-N V3055))))))

(defun mapcan (V3060 V3061) (cond ((= () V3061) ()) ((cons? V3061) (append (V3060 (hd V3061)) (mapcan V3060 (tl V3061)))) (true (shen.f_error mapcan))))

(defun == (V3073 V3074) (cond ((= V3074 V3073) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V3076) (and (symbol? V3076) (let Val (trap-error (value V3076) (lambda E shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V3078) (cond ((= "" V3078) ()) (true (cons (string->n (pos V3078 0)) (shen.string->bytes (tlstr V3078))))))

(defun maxinferences (V3080) (set shen.*maxinferences* V3080))

(defun inferences () (value shen.*infs*))

(defun protect (V3082) V3082)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V3084) (let Symbol (intern V3084) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V3084 " to a symbol" shen.s))))))

(defun optimise (V3090) (cond ((= + V3090) (set shen.*optimise* true)) ((= - V3090) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V3092) (trap-error (do (external V3092) true) (lambda E false)))

(defun function (V3094) (shen.lookup-func V3094 (value shen.*symbol-table*)))

(defun shen.lookup-func (V3104 V3105) (cond ((= () V3105) (simple-error (shen.app V3104 " has no lambda expansion
" shen.a))) ((and (cons? V3105) (and (cons? (hd V3105)) (= (hd (hd V3105)) V3104))) (tl (hd V3105))) ((cons? V3105) (shen.lookup-func V3104 (tl V3105))) (true (shen.f_error shen.lookup-func))))



