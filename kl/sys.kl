"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V1473) (V1473))

(defun eval (V1474) (let Macroexpand (shen.walk (lambda V1468 (macroexpand V1468)) V1474) (if (shen.packaged? Macroexpand) (map (lambda V1469 (shen.eval-without-macros V1469)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.proc-defmacro (V1475) (cond ((and (cons? V1475) (and (= defmacro (hd V1475)) (cons? (tl V1475)))) (shen.add-macro (hd (tl V1475)))) (true V1475)))

(defun shen.eval-without-macros (V1476) (let Result (eval-kl (shen.elim-def (shen.proc-input+ V1476))) (let Macro (shen.proc-defmacro V1476) Result)))

(defun shen.proc-input+ (V1477) (cond ((and (cons? V1477) (and (= input+ (hd V1477)) (and (cons? (tl V1477)) (and (cons? (tl (tl V1477))) (= () (tl (tl (tl V1477)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1477))) (tl (tl V1477))))) ((and (cons? V1477) (and (= shen.read+ (hd V1477)) (and (cons? (tl V1477)) (and (cons? (tl (tl V1477))) (= () (tl (tl (tl V1477)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V1477))) (tl (tl V1477))))) ((cons? V1477) (map (lambda V1470 (shen.proc-input+ V1470)) V1477)) (true V1477)))

(defun shen.elim-def (V1478) (cond ((and (cons? V1478) (and (= define (hd V1478)) (cons? (tl V1478)))) (shen.shen->kl (hd (tl V1478)) (tl (tl V1478)))) ((and (cons? V1478) (and (= defmacro (hd V1478)) (cons? (tl V1478)))) (let Default (cons X (cons -> (cons X ()))) (shen.elim-def (cons define (cons (hd (tl V1478)) (append (tl (tl V1478)) Default)))))) ((and (cons? V1478) (and (= defcc (hd V1478)) (cons? (tl V1478)))) (shen.elim-def (shen.yacc V1478))) ((cons? V1478) (map (lambda V1471 (shen.elim-def V1471)) V1478)) (true V1478)))

(defun shen.symbol->function (V1479) (cond ((symbol? V1479) (eval-kl (cons lambda (cons X (cons (cons V1479 (cons X ())) ()))))) (true V1479)))

(defun shen.add-macro (V1480) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V1480 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (let MacroF (shen.symbol->function V1480) (set *macros* (cons MacroF (value *macros*))))))))

(defun shen.packaged? (V1487) (cond ((and (cons? V1487) (and (= package (hd V1487)) (and (cons? (tl V1487)) (cons? (tl (tl V1487)))))) true) (true false)))

(defun external (V1488) (trap-error (get V1488 shen.external-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V1488 " has not been used.
" shen.a))))))

(defun shen.package-contents (V1491) (cond ((and (cons? V1491) (and (= package (hd V1491)) (and (cons? (tl V1491)) (and (= null (hd (tl V1491))) (cons? (tl (tl V1491))))))) (tl (tl (tl V1491)))) ((and (cons? V1491) (and (= package (hd V1491)) (and (cons? (tl V1491)) (cons? (tl (tl V1491)))))) (shen.packageh (hd (tl V1491)) (hd (tl (tl V1491))) (tl (tl (tl V1491))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V1492 V1493) (cond ((cons? V1493) (V1492 (map (lambda Z (shen.walk V1492 Z)) V1493))) (true (V1492 V1493))))

(defun compile (V1494 V1495 V1496) (let O (V1494 (cons V1495 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V1496 O) (shen.hdtl O))))

(defun fail-if (V1497 V1498) (if (V1497 V1498) (fail) V1498))

(defun @s (V1499 V1500) (cn V1499 V1500))

(defun tc? () (value shen.*tc*))

(defun ps (V1501) (trap-error (get V1501 shen.source (value *property-vector*)) (lambda E (simple-error (shen.app V1501 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun shen.+vector? (V1502) (and (absvector? V1502) (> (<-address V1502 0) 0)))

(defun vector (V1503) (let Vector (absvector (+ V1503 1)) (let ZeroStamp (address-> Vector 0 V1503) (let Standard (if (= V1503 0) ZeroStamp (shen.fillvector ZeroStamp 1 V1503 (fail))) Standard))))

(defun shen.fillvector (V1505 V1506 V1507 V1508) (cond ((= V1507 V1506) (address-> V1505 V1507 V1508)) (true (shen.fillvector (address-> V1505 V1506 V1508) (+ 1 V1506) V1507 V1508))))

(defun vector? (V1509) (and (absvector? V1509) (trap-error (>= (<-address V1509 0) 0) (lambda E false))))

(defun vector-> (V1510 V1511 V1512) (if (= V1511 0) (simple-error "cannot access 0th element of a vector
") (address-> V1510 V1511 V1512)))

(defun <-vector (V1513 V1514) (if (= V1514 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V1513 V1514) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun shen.posint? (V1515) (and (integer? V1515) (>= V1515 0)))

(defun limit (V1516) (<-address V1516 0))

(defun symbol? (V1517) (cond ((or (boolean? V1517) (or (number? V1517) (string? V1517))) false) (true (trap-error (let String (str V1517) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V1518) (cond ((shen.+string? V1518) (and (shen.alpha? (pos V1518 0)) (shen.alphanums? (tlstr V1518)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V1519) (element? V1519 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V1520) (cond ((= "" V1520) true) ((shen.+string? V1520) (and (shen.alphanum? (pos V1520 0)) (shen.alphanums? (tlstr V1520)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V1521) (or (shen.alpha? V1521) (shen.digit? V1521)))

(defun shen.digit? (V1522) (element? V1522 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V1523) (cond ((or (boolean? V1523) (or (number? V1523) (string? V1523))) false) (true (trap-error (let String (str V1523) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V1524) (cond ((shen.+string? V1524) (and (shen.uppercase? (pos V1524 0)) (shen.alphanums? (tlstr V1524)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V1525) (element? V1525 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V1526) (concat V1526 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V1527 V1528) (intern (cn (str V1527) (str V1528))))

(defun @p (V1529 V1530) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V1529) (let Snd (address-> Vector 2 V1530) Vector)))))

(defun fst (V1531) (<-address V1531 1))

(defun snd (V1532) (<-address V1532 2))

(defun tuple? (V1533) (trap-error (and (absvector? V1533) (= shen.tuple (<-address V1533 0))) (lambda E false)))

(defun append (V1534 V1535) (cond ((= () V1534) V1535) ((cons? V1534) (cons (hd V1534) (append (tl V1534) V1535))) (true (shen.f_error append))))

(defun @v (V1536 V1537) (let Limit (limit V1537) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V1536) (if (= Limit 0) X+NewVector (shen.@v-help V1537 1 Limit X+NewVector))))))

(defun shen.@v-help (V1539 V1540 V1541 V1542) (cond ((= V1541 V1540) (shen.copyfromvector V1539 V1542 V1541 (+ V1541 1))) (true (shen.@v-help V1539 (+ V1540 1) V1541 (shen.copyfromvector V1539 V1542 V1540 (+ V1540 1))))))

(defun shen.copyfromvector (V1543 V1544 V1545 V1546) (trap-error (vector-> V1544 V1546 (<-vector V1543 V1545)) (lambda E V1544)))

(defun hdv (V1547) (trap-error (<-vector V1547 1) (lambda E (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V1547 "
" shen.s))))))

(defun tlv (V1548) (let Limit (limit V1548) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V1548 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V1550 V1551 V1552 V1553) (cond ((= V1552 V1551) (shen.copyfromvector V1550 V1553 V1552 (- V1552 1))) (true (shen.tlv-help V1550 (+ V1551 1) V1552 (shen.copyfromvector V1550 V1553 V1551 (- V1551 1))))))

(defun assoc (V1563 V1564) (cond ((= () V1564) ()) ((and (cons? V1564) (and (cons? (hd V1564)) (= (hd (hd V1564)) V1563))) (hd V1564)) ((cons? V1564) (assoc V1563 (tl V1564))) (true (shen.f_error assoc))))

(defun boolean? (V1569) (cond ((= true V1569) true) ((= false V1569) true) (true false)))

(defun nl (V1570) (cond ((= 0 V1570) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V1570 1))))))

(defun difference (V1573 V1574) (cond ((= () V1573) ()) ((cons? V1573) (if (element? (hd V1573) V1574) (difference (tl V1573) V1574) (cons (hd V1573) (difference (tl V1573) V1574)))) (true (shen.f_error difference))))

(defun do (V1575 V1576) V1576)

(defun element? (V1586 V1587) (cond ((= () V1587) false) ((and (cons? V1587) (= (hd V1587) V1586)) true) ((cons? V1587) (element? V1586 (tl V1587))) (true (shen.f_error element?))))

(defun empty? (V1592) (cond ((= () V1592) true) (true false)))

(defun fix (V1593 V1594) (shen.fix-help V1593 V1594 (V1593 V1594)))

(defun shen.fix-help (V1602 V1603 V1604) (cond ((= V1604 V1603) V1604) (true (shen.fix-help V1602 V1604 (V1602 V1604)))))

(defun put (V1605 V1606 V1607 V1608) (let N (hash V1605 (limit V1608)) (let Entry (trap-error (<-vector V1608 N) (lambda E ())) (let Change (vector-> V1608 N (shen.change-pointer-value V1605 V1606 V1607 Entry)) V1607))))

(defun unput (V1609 V1610 V1611) (let N (hash V1609 (limit V1611)) (let Entry (trap-error (<-vector V1611 N) (lambda E ())) (let Change (vector-> V1611 N (shen.remove-pointer V1609 V1610 Entry)) V1609))))

(defun shen.remove-pointer (V1616 V1617 V1618) (cond ((= () V1618) ()) ((and (cons? V1618) (and (cons? (hd V1618)) (and (cons? (hd (hd V1618))) (and (cons? (tl (hd (hd V1618)))) (and (= () (tl (tl (hd (hd V1618))))) (and (= (hd (tl (hd (hd V1618)))) V1617) (= (hd (hd (hd V1618))) V1616))))))) (tl V1618)) ((cons? V1618) (cons (hd V1618) (shen.remove-pointer V1616 V1617 (tl V1618)))) (true (shen.f_error shen.remove-pointer))))

(defun shen.change-pointer-value (V1623 V1624 V1625 V1626) (cond ((= () V1626) (cons (cons (cons V1623 (cons V1624 ())) V1625) ())) ((and (cons? V1626) (and (cons? (hd V1626)) (and (cons? (hd (hd V1626))) (and (cons? (tl (hd (hd V1626)))) (and (= () (tl (tl (hd (hd V1626))))) (and (= (hd (tl (hd (hd V1626)))) V1624) (= (hd (hd (hd V1626))) V1623))))))) (cons (cons (hd (hd V1626)) V1625) (tl V1626))) ((cons? V1626) (cons (hd V1626) (shen.change-pointer-value V1623 V1624 V1625 (tl V1626)))) (true (shen.f_error shen.change-pointer-value))))

(defun get (V1627 V1628 V1629) (let N (hash V1627 (limit V1629)) (let Entry (trap-error (<-vector V1629 N) (lambda E (simple-error "pointer not found
"))) (let Result (assoc (cons V1627 (cons V1628 ())) Entry) (if (empty? Result) (simple-error "value not found
") (tl Result))))))

(defun hash (V1630 V1631) (let Hash (shen.mod (sum (map (lambda V1472 (string->n V1472)) (explode V1630))) V1631) (if (= 0 Hash) 1 Hash)))

(defun shen.mod (V1632 V1633) (shen.modh V1632 (shen.multiples V1632 (cons V1633 ()))))

(defun shen.multiples (V1634 V1635) (cond ((and (cons? V1635) (> (hd V1635) V1634)) (tl V1635)) ((cons? V1635) (shen.multiples V1634 (cons (* 2 (hd V1635)) V1635))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V1638 V1639) (cond ((= 0 V1638) 0) ((= () V1639) V1638) ((and (cons? V1639) (> (hd V1639) V1638)) (if (empty? (tl V1639)) V1638 (shen.modh V1638 (tl V1639)))) ((cons? V1639) (shen.modh (- V1638 (hd V1639)) V1639)) (true (shen.f_error shen.modh))))

(defun sum (V1640) (cond ((= () V1640) 0) ((cons? V1640) (+ (hd V1640) (sum (tl V1640)))) (true (shen.f_error sum))))

(defun head (V1647) (cond ((cons? V1647) (hd V1647)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V1654) (cond ((cons? V1654) (tl V1654)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V1655) (pos V1655 0))

(defun intersection (V1658 V1659) (cond ((= () V1658) ()) ((cons? V1658) (if (element? (hd V1658) V1659) (cons (hd V1658) (intersection (tl V1658) V1659)) (intersection (tl V1658) V1659))) (true (shen.f_error intersection))))

(defun reverse (V1660) (shen.reverse_help V1660 ()))

(defun shen.reverse_help (V1661 V1662) (cond ((= () V1661) V1662) ((cons? V1661) (shen.reverse_help (tl V1661) (cons (hd V1661) V1662))) (true (shen.f_error shen.reverse_help))))

(defun union (V1663 V1664) (cond ((= () V1663) V1664) ((cons? V1663) (if (element? (hd V1663) V1664) (union (tl V1663) V1664) (cons (hd V1663) (union (tl V1663) V1664)))) (true (shen.f_error union))))

(defun y-or-n? (V1665) (let Message (shen.prhush (shen.proc-nl V1665) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V1665))))))))

(defun not (V1666) (if V1666 false true))

(defun subst (V1676 V1677 V1678) (cond ((= V1678 V1677) V1676) ((cons? V1678) (map (lambda W (subst V1676 V1677 W)) V1678)) (true V1678)))

(defun explode (V1679) (shen.explode-h (shen.app V1679 "" shen.a)))

(defun shen.explode-h (V1680) (cond ((= "" V1680) ()) ((shen.+string? V1680) (cons (pos V1680 0) (shen.explode-h (tlstr V1680)))) (true (shen.f_error shen.explode-h))))

(defun cd (V1681) (set *home-directory* (if (= V1681 "") "" (shen.app V1681 "/" shen.a))))

(defun map (V1682 V1683) (shen.map-h V1682 V1683 ()))

(defun shen.map-h (V1686 V1687 V1688) (cond ((= () V1687) (reverse V1688)) ((cons? V1687) (shen.map-h V1686 (tl V1687) (cons (V1686 (hd V1687)) V1688))) (true (shen.f_error shen.map-h))))

(defun length (V1689) (shen.length-h V1689 0))

(defun shen.length-h (V1690 V1691) (cond ((= () V1690) V1691) (true (shen.length-h (tl V1690) (+ V1691 1)))))

(defun occurrences (V1701 V1702) (cond ((= V1702 V1701) 1) ((cons? V1702) (+ (occurrences V1701 (hd V1702)) (occurrences V1701 (tl V1702)))) (true 0)))

(defun nth (V1709 V1710) (cond ((and (= 1 V1709) (cons? V1710)) (hd V1710)) ((cons? V1710) (nth (- V1709 1) (tl V1710))) (true (shen.f_error nth))))

(defun integer? (V1711) (and (number? V1711) (let Abs (shen.abs V1711) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V1712) (if (> V1712 0) V1712 (- 0 V1712)))

(defun shen.magless (V1713 V1714) (let Nx2 (* V1714 2) (if (> Nx2 V1713) V1714 (shen.magless V1713 Nx2))))

(defun shen.integer-test? (V1718 V1719) (cond ((= 0 V1718) true) ((> 1 V1718) false) (true (let Abs-N (- V1718 V1719) (if (> 0 Abs-N) (integer? V1718) (shen.integer-test? Abs-N V1719))))))

(defun mapcan (V1722 V1723) (cond ((= () V1723) ()) ((cons? V1723) (append (V1722 (hd V1723)) (mapcan V1722 (tl V1723)))) (true (shen.f_error mapcan))))

(defun == (V1733 V1734) (cond ((= V1734 V1733) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V1735) (and (symbol? V1735) (let Val (trap-error (value V1735) (lambda E shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V1736) (cond ((= "" V1736) ()) (true (cons (string->n (pos V1736 0)) (shen.string->bytes (tlstr V1736))))))

(defun maxinferences (V1737) (set shen.*maxinferences* V1737))

(defun inferences () (value shen.*infs*))

(defun protect (V1738) V1738)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V1739) (let Symbol (intern V1739) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V1739 " to a symbol" shen.s))))))

(defun optimise (V1744) (cond ((= + V1744) (set shen.*optimise* true)) ((= - V1744) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V1745) (trap-error (do (external V1745) true) (lambda E false)))



