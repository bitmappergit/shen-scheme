"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V1473) (V1473))

(defun eval (V1474) (let Macroexpand (shen.walk (lambda V1468 (macroexpand V1468)) V1474) (if (shen.packaged? Macroexpand) (map (lambda V1469 (shen.eval-without-macros V1469)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.eval-without-macros (V1475) (eval-kl (shen.elim-def (shen.proc-input+ V1475))))

(defun shen.proc-input+ (V1476) (cond ((and (cons? V1476) (and (= input+ (hd V1476)) (and (cons? (tl V1476)) (and (cons? (tl (tl V1476))) (= () (tl (tl (tl V1476)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1476))) (tl (tl V1476))))) ((and (cons? V1476) (and (= shen.read+ (hd V1476)) (and (cons? (tl V1476)) (and (cons? (tl (tl V1476))) (= () (tl (tl (tl V1476)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V1476))) (tl (tl V1476))))) ((cons? V1476) (map (lambda V1470 (shen.proc-input+ V1470)) V1476)) (true V1476)))

(defun shen.elim-def (V1477) (cond ((and (cons? V1477) (and (= define (hd V1477)) (cons? (tl V1477)))) (shen.shen->kl (hd (tl V1477)) (tl (tl V1477)))) ((and (cons? V1477) (and (= defmacro (hd V1477)) (cons? (tl V1477)))) (let Default (cons X (cons -> (cons X ()))) (let Def (shen.elim-def (cons define (cons (hd (tl V1477)) (append (tl (tl V1477)) Default)))) (let MacroAdd (shen.add-macro (hd (tl V1477))) Def)))) ((and (cons? V1477) (and (= defcc (hd V1477)) (cons? (tl V1477)))) (shen.elim-def (shen.yacc V1477))) ((cons? V1477) (map (lambda V1471 (shen.elim-def V1471)) V1477)) (true V1477)))

(defun shen.add-macro (V1478) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V1478 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (let Var (gensym V) (let MacroF (eval-kl (cons lambda (cons Var (cons (cons V1478 (cons Var ())) ())))) (set *macros* (cons MacroF (value *macros*)))))))))

(defun shen.packaged? (V1485) (cond ((and (cons? V1485) (and (= package (hd V1485)) (and (cons? (tl V1485)) (cons? (tl (tl V1485)))))) true) (true false)))

(defun external (V1486) (trap-error (get V1486 shen.external-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V1486 " has not been used.
" shen.a))))))

(defun shen.package-contents (V1489) (cond ((and (cons? V1489) (and (= package (hd V1489)) (and (cons? (tl V1489)) (and (= null (hd (tl V1489))) (cons? (tl (tl V1489))))))) (tl (tl (tl V1489)))) ((and (cons? V1489) (and (= package (hd V1489)) (and (cons? (tl V1489)) (cons? (tl (tl V1489)))))) (shen.packageh (hd (tl V1489)) (hd (tl (tl V1489))) (tl (tl (tl V1489))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V1490 V1491) (cond ((cons? V1491) (V1490 (map (lambda Z (shen.walk V1490 Z)) V1491))) (true (V1490 V1491))))

(defun compile (V1492 V1493 V1494) (let O (V1492 (cons V1493 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V1494 O) (shen.hdtl O))))

(defun fail-if (V1495 V1496) (if (V1495 V1496) (fail) V1496))

(defun @s (V1497 V1498) (cn V1497 V1498))

(defun tc? () (value shen.*tc*))

(defun ps (V1499) (trap-error (get V1499 shen.source (value *property-vector*)) (lambda E (simple-error (shen.app V1499 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun shen.+vector? (V1500) (and (absvector? V1500) (> (<-address V1500 0) 0)))

(defun vector (V1501) (let Vector (absvector (+ V1501 1)) (let ZeroStamp (address-> Vector 0 V1501) (let Standard (if (= V1501 0) ZeroStamp (shen.fillvector ZeroStamp 1 V1501 (fail))) Standard))))

(defun shen.fillvector (V1503 V1504 V1505 V1506) (cond ((= V1505 V1504) (address-> V1503 V1505 V1506)) (true (shen.fillvector (address-> V1503 V1504 V1506) (+ 1 V1504) V1505 V1506))))

(defun vector? (V1507) (and (absvector? V1507) (trap-error (>= (<-address V1507 0) 0) (lambda E false))))

(defun vector-> (V1508 V1509 V1510) (if (= V1509 0) (simple-error "cannot access 0th element of a vector
") (address-> V1508 V1509 V1510)))

(defun <-vector (V1511 V1512) (if (= V1512 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V1511 V1512) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun shen.posint? (V1513) (and (integer? V1513) (>= V1513 0)))

(defun limit (V1514) (<-address V1514 0))

(defun symbol? (V1515) (cond ((or (boolean? V1515) (or (number? V1515) (string? V1515))) false) (true (trap-error (let String (str V1515) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V1516) (cond ((shen.+string? V1516) (and (shen.alpha? (pos V1516 0)) (shen.alphanums? (tlstr V1516)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V1517) (element? V1517 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V1518) (cond ((= "" V1518) true) ((shen.+string? V1518) (and (shen.alphanum? (pos V1518 0)) (shen.alphanums? (tlstr V1518)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V1519) (or (shen.alpha? V1519) (shen.digit? V1519)))

(defun shen.digit? (V1520) (element? V1520 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V1521) (cond ((or (boolean? V1521) (or (number? V1521) (string? V1521))) false) (true (trap-error (let String (str V1521) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V1522) (cond ((shen.+string? V1522) (and (shen.uppercase? (pos V1522 0)) (shen.alphanums? (tlstr V1522)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V1523) (element? V1523 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V1524) (concat V1524 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V1525 V1526) (intern (cn (str V1525) (str V1526))))

(defun @p (V1527 V1528) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V1527) (let Snd (address-> Vector 2 V1528) Vector)))))

(defun fst (V1529) (<-address V1529 1))

(defun snd (V1530) (<-address V1530 2))

(defun tuple? (V1531) (trap-error (and (absvector? V1531) (= shen.tuple (<-address V1531 0))) (lambda E false)))

(defun append (V1532 V1533) (cond ((= () V1532) V1533) ((cons? V1532) (cons (hd V1532) (append (tl V1532) V1533))) (true (shen.f_error append))))

(defun @v (V1534 V1535) (let Limit (limit V1535) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V1534) (if (= Limit 0) X+NewVector (shen.@v-help V1535 1 Limit X+NewVector))))))

(defun shen.@v-help (V1537 V1538 V1539 V1540) (cond ((= V1539 V1538) (shen.copyfromvector V1537 V1540 V1539 (+ V1539 1))) (true (shen.@v-help V1537 (+ V1538 1) V1539 (shen.copyfromvector V1537 V1540 V1538 (+ V1538 1))))))

(defun shen.copyfromvector (V1541 V1542 V1543 V1544) (trap-error (vector-> V1542 V1544 (<-vector V1541 V1543)) (lambda E V1542)))

(defun hdv (V1545) (trap-error (<-vector V1545 1) (lambda E (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V1545 "
" shen.s))))))

(defun tlv (V1546) (let Limit (limit V1546) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V1546 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V1548 V1549 V1550 V1551) (cond ((= V1550 V1549) (shen.copyfromvector V1548 V1551 V1550 (- V1550 1))) (true (shen.tlv-help V1548 (+ V1549 1) V1550 (shen.copyfromvector V1548 V1551 V1549 (- V1549 1))))))

(defun assoc (V1561 V1562) (cond ((= () V1562) ()) ((and (cons? V1562) (and (cons? (hd V1562)) (= (hd (hd V1562)) V1561))) (hd V1562)) ((cons? V1562) (assoc V1561 (tl V1562))) (true (shen.f_error assoc))))

(defun boolean? (V1567) (cond ((= true V1567) true) ((= false V1567) true) (true false)))

(defun nl (V1568) (cond ((= 0 V1568) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V1568 1))))))

(defun difference (V1571 V1572) (cond ((= () V1571) ()) ((cons? V1571) (if (element? (hd V1571) V1572) (difference (tl V1571) V1572) (cons (hd V1571) (difference (tl V1571) V1572)))) (true (shen.f_error difference))))

(defun do (V1573 V1574) V1574)

(defun element? (V1584 V1585) (cond ((= () V1585) false) ((and (cons? V1585) (= (hd V1585) V1584)) true) ((cons? V1585) (element? V1584 (tl V1585))) (true (shen.f_error element?))))

(defun empty? (V1590) (cond ((= () V1590) true) (true false)))

(defun fix (V1591 V1592) (shen.fix-help V1591 V1592 (V1591 V1592)))

(defun shen.fix-help (V1600 V1601 V1602) (cond ((= V1602 V1601) V1602) (true (shen.fix-help V1600 V1602 (V1600 V1602)))))

(defun put (V1603 V1604 V1605 V1606) (let N (hash V1603 (limit V1606)) (let Entry (trap-error (<-vector V1606 N) (lambda E ())) (let Change (vector-> V1606 N (shen.change-pointer-value V1603 V1604 V1605 Entry)) V1605))))

(defun unput (V1607 V1608 V1609) (let N (hash V1607 (limit V1609)) (let Entry (trap-error (<-vector V1609 N) (lambda E ())) (let Change (vector-> V1609 N (shen.remove-pointer V1607 V1608 Entry)) V1607))))

(defun shen.remove-pointer (V1614 V1615 V1616) (cond ((= () V1616) ()) ((and (cons? V1616) (and (cons? (hd V1616)) (and (cons? (hd (hd V1616))) (and (cons? (tl (hd (hd V1616)))) (and (= () (tl (tl (hd (hd V1616))))) (and (= (hd (tl (hd (hd V1616)))) V1615) (= (hd (hd (hd V1616))) V1614))))))) (tl V1616)) ((cons? V1616) (cons (hd V1616) (shen.remove-pointer V1614 V1615 (tl V1616)))) (true (shen.f_error shen.remove-pointer))))

(defun shen.change-pointer-value (V1621 V1622 V1623 V1624) (cond ((= () V1624) (cons (cons (cons V1621 (cons V1622 ())) V1623) ())) ((and (cons? V1624) (and (cons? (hd V1624)) (and (cons? (hd (hd V1624))) (and (cons? (tl (hd (hd V1624)))) (and (= () (tl (tl (hd (hd V1624))))) (and (= (hd (tl (hd (hd V1624)))) V1622) (= (hd (hd (hd V1624))) V1621))))))) (cons (cons (hd (hd V1624)) V1623) (tl V1624))) ((cons? V1624) (cons (hd V1624) (shen.change-pointer-value V1621 V1622 V1623 (tl V1624)))) (true (shen.f_error shen.change-pointer-value))))

(defun get (V1625 V1626 V1627) (let N (hash V1625 (limit V1627)) (let Entry (trap-error (<-vector V1627 N) (lambda E (simple-error "pointer not found
"))) (let Result (assoc (cons V1625 (cons V1626 ())) Entry) (if (empty? Result) (simple-error "value not found
") (tl Result))))))

(defun hash (V1628 V1629) (let Hash (shen.mod (sum (map (lambda V1472 (string->n V1472)) (explode V1628))) V1629) (if (= 0 Hash) 1 Hash)))

(defun shen.mod (V1630 V1631) (shen.modh V1630 (shen.multiples V1630 (cons V1631 ()))))

(defun shen.multiples (V1632 V1633) (cond ((and (cons? V1633) (> (hd V1633) V1632)) (tl V1633)) ((cons? V1633) (shen.multiples V1632 (cons (* 2 (hd V1633)) V1633))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V1636 V1637) (cond ((= 0 V1636) 0) ((= () V1637) V1636) ((and (cons? V1637) (> (hd V1637) V1636)) (if (empty? (tl V1637)) V1636 (shen.modh V1636 (tl V1637)))) ((cons? V1637) (shen.modh (- V1636 (hd V1637)) V1637)) (true (shen.f_error shen.modh))))

(defun sum (V1638) (cond ((= () V1638) 0) ((cons? V1638) (+ (hd V1638) (sum (tl V1638)))) (true (shen.f_error sum))))

(defun head (V1645) (cond ((cons? V1645) (hd V1645)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V1652) (cond ((cons? V1652) (tl V1652)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V1653) (pos V1653 0))

(defun intersection (V1656 V1657) (cond ((= () V1656) ()) ((cons? V1656) (if (element? (hd V1656) V1657) (cons (hd V1656) (intersection (tl V1656) V1657)) (intersection (tl V1656) V1657))) (true (shen.f_error intersection))))

(defun reverse (V1658) (shen.reverse_help V1658 ()))

(defun shen.reverse_help (V1659 V1660) (cond ((= () V1659) V1660) ((cons? V1659) (shen.reverse_help (tl V1659) (cons (hd V1659) V1660))) (true (shen.f_error shen.reverse_help))))

(defun union (V1661 V1662) (cond ((= () V1661) V1662) ((cons? V1661) (if (element? (hd V1661) V1662) (union (tl V1661) V1662) (cons (hd V1661) (union (tl V1661) V1662)))) (true (shen.f_error union))))

(defun y-or-n? (V1663) (let Message (shen.prhush (shen.proc-nl V1663) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V1663))))))))

(defun not (V1664) (if V1664 false true))

(defun subst (V1674 V1675 V1676) (cond ((= V1676 V1675) V1674) ((cons? V1676) (map (lambda W (subst V1674 V1675 W)) V1676)) (true V1676)))

(defun explode (V1677) (shen.explode-h (shen.app V1677 "" shen.a)))

(defun shen.explode-h (V1678) (cond ((= "" V1678) ()) ((shen.+string? V1678) (cons (pos V1678 0) (shen.explode-h (tlstr V1678)))) (true (shen.f_error shen.explode-h))))

(defun cd (V1679) (set *home-directory* (if (= V1679 "") "" (shen.app V1679 "/" shen.a))))

(defun map (V1680 V1681) (shen.map-h V1680 V1681 ()))

(defun shen.map-h (V1684 V1685 V1686) (cond ((= () V1685) (reverse V1686)) ((cons? V1685) (shen.map-h V1684 (tl V1685) (cons (V1684 (hd V1685)) V1686))) (true (shen.f_error shen.map-h))))

(defun length (V1687) (shen.length-h V1687 0))

(defun shen.length-h (V1688 V1689) (cond ((= () V1688) V1689) (true (shen.length-h (tl V1688) (+ V1689 1)))))

(defun occurrences (V1699 V1700) (cond ((= V1700 V1699) 1) ((cons? V1700) (+ (occurrences V1699 (hd V1700)) (occurrences V1699 (tl V1700)))) (true 0)))

(defun nth (V1707 V1708) (cond ((and (= 1 V1707) (cons? V1708)) (hd V1708)) ((cons? V1708) (nth (- V1707 1) (tl V1708))) (true (shen.f_error nth))))

(defun integer? (V1709) (and (number? V1709) (let Abs (shen.abs V1709) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V1710) (if (> V1710 0) V1710 (- 0 V1710)))

(defun shen.magless (V1711 V1712) (let Nx2 (* V1712 2) (if (> Nx2 V1711) V1712 (shen.magless V1711 Nx2))))

(defun shen.integer-test? (V1716 V1717) (cond ((= 0 V1716) true) ((> 1 V1716) false) (true (let Abs-N (- V1716 V1717) (if (> 0 Abs-N) (integer? V1716) (shen.integer-test? Abs-N V1717))))))

(defun mapcan (V1720 V1721) (cond ((= () V1721) ()) ((cons? V1721) (append (V1720 (hd V1721)) (mapcan V1720 (tl V1721)))) (true (shen.f_error mapcan))))

(defun == (V1731 V1732) (cond ((= V1732 V1731) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V1733) (and (symbol? V1733) (let Val (trap-error (value V1733) (lambda E shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V1734) (cond ((= "" V1734) ()) (true (cons (string->n (pos V1734 0)) (shen.string->bytes (tlstr V1734))))))

(defun maxinferences (V1735) (set shen.*maxinferences* V1735))

(defun inferences () (value shen.*infs*))

(defun protect (V1736) V1736)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V1737) (let Symbol (intern V1737) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V1737 " to a symbol" shen.s))))))

(defun optimise (V1742) (cond ((= + V1742) (set shen.*optimise* true)) ((= - V1742) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V1743) (trap-error (do (external V1743) true) (lambda E false)))



