"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun thaw (V1473) (V1473))

(defun eval (V1474) (let Macroexpand (shen.walk (lambda V1468 (macroexpand V1468)) V1474) (if (shen.packaged? Macroexpand) (map (lambda V1469 (shen.eval-without-macros V1469)) (shen.package-contents Macroexpand)) (shen.eval-without-macros Macroexpand))))

(defun shen.proc-defmacro (V1475) (cond ((and (cons? V1475) (and (= defmacro (hd V1475)) (cons? (tl V1475)))) (shen.add-macro (hd (tl V1475)))) (true V1475)))

(defun shen.eval-without-macros (V1476) (let Result (eval-kl (shen.elim-def (shen.proc-input+ V1476))) (let Macro (shen.proc-defmacro V1476) Result)))

(defun shen.proc-input+ (V1477) (cond ((and (cons? V1477) (and (= input+ (hd V1477)) (and (cons? (tl V1477)) (and (cons? (tl (tl V1477))) (= () (tl (tl (tl V1477)))))))) (cons input+ (cons (shen.rcons_form (hd (tl V1477))) (tl (tl V1477))))) ((and (cons? V1477) (and (= shen.read+ (hd V1477)) (and (cons? (tl V1477)) (and (cons? (tl (tl V1477))) (= () (tl (tl (tl V1477)))))))) (cons shen.read+ (cons (shen.rcons_form (hd (tl V1477))) (tl (tl V1477))))) ((cons? V1477) (map (lambda V1470 (shen.proc-input+ V1470)) V1477)) (true V1477)))

(defun shen.elim-def (V1478) (cond ((and (cons? V1478) (and (= define (hd V1478)) (cons? (tl V1478)))) (shen.shen->kl (hd (tl V1478)) (tl (tl V1478)))) ((and (cons? V1478) (and (= defmacro (hd V1478)) (cons? (tl V1478)))) (let Default (cons X (cons -> (cons X ()))) (shen.elim-def (cons define (cons (hd (tl V1478)) (append (tl (tl V1478)) Default)))))) ((and (cons? V1478) (and (= defcc (hd V1478)) (cons? (tl V1478)))) (shen.elim-def (shen.yacc V1478))) ((cons? V1478) (map (lambda V1471 (shen.elim-def V1471)) V1478)) (true V1478)))

(defun shen.add-macro (V1479) (let MacroReg (value shen.*macroreg*) (let NewMacroReg (set shen.*macroreg* (adjoin V1479 (value shen.*macroreg*))) (if (= MacroReg NewMacroReg) shen.skip (let Var (gensym V) (let MacroF (eval-kl (cons lambda (cons Var (cons (cons V1479 (cons Var ())) ())))) (set *macros* (cons MacroF (value *macros*)))))))))

(defun shen.packaged? (V1486) (cond ((and (cons? V1486) (and (= package (hd V1486)) (and (cons? (tl V1486)) (cons? (tl (tl V1486)))))) true) (true false)))

(defun external (V1487) (trap-error (get V1487 shen.external-symbols (value *property-vector*)) (lambda E (simple-error (cn "package " (shen.app V1487 " has not been used.
" shen.a))))))

(defun shen.package-contents (V1490) (cond ((and (cons? V1490) (and (= package (hd V1490)) (and (cons? (tl V1490)) (and (= null (hd (tl V1490))) (cons? (tl (tl V1490))))))) (tl (tl (tl V1490)))) ((and (cons? V1490) (and (= package (hd V1490)) (and (cons? (tl V1490)) (cons? (tl (tl V1490)))))) (shen.packageh (hd (tl V1490)) (hd (tl (tl V1490))) (tl (tl (tl V1490))))) (true (shen.f_error shen.package-contents))))

(defun shen.walk (V1491 V1492) (cond ((cons? V1492) (V1491 (map (lambda Z (shen.walk V1491 Z)) V1492))) (true (V1491 V1492))))

(defun compile (V1493 V1494 V1495) (let O (V1493 (cons V1494 (cons () ()))) (if (or (= (fail) O) (not (empty? (hd O)))) (V1495 O) (shen.hdtl O))))

(defun fail-if (V1496 V1497) (if (V1496 V1497) (fail) V1497))

(defun @s (V1498 V1499) (cn V1498 V1499))

(defun tc? () (value shen.*tc*))

(defun ps (V1500) (trap-error (get V1500 shen.source (value *property-vector*)) (lambda E (simple-error (shen.app V1500 " not found.
" shen.a)))))

(defun stinput () (value *stinput*))

(defun shen.+vector? (V1501) (and (absvector? V1501) (> (<-address V1501 0) 0)))

(defun vector (V1502) (let Vector (absvector (+ V1502 1)) (let ZeroStamp (address-> Vector 0 V1502) (let Standard (if (= V1502 0) ZeroStamp (shen.fillvector ZeroStamp 1 V1502 (fail))) Standard))))

(defun shen.fillvector (V1504 V1505 V1506 V1507) (cond ((= V1506 V1505) (address-> V1504 V1506 V1507)) (true (shen.fillvector (address-> V1504 V1505 V1507) (+ 1 V1505) V1506 V1507))))

(defun vector? (V1508) (and (absvector? V1508) (trap-error (>= (<-address V1508 0) 0) (lambda E false))))

(defun vector-> (V1509 V1510 V1511) (if (= V1510 0) (simple-error "cannot access 0th element of a vector
") (address-> V1509 V1510 V1511)))

(defun <-vector (V1512 V1513) (if (= V1513 0) (simple-error "cannot access 0th element of a vector
") (let VectorElement (<-address V1512 V1513) (if (= VectorElement (fail)) (simple-error "vector element not found
") VectorElement))))

(defun shen.posint? (V1514) (and (integer? V1514) (>= V1514 0)))

(defun limit (V1515) (<-address V1515 0))

(defun symbol? (V1516) (cond ((or (boolean? V1516) (or (number? V1516) (string? V1516))) false) (true (trap-error (let String (str V1516) (shen.analyse-symbol? String)) (lambda E false)))))

(defun shen.analyse-symbol? (V1517) (cond ((shen.+string? V1517) (and (shen.alpha? (pos V1517 0)) (shen.alphanums? (tlstr V1517)))) (true (shen.f_error shen.analyse-symbol?))))

(defun shen.alpha? (V1518) (element? V1518 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" (cons "a" (cons "b" (cons "c" (cons "d" (cons "e" (cons "f" (cons "g" (cons "h" (cons "i" (cons "j" (cons "k" (cons "l" (cons "m" (cons "n" (cons "o" (cons "p" (cons "q" (cons "r" (cons "s" (cons "t" (cons "u" (cons "v" (cons "w" (cons "x" (cons "y" (cons "z" (cons "=" (cons "*" (cons "/" (cons "+" (cons "-" (cons "_" (cons "?" (cons "$" (cons "!" (cons "@" (cons "~" (cons ">" (cons "<" (cons "&" (cons "%" (cons "{" (cons "}" (cons ":" (cons ";" (cons "`" (cons "#" (cons "'" (cons "." ())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))

(defun shen.alphanums? (V1519) (cond ((= "" V1519) true) ((shen.+string? V1519) (and (shen.alphanum? (pos V1519 0)) (shen.alphanums? (tlstr V1519)))) (true (shen.f_error shen.alphanums?))))

(defun shen.alphanum? (V1520) (or (shen.alpha? V1520) (shen.digit? V1520)))

(defun shen.digit? (V1521) (element? V1521 (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))

(defun variable? (V1522) (cond ((or (boolean? V1522) (or (number? V1522) (string? V1522))) false) (true (trap-error (let String (str V1522) (shen.analyse-variable? String)) (lambda E false)))))

(defun shen.analyse-variable? (V1523) (cond ((shen.+string? V1523) (and (shen.uppercase? (pos V1523 0)) (shen.alphanums? (tlstr V1523)))) (true (shen.f_error shen.analyse-variable?))))

(defun shen.uppercase? (V1524) (element? V1524 (cons "A" (cons "B" (cons "C" (cons "D" (cons "E" (cons "F" (cons "G" (cons "H" (cons "I" (cons "J" (cons "K" (cons "L" (cons "M" (cons "N" (cons "O" (cons "P" (cons "Q" (cons "R" (cons "S" (cons "T" (cons "U" (cons "V" (cons "W" (cons "X" (cons "Y" (cons "Z" ()))))))))))))))))))))))))))))

(defun gensym (V1525) (concat V1525 (set shen.*gensym* (+ 1 (value shen.*gensym*)))))

(defun concat (V1526 V1527) (intern (cn (str V1526) (str V1527))))

(defun @p (V1528 V1529) (let Vector (absvector 3) (let Tag (address-> Vector 0 shen.tuple) (let Fst (address-> Vector 1 V1528) (let Snd (address-> Vector 2 V1529) Vector)))))

(defun fst (V1530) (<-address V1530 1))

(defun snd (V1531) (<-address V1531 2))

(defun tuple? (V1532) (trap-error (and (absvector? V1532) (= shen.tuple (<-address V1532 0))) (lambda E false)))

(defun append (V1533 V1534) (cond ((= () V1533) V1534) ((cons? V1533) (cons (hd V1533) (append (tl V1533) V1534))) (true (shen.f_error append))))

(defun @v (V1535 V1536) (let Limit (limit V1536) (let NewVector (vector (+ Limit 1)) (let X+NewVector (vector-> NewVector 1 V1535) (if (= Limit 0) X+NewVector (shen.@v-help V1536 1 Limit X+NewVector))))))

(defun shen.@v-help (V1538 V1539 V1540 V1541) (cond ((= V1540 V1539) (shen.copyfromvector V1538 V1541 V1540 (+ V1540 1))) (true (shen.@v-help V1538 (+ V1539 1) V1540 (shen.copyfromvector V1538 V1541 V1539 (+ V1539 1))))))

(defun shen.copyfromvector (V1542 V1543 V1544 V1545) (trap-error (vector-> V1543 V1545 (<-vector V1542 V1544)) (lambda E V1543)))

(defun hdv (V1546) (trap-error (<-vector V1546 1) (lambda E (simple-error (cn "hdv needs a non-empty vector as an argument; not " (shen.app V1546 "
" shen.s))))))

(defun tlv (V1547) (let Limit (limit V1547) (if (= Limit 0) (simple-error "cannot take the tail of the empty vector
") (if (= Limit 1) (vector 0) (let NewVector (vector (- Limit 1)) (shen.tlv-help V1547 2 Limit (vector (- Limit 1))))))))

(defun shen.tlv-help (V1549 V1550 V1551 V1552) (cond ((= V1551 V1550) (shen.copyfromvector V1549 V1552 V1551 (- V1551 1))) (true (shen.tlv-help V1549 (+ V1550 1) V1551 (shen.copyfromvector V1549 V1552 V1550 (- V1550 1))))))

(defun assoc (V1562 V1563) (cond ((= () V1563) ()) ((and (cons? V1563) (and (cons? (hd V1563)) (= (hd (hd V1563)) V1562))) (hd V1563)) ((cons? V1563) (assoc V1562 (tl V1563))) (true (shen.f_error assoc))))

(defun boolean? (V1568) (cond ((= true V1568) true) ((= false V1568) true) (true false)))

(defun nl (V1569) (cond ((= 0 V1569) 0) (true (do (shen.prhush "
" (stoutput)) (nl (- V1569 1))))))

(defun difference (V1572 V1573) (cond ((= () V1572) ()) ((cons? V1572) (if (element? (hd V1572) V1573) (difference (tl V1572) V1573) (cons (hd V1572) (difference (tl V1572) V1573)))) (true (shen.f_error difference))))

(defun do (V1574 V1575) V1575)

(defun element? (V1585 V1586) (cond ((= () V1586) false) ((and (cons? V1586) (= (hd V1586) V1585)) true) ((cons? V1586) (element? V1585 (tl V1586))) (true (shen.f_error element?))))

(defun empty? (V1591) (cond ((= () V1591) true) (true false)))

(defun fix (V1592 V1593) (shen.fix-help V1592 V1593 (V1592 V1593)))

(defun shen.fix-help (V1601 V1602 V1603) (cond ((= V1603 V1602) V1603) (true (shen.fix-help V1601 V1603 (V1601 V1603)))))

(defun put (V1604 V1605 V1606 V1607) (let N (hash V1604 (limit V1607)) (let Entry (trap-error (<-vector V1607 N) (lambda E ())) (let Change (vector-> V1607 N (shen.change-pointer-value V1604 V1605 V1606 Entry)) V1606))))

(defun unput (V1608 V1609 V1610) (let N (hash V1608 (limit V1610)) (let Entry (trap-error (<-vector V1610 N) (lambda E ())) (let Change (vector-> V1610 N (shen.remove-pointer V1608 V1609 Entry)) V1608))))

(defun shen.remove-pointer (V1615 V1616 V1617) (cond ((= () V1617) ()) ((and (cons? V1617) (and (cons? (hd V1617)) (and (cons? (hd (hd V1617))) (and (cons? (tl (hd (hd V1617)))) (and (= () (tl (tl (hd (hd V1617))))) (and (= (hd (tl (hd (hd V1617)))) V1616) (= (hd (hd (hd V1617))) V1615))))))) (tl V1617)) ((cons? V1617) (cons (hd V1617) (shen.remove-pointer V1615 V1616 (tl V1617)))) (true (shen.f_error shen.remove-pointer))))

(defun shen.change-pointer-value (V1622 V1623 V1624 V1625) (cond ((= () V1625) (cons (cons (cons V1622 (cons V1623 ())) V1624) ())) ((and (cons? V1625) (and (cons? (hd V1625)) (and (cons? (hd (hd V1625))) (and (cons? (tl (hd (hd V1625)))) (and (= () (tl (tl (hd (hd V1625))))) (and (= (hd (tl (hd (hd V1625)))) V1623) (= (hd (hd (hd V1625))) V1622))))))) (cons (cons (hd (hd V1625)) V1624) (tl V1625))) ((cons? V1625) (cons (hd V1625) (shen.change-pointer-value V1622 V1623 V1624 (tl V1625)))) (true (shen.f_error shen.change-pointer-value))))

(defun get (V1626 V1627 V1628) (let N (hash V1626 (limit V1628)) (let Entry (trap-error (<-vector V1628 N) (lambda E (simple-error "pointer not found
"))) (let Result (assoc (cons V1626 (cons V1627 ())) Entry) (if (empty? Result) (simple-error "value not found
") (tl Result))))))

(defun hash (V1629 V1630) (let Hash (shen.mod (sum (map (lambda V1472 (string->n V1472)) (explode V1629))) V1630) (if (= 0 Hash) 1 Hash)))

(defun shen.mod (V1631 V1632) (shen.modh V1631 (shen.multiples V1631 (cons V1632 ()))))

(defun shen.multiples (V1633 V1634) (cond ((and (cons? V1634) (> (hd V1634) V1633)) (tl V1634)) ((cons? V1634) (shen.multiples V1633 (cons (* 2 (hd V1634)) V1634))) (true (shen.f_error shen.multiples))))

(defun shen.modh (V1637 V1638) (cond ((= 0 V1637) 0) ((= () V1638) V1637) ((and (cons? V1638) (> (hd V1638) V1637)) (if (empty? (tl V1638)) V1637 (shen.modh V1637 (tl V1638)))) ((cons? V1638) (shen.modh (- V1637 (hd V1638)) V1638)) (true (shen.f_error shen.modh))))

(defun sum (V1639) (cond ((= () V1639) 0) ((cons? V1639) (+ (hd V1639) (sum (tl V1639)))) (true (shen.f_error sum))))

(defun head (V1646) (cond ((cons? V1646) (hd V1646)) (true (simple-error "head expects a non-empty list"))))

(defun tail (V1653) (cond ((cons? V1653) (tl V1653)) (true (simple-error "tail expects a non-empty list"))))

(defun hdstr (V1654) (pos V1654 0))

(defun intersection (V1657 V1658) (cond ((= () V1657) ()) ((cons? V1657) (if (element? (hd V1657) V1658) (cons (hd V1657) (intersection (tl V1657) V1658)) (intersection (tl V1657) V1658))) (true (shen.f_error intersection))))

(defun reverse (V1659) (shen.reverse_help V1659 ()))

(defun shen.reverse_help (V1660 V1661) (cond ((= () V1660) V1661) ((cons? V1660) (shen.reverse_help (tl V1660) (cons (hd V1660) V1661))) (true (shen.f_error shen.reverse_help))))

(defun union (V1662 V1663) (cond ((= () V1662) V1663) ((cons? V1662) (if (element? (hd V1662) V1663) (union (tl V1662) V1663) (cons (hd V1662) (union (tl V1662) V1663)))) (true (shen.f_error union))))

(defun y-or-n? (V1664) (let Message (shen.prhush (shen.proc-nl V1664) (stoutput)) (let Y-or-N (shen.prhush " (y/n) " (stoutput)) (let Input (shen.app (read (stinput)) "" shen.s) (if (= "y" Input) true (if (= "n" Input) false (do (shen.prhush "please answer y or n
" (stoutput)) (y-or-n? V1664))))))))

(defun not (V1665) (if V1665 false true))

(defun subst (V1675 V1676 V1677) (cond ((= V1677 V1676) V1675) ((cons? V1677) (map (lambda W (subst V1675 V1676 W)) V1677)) (true V1677)))

(defun explode (V1678) (shen.explode-h (shen.app V1678 "" shen.a)))

(defun shen.explode-h (V1679) (cond ((= "" V1679) ()) ((shen.+string? V1679) (cons (pos V1679 0) (shen.explode-h (tlstr V1679)))) (true (shen.f_error shen.explode-h))))

(defun cd (V1680) (set *home-directory* (if (= V1680 "") "" (shen.app V1680 "/" shen.a))))

(defun map (V1681 V1682) (shen.map-h V1681 V1682 ()))

(defun shen.map-h (V1685 V1686 V1687) (cond ((= () V1686) (reverse V1687)) ((cons? V1686) (shen.map-h V1685 (tl V1686) (cons (V1685 (hd V1686)) V1687))) (true (shen.f_error shen.map-h))))

(defun length (V1688) (shen.length-h V1688 0))

(defun shen.length-h (V1689 V1690) (cond ((= () V1689) V1690) (true (shen.length-h (tl V1689) (+ V1690 1)))))

(defun occurrences (V1700 V1701) (cond ((= V1701 V1700) 1) ((cons? V1701) (+ (occurrences V1700 (hd V1701)) (occurrences V1700 (tl V1701)))) (true 0)))

(defun nth (V1708 V1709) (cond ((and (= 1 V1708) (cons? V1709)) (hd V1709)) ((cons? V1709) (nth (- V1708 1) (tl V1709))) (true (shen.f_error nth))))

(defun integer? (V1710) (and (number? V1710) (let Abs (shen.abs V1710) (shen.integer-test? Abs (shen.magless Abs 1)))))

(defun shen.abs (V1711) (if (> V1711 0) V1711 (- 0 V1711)))

(defun shen.magless (V1712 V1713) (let Nx2 (* V1713 2) (if (> Nx2 V1712) V1713 (shen.magless V1712 Nx2))))

(defun shen.integer-test? (V1717 V1718) (cond ((= 0 V1717) true) ((> 1 V1717) false) (true (let Abs-N (- V1717 V1718) (if (> 0 Abs-N) (integer? V1717) (shen.integer-test? Abs-N V1718))))))

(defun mapcan (V1721 V1722) (cond ((= () V1722) ()) ((cons? V1722) (append (V1721 (hd V1722)) (mapcan V1721 (tl V1722)))) (true (shen.f_error mapcan))))

(defun == (V1732 V1733) (cond ((= V1733 V1732) true) (true false)))

(defun abort () (simple-error ""))

(defun bound? (V1734) (and (symbol? V1734) (let Val (trap-error (value V1734) (lambda E shen.this-symbol-is-unbound)) (if (= Val shen.this-symbol-is-unbound) false true))))

(defun shen.string->bytes (V1735) (cond ((= "" V1735) ()) (true (cons (string->n (pos V1735 0)) (shen.string->bytes (tlstr V1735))))))

(defun maxinferences (V1736) (set shen.*maxinferences* V1736))

(defun inferences () (value shen.*infs*))

(defun protect (V1737) V1737)

(defun stoutput () (value *stoutput*))

(defun string->symbol (V1738) (let Symbol (intern V1738) (if (symbol? Symbol) Symbol (simple-error (cn "cannot intern " (shen.app V1738 " to a symbol" shen.s))))))

(defun optimise (V1743) (cond ((= + V1743) (set shen.*optimise* true)) ((= - V1743) (set shen.*optimise* false)) (true (simple-error "optimise expects a + or a -.
"))))

(defun os () (value *os*))

(defun language () (value *language*))

(defun version () (value *version*))

(defun port () (value *port*))

(defun porters () (value *porters*))

(defun implementation () (value *implementation*))

(defun release () (value *release*))

(defun package? (V1744) (trap-error (do (external V1744) true) (lambda E false)))



