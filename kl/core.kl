"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.shen->kl (V614 V615) (compile (lambda X608 (shen.<define> X608)) (cons V614 V615) (lambda X (shen.shen-syntax-error V614 X))))

(defun shen.shen-syntax-error (V616 V617) (simple-error (cn "syntax error in " (shen.app V616 (cn " here:

 " (shen.app (shen.next-50 50 V617) "
" shen.a)) shen.a))))

(defun shen.<define> (V622) (let Result (let Parse_shen.<name> (shen.<name> V622) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<name> (shen.<name> V622) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<name> (V627) (let Result (if (cons? (hd V627)) (let Parse_X (hd (hd V627)) (shen.pair (hd (shen.pair (tl (hd V627)) (shen.hdtl V627))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.sysfunc? (V628) (element? V628 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V633) (let Result (if (and (cons? (hd V633)) (= { (hd (hd V633)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V633)) (shen.hdtl V633))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.curry-type (V634) (cond ((and (cons? V634) (and (cons? (tl V634)) (and (= --> (hd (tl V634))) (and (cons? (tl (tl V634))) (and (cons? (tl (tl (tl V634)))) (= --> (hd (tl (tl (tl V634)))))))))) (shen.curry-type (cons (hd V634) (cons --> (cons (tl (tl V634)) ()))))) ((and (cons? V634) (and (cons? (tl V634)) (and (= * (hd (tl V634))) (and (cons? (tl (tl V634))) (and (cons? (tl (tl (tl V634)))) (= * (hd (tl (tl (tl V634)))))))))) (shen.curry-type (cons (hd V634) (cons * (cons (tl (tl V634)) ()))))) ((cons? V634) (map (lambda X609 (shen.curry-type X609)) V634)) (true V634)))

(defun shen.<signature-help> (V639) (let Result (if (cons? (hd V639)) (let Parse_X (hd (hd V639)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V639)) (shen.hdtl V639))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V639) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<rules> (V644) (let Result (let Parse_shen.<rule> (shen.<rule> V644) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<rule> (shen.<rule> V644) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<rule> (V649) (let Result (let Parse_shen.<patterns> (shen.<patterns> V649) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<patterns> (shen.<patterns> V649) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<patterns> (shen.<patterns> V649) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<patterns> (shen.<patterns> V649) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)))

(defun shen.fail_if (V650 V651) (if (V650 V651) (fail) V651))

(defun shen.succeeds? (V656) (cond ((= V656 (fail)) false) (true true)))

(defun shen.<patterns> (V661) (let Result (let Parse_shen.<pattern> (shen.<pattern> V661) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V661) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<pattern> (V666) (let Result (if (and (cons? (hd V666)) (cons? (hd (hd V666)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (= @p (hd (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V666)) (shen.hdtl V666))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V666)) (cons? (hd (hd V666)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (= cons (hd (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V666)) (shen.hdtl V666))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V666)) (cons? (hd (hd V666)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (= @v (hd (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V666)) (shen.hdtl V666))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V666)) (cons? (hd (hd V666)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (= @s (hd (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V666)) (shen.hdtl V666))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V666)) (cons? (hd (hd V666)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (= vector (hd (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666)))))))) (shen.pair (hd (shen.pair (tl (hd (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666)))))) (shen.hdtl (shen.pair (tl (hd (shen.pair (hd (hd V666)) (shen.hdtl V666)))) (shen.hdtl (shen.pair (hd (hd V666)) (shen.hdtl V666))))))) (shen.pair (hd (shen.pair (tl (hd V666)) (shen.hdtl V666))) (cons vector (cons 0 ())))) (fail)) (fail))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V666)) (let Parse_X (hd (hd V666)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V666)) (shen.hdtl V666))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= Result (fail)) (let Result (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V666) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.constructor-error (V667) (simple-error (shen.app V667 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V672) (let Result (if (cons? (hd V672)) (let Parse_X (hd (hd V672)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V672)) (shen.hdtl V672))) (gensym Parse_Y)) (fail))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V672)) (let Parse_X (hd (hd V672)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V672)) (shen.hdtl V672))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<pattern1> (V677) (let Result (let Parse_shen.<pattern> (shen.<pattern> V677) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<pattern2> (V682) (let Result (let Parse_shen.<pattern> (shen.<pattern> V682) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<action> (V687) (let Result (if (cons? (hd V687)) (let Parse_X (hd (hd V687)) (shen.pair (hd (shen.pair (tl (hd V687)) (shen.hdtl V687))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<guard> (V692) (let Result (if (cons? (hd V692)) (let Parse_X (hd (hd V692)) (shen.pair (hd (shen.pair (tl (hd V692)) (shen.hdtl V692))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.compile_to_machine_code (V693 V694) (let Lambda+ (shen.compile_to_lambda+ V693 V694) (let KL (shen.compile_to_kl V693 Lambda+) (let Record (shen.record-source V693 KL) KL))))

(defun shen.record-source (V697 V698) (cond ((value shen.*installing-kl*) shen.skip) (true (put V697 shen.source V698 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V699 V700) (let Arity (shen.aritycheck V699 V700) (let Free (map (lambda Rule (shen.free_variable_check V699 Rule)) V700) (let Variables (shen.parameters Arity) (let Strip (map (lambda X610 (shen.strip-protect X610)) V700) (let Abstractions (map (lambda X611 (shen.abstract_rule X611)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ())))))))))

(defun shen.free_variable_check (V701 V702) (cond ((and (cons? V702) (and (cons? (tl V702)) (= () (tl (tl V702))))) (let Bound (shen.extract_vars (hd V702)) (let Free (shen.extract_free_vars Bound (hd (tl V702))) (shen.free_variable_warnings V701 Free)))) (true (shen.sys-error shen.free_variable_check))))

(defun shen.extract_vars (V703) (cond ((variable? V703) (cons V703 ())) ((cons? V703) (union (shen.extract_vars (hd V703)) (shen.extract_vars (tl V703)))) (true ())))

(defun shen.extract_free_vars (V713 V714) (cond ((and (cons? V714) (and (cons? (tl V714)) (and (= () (tl (tl V714))) (= (hd V714) protect)))) ()) ((and (variable? V714) (not (element? V714 V713))) (cons V714 ())) ((and (cons? V714) (and (= lambda (hd V714)) (and (cons? (tl V714)) (and (cons? (tl (tl V714))) (= () (tl (tl (tl V714)))))))) (shen.extract_free_vars (cons (hd (tl V714)) V713) (hd (tl (tl V714))))) ((and (cons? V714) (and (= let (hd V714)) (and (cons? (tl V714)) (and (cons? (tl (tl V714))) (and (cons? (tl (tl (tl V714)))) (= () (tl (tl (tl (tl V714)))))))))) (union (shen.extract_free_vars V713 (hd (tl (tl V714)))) (shen.extract_free_vars (cons (hd (tl V714)) V713) (hd (tl (tl (tl V714))))))) ((cons? V714) (union (shen.extract_free_vars V713 (hd V714)) (shen.extract_free_vars V713 (tl V714)))) (true ())))

(defun shen.free_variable_warnings (V717 V718) (cond ((= () V718) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V717 (cn ": " (shen.app (shen.list_variables V718) "" shen.a)) shen.a))))))

(defun shen.list_variables (V719) (cond ((and (cons? V719) (= () (tl V719))) (cn (str (hd V719)) ".")) ((cons? V719) (cn (str (hd V719)) (cn ", " (shen.list_variables (tl V719))))) (true (shen.sys-error shen.list_variables))))

(defun shen.strip-protect (V720) (cond ((and (cons? V720) (and (cons? (tl V720)) (and (= () (tl (tl V720))) (= (hd V720) protect)))) (hd (tl V720))) ((cons? V720) (cons (shen.strip-protect (hd V720)) (shen.strip-protect (tl V720)))) (true V720)))

(defun shen.linearise (V721) (cond ((and (cons? V721) (and (cons? (tl V721)) (= () (tl (tl V721))))) (shen.linearise_help (shen.flatten (hd V721)) (hd V721) (hd (tl V721)))) (true (shen.sys-error shen.linearise))))

(defun shen.flatten (V722) (cond ((= () V722) ()) ((cons? V722) (append (shen.flatten (hd V722)) (shen.flatten (tl V722)))) (true (cons V722 ()))))

(defun shen.linearise_help (V723 V724 V725) (cond ((= () V723) (cons V724 (cons V725 ()))) ((cons? V723) (if (and (variable? (hd V723)) (element? (hd V723) (tl V723))) (let Var (gensym (hd V723)) (let NewAction (cons where (cons (cons = (cons (hd V723) (cons Var ()))) (cons V725 ()))) (let NewPatts (shen.linearise_X (hd V723) Var V724) (shen.linearise_help (tl V723) NewPatts NewAction)))) (shen.linearise_help (tl V723) V724 V725))) (true (shen.sys-error shen.linearise_help))))

(defun shen.linearise_X (V734 V735 V736) (cond ((= V736 V734) V735) ((cons? V736) (let L (shen.linearise_X V734 V735 (hd V736)) (if (= L (hd V736)) (cons (hd V736) (shen.linearise_X V734 V735 (tl V736))) (cons L (tl V736))))) (true V736)))

(defun shen.aritycheck (V738 V739) (cond ((and (cons? V739) (and (cons? (hd V739)) (and (cons? (tl (hd V739))) (and (= () (tl (tl (hd V739)))) (= () (tl V739)))))) (do (shen.aritycheck-action (hd (tl (hd V739)))) (shen.aritycheck-name V738 (arity V738) (length (hd (hd V739)))))) ((and (cons? V739) (and (cons? (hd V739)) (and (cons? (tl (hd V739))) (and (= () (tl (tl (hd V739)))) (and (cons? (tl V739)) (and (cons? (hd (tl V739))) (and (cons? (tl (hd (tl V739)))) (= () (tl (tl (hd (tl V739)))))))))))) (if (= (length (hd (hd V739))) (length (hd (hd (tl V739))))) (do (shen.aritycheck-action (hd (tl (hd V739)))) (shen.aritycheck V738 (tl V739))) (simple-error (cn "arity error in " (shen.app V738 "
" shen.a))))) (true (shen.sys-error shen.aritycheck))))

(defun shen.aritycheck-name (V748 V749 V750) (cond ((= -1 V749) V750) ((= V750 V749) V750) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V748 " can cause errors.
" shen.a)) (stoutput)) V750))))

(defun shen.aritycheck-action (V756) (cond ((cons? V756) (do (shen.aah (hd V756) (tl V756)) (map (lambda X612 (shen.aritycheck-action X612)) V756))) (true shen.skip)))

(defun shen.aah (V757 V758) (let Arity (arity V757) (let Len (length V758) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V757 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V759) (cond ((and (cons? V759) (and (cons? (tl V759)) (= () (tl (tl V759))))) (shen.abstraction_build (hd V759) (hd (tl V759)))) (true (shen.sys-error shen.abstract_rule))))

(defun shen.abstraction_build (V760 V761) (cond ((= () V760) V761) ((cons? V760) (cons /. (cons (hd V760) (cons (shen.abstraction_build (tl V760) V761) ())))) (true (shen.sys-error shen.abstraction_build))))

(defun shen.parameters (V762) (cond ((= 0 V762) ()) (true (cons (gensym V) (shen.parameters (- V762 1))))))

(defun shen.application_build (V763 V764) (cond ((= () V763) V764) ((cons? V763) (shen.application_build (tl V763) (cons V764 (cons (hd V763) ())))) (true (shen.sys-error shen.application_build))))

(defun shen.compile_to_kl (V765 V766) (cond ((and (cons? V766) (and (cons? (tl V766)) (= () (tl (tl V766))))) (let Arity (shen.store-arity V765 (length (hd V766))) (let Reduce (map (lambda X613 (shen.reduce X613)) (hd (tl V766))) (let CondExpression (shen.cond-expression V765 (hd V766) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V765) (hd V766)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V766) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V765 (cons (hd V766) (cons TypedCondExpression ())))) KL))))))) (true (shen.sys-error shen.compile_to_kl))))

(defun shen.get-type (V771) (cond ((cons? V771) shen.skip) (true (let FType (assoc V771 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V780 V781) (cond ((and (cons? V780) (and (cons? (tl V780)) (and (= --> (hd (tl V780))) (and (cons? (tl (tl V780))) (and (= () (tl (tl (tl V780)))) (cons? V781)))))) (if (variable? (hd V780)) (shen.typextable (hd (tl (tl V780))) (tl V781)) (cons (cons (hd V781) (hd V780)) (shen.typextable (hd (tl (tl V780))) (tl V781))))) (true ())))

(defun shen.assign-types (V782 V783 V784) (cond ((and (cons? V784) (and (= let (hd V784)) (and (cons? (tl V784)) (and (cons? (tl (tl V784))) (and (cons? (tl (tl (tl V784)))) (= () (tl (tl (tl (tl V784)))))))))) (cons let (cons (hd (tl V784)) (cons (shen.assign-types V782 V783 (hd (tl (tl V784)))) (cons (shen.assign-types (cons (hd (tl V784)) V782) V783 (hd (tl (tl (tl V784))))) ()))))) ((and (cons? V784) (and (= lambda (hd V784)) (and (cons? (tl V784)) (and (cons? (tl (tl V784))) (= () (tl (tl (tl V784)))))))) (cons lambda (cons (hd (tl V784)) (cons (shen.assign-types (cons (hd (tl V784)) V782) V783 (hd (tl (tl V784)))) ())))) ((and (cons? V784) (= cond (hd V784))) (cons cond (map (lambda Y (cons (shen.assign-types V782 V783 (hd Y)) (cons (shen.assign-types V782 V783 (hd (tl Y))) ()))) (tl V784)))) ((cons? V784) (let NewTable (shen.typextable (shen.get-type (hd V784)) (tl V784)) (cons (hd V784) (map (lambda Y (shen.assign-types V782 (append V783 NewTable) Y)) (tl V784))))) (true (let AtomType (assoc V784 V783) (if (cons? AtomType) (cons type (cons V784 (cons (tl AtomType) ()))) (if (element? V784 V782) V784 (shen.atom-type V784)))))))

(defun shen.atom-type (V785) (if (string? V785) (cons type (cons V785 (cons string ()))) (if (number? V785) (cons type (cons V785 (cons number ()))) (if (boolean? V785) (cons type (cons V785 (cons boolean ()))) (if (symbol? V785) (cons type (cons V785 (cons symbol ()))) V785)))))

(defun shen.store-arity (V788 V789) (cond ((value shen.*installing-kl*) shen.skip) (true (put V788 arity V789 (value *property-vector*)))))

(defun shen.reduce (V790) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V790) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V791) (cond ((and (cons? V791) (and (cons? (hd V791)) (and (= /. (hd (hd V791))) (and (cons? (tl (hd V791))) (and (cons? (hd (tl (hd V791)))) (and (= cons (hd (hd (tl (hd V791))))) (and (cons? (tl (hd (tl (hd V791))))) (and (cons? (tl (tl (hd (tl (hd V791)))))) (and (= () (tl (tl (tl (hd (tl (hd V791))))))) (and (cons? (tl (tl (hd V791)))) (and (= () (tl (tl (tl (hd V791))))) (and (cons? (tl V791)) (= () (tl (tl V791))))))))))))))) (do (shen.add_test (cons cons? (tl V791))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V791))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V791)))))) (cons (shen.ebr (hd (tl V791)) (hd (tl (hd V791))) (hd (tl (tl (hd V791))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V791)) ())) (cons (cons tl (tl V791)) ())) (shen.reduce_help Application))))) ((and (cons? V791) (and (cons? (hd V791)) (and (= /. (hd (hd V791))) (and (cons? (tl (hd V791))) (and (cons? (hd (tl (hd V791)))) (and (= @p (hd (hd (tl (hd V791))))) (and (cons? (tl (hd (tl (hd V791))))) (and (cons? (tl (tl (hd (tl (hd V791)))))) (and (= () (tl (tl (tl (hd (tl (hd V791))))))) (and (cons? (tl (tl (hd V791)))) (and (= () (tl (tl (tl (hd V791))))) (and (cons? (tl V791)) (= () (tl (tl V791))))))))))))))) (do (shen.add_test (cons tuple? (tl V791))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V791))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V791)))))) (cons (shen.ebr (hd (tl V791)) (hd (tl (hd V791))) (hd (tl (tl (hd V791))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V791)) ())) (cons (cons snd (tl V791)) ())) (shen.reduce_help Application))))) ((and (cons? V791) (and (cons? (hd V791)) (and (= /. (hd (hd V791))) (and (cons? (tl (hd V791))) (and (cons? (hd (tl (hd V791)))) (and (= @v (hd (hd (tl (hd V791))))) (and (cons? (tl (hd (tl (hd V791))))) (and (cons? (tl (tl (hd (tl (hd V791)))))) (and (= () (tl (tl (tl (hd (tl (hd V791))))))) (and (cons? (tl (tl (hd V791)))) (and (= () (tl (tl (tl (hd V791))))) (and (cons? (tl V791)) (= () (tl (tl V791))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V791))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V791))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V791)))))) (cons (shen.ebr (hd (tl V791)) (hd (tl (hd V791))) (hd (tl (tl (hd V791))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V791)) ())) (cons (cons tlv (tl V791)) ())) (shen.reduce_help Application))))) ((and (cons? V791) (and (cons? (hd V791)) (and (= /. (hd (hd V791))) (and (cons? (tl (hd V791))) (and (cons? (hd (tl (hd V791)))) (and (= @s (hd (hd (tl (hd V791))))) (and (cons? (tl (hd (tl (hd V791))))) (and (cons? (tl (tl (hd (tl (hd V791)))))) (and (= () (tl (tl (tl (hd (tl (hd V791))))))) (and (cons? (tl (tl (hd V791)))) (and (= () (tl (tl (tl (hd V791))))) (and (cons? (tl V791)) (= () (tl (tl V791))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V791))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V791))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V791)))))) (cons (shen.ebr (hd (tl V791)) (hd (tl (hd V791))) (hd (tl (tl (hd V791))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V791)) (cons 0 ()))) ())) (cons (cons tlstr (tl V791)) ())) (shen.reduce_help Application))))) ((and (cons? V791) (and (cons? (hd V791)) (and (= /. (hd (hd V791))) (and (cons? (tl (hd V791))) (and (cons? (tl (tl (hd V791)))) (and (= () (tl (tl (tl (hd V791))))) (and (cons? (tl V791)) (and (= () (tl (tl V791))) (not (variable? (hd (tl (hd V791))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V791))) (tl V791)))) (shen.reduce_help (hd (tl (tl (hd V791))))))) ((and (cons? V791) (and (cons? (hd V791)) (and (= /. (hd (hd V791))) (and (cons? (tl (hd V791))) (and (cons? (tl (tl (hd V791)))) (and (= () (tl (tl (tl (hd V791))))) (and (cons? (tl V791)) (= () (tl (tl V791)))))))))) (shen.reduce_help (shen.ebr (hd (tl V791)) (hd (tl (hd V791))) (hd (tl (tl (hd V791))))))) ((and (cons? V791) (and (= where (hd V791)) (and (cons? (tl V791)) (and (cons? (tl (tl V791))) (= () (tl (tl (tl V791)))))))) (do (shen.add_test (hd (tl V791))) (shen.reduce_help (hd (tl (tl V791)))))) ((and (cons? V791) (and (cons? (tl V791)) (= () (tl (tl V791))))) (let Z (shen.reduce_help (hd V791)) (if (= (hd V791) Z) V791 (shen.reduce_help (cons Z (tl V791)))))) (true V791)))

(defun shen.+string? (V792) (cond ((= "" V792) false) (true (string? V792))))

(defun shen.+vector (V793) (cond ((= V793 (vector 0)) false) (true (vector? V793))))

(defun shen.ebr (V802 V803 V804) (cond ((= V804 V803) V802) ((and (cons? V804) (and (= /. (hd V804)) (and (cons? (tl V804)) (and (cons? (tl (tl V804))) (and (= () (tl (tl (tl V804)))) (> (occurrences V803 (hd (tl V804))) 0)))))) V804) ((and (cons? V804) (and (= let (hd V804)) (and (cons? (tl V804)) (and (cons? (tl (tl V804))) (and (cons? (tl (tl (tl V804)))) (and (= () (tl (tl (tl (tl V804))))) (= (hd (tl V804)) V803))))))) (cons let (cons (hd (tl V804)) (cons (shen.ebr V802 (hd (tl V804)) (hd (tl (tl V804)))) (tl (tl (tl V804))))))) ((cons? V804) (cons (shen.ebr V802 V803 (hd V804)) (shen.ebr V802 V803 (tl V804)))) (true V804)))

(defun shen.add_test (V807) (set shen.*teststack* (cons V807 (value shen.*teststack*))))

(defun shen.cond-expression (V808 V809 V810) (let Err (shen.err-condition V808) (let Cases (shen.case-form V810 Err) (let EncodeChoices (shen.encode-choices Cases V808) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V813) (cond ((and (cons? V813) (and (cons? (hd V813)) (and (= true (hd (hd V813))) (and (cons? (tl (hd V813))) (= () (tl (tl (hd V813)))))))) (hd (tl (hd V813)))) (true (cons cond V813))))

(defun shen.encode-choices (V816 V817) (cond ((= () V816) ()) ((and (cons? V816) (and (cons? (hd V816)) (and (= true (hd (hd V816))) (and (cons? (tl (hd V816))) (and (cons? (hd (tl (hd V816)))) (and (= shen.choicepoint! (hd (hd (tl (hd V816))))) (and (cons? (tl (hd (tl (hd V816))))) (and (= () (tl (tl (hd (tl (hd V816)))))) (and (= () (tl (tl (hd V816)))) (= () (tl V816))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V816))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V817 ())) (cons shen.f_error (cons V817 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V816) (and (cons? (hd V816)) (and (= true (hd (hd V816))) (and (cons? (tl (hd V816))) (and (cons? (hd (tl (hd V816)))) (and (= shen.choicepoint! (hd (hd (tl (hd V816))))) (and (cons? (tl (hd (tl (hd V816))))) (and (= () (tl (tl (hd (tl (hd V816)))))) (= () (tl (tl (hd V816)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V816))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V816) V817)) (cons Result ())))) ())))) ())) ())) ((and (cons? V816) (and (cons? (hd V816)) (and (cons? (tl (hd V816))) (and (cons? (hd (tl (hd V816)))) (and (= shen.choicepoint! (hd (hd (tl (hd V816))))) (and (cons? (tl (hd (tl (hd V816))))) (and (= () (tl (tl (hd (tl (hd V816)))))) (= () (tl (tl (hd V816))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V816) V817)) ())) (cons (cons if (cons (hd (hd V816)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V816))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V816) (and (cons? (hd V816)) (and (cons? (tl (hd V816))) (= () (tl (tl (hd V816))))))) (cons (hd V816) (shen.encode-choices (tl V816) V817))) (true (shen.sys-error shen.encode-choices))))

(defun shen.case-form (V822 V823) (cond ((= () V822) (cons V823 ())) ((and (cons? V822) (and (cons? (hd V822)) (and (cons? (hd (hd V822))) (and (= : (hd (hd (hd V822)))) (and (cons? (tl (hd (hd V822)))) (and (= shen.tests (hd (tl (hd (hd V822))))) (and (= () (tl (tl (hd (hd V822))))) (and (cons? (tl (hd V822))) (and (cons? (hd (tl (hd V822)))) (and (= shen.choicepoint! (hd (hd (tl (hd V822))))) (and (cons? (tl (hd (tl (hd V822))))) (and (= () (tl (tl (hd (tl (hd V822)))))) (= () (tl (tl (hd V822)))))))))))))))) (cons (cons true (tl (hd V822))) (shen.case-form (tl V822) V823))) ((and (cons? V822) (and (cons? (hd V822)) (and (cons? (hd (hd V822))) (and (= : (hd (hd (hd V822)))) (and (cons? (tl (hd (hd V822)))) (and (= shen.tests (hd (tl (hd (hd V822))))) (and (= () (tl (tl (hd (hd V822))))) (and (cons? (tl (hd V822))) (= () (tl (tl (hd V822)))))))))))) (cons (cons true (tl (hd V822))) ())) ((and (cons? V822) (and (cons? (hd V822)) (and (cons? (hd (hd V822))) (and (= : (hd (hd (hd V822)))) (and (cons? (tl (hd (hd V822)))) (and (= shen.tests (hd (tl (hd (hd V822))))) (and (cons? (tl (hd V822))) (= () (tl (tl (hd V822))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V822))))) (tl (hd V822))) (shen.case-form (tl V822) V823))) (true (shen.sys-error shen.case-form))))

(defun shen.embed-and (V824) (cond ((and (cons? V824) (= () (tl V824))) (hd V824)) ((cons? V824) (cons and (cons (hd V824) (cons (shen.embed-and (tl V824)) ())))) (true (shen.sys-error shen.embed-and))))

(defun shen.err-condition (V825) (cons true (cons (cons shen.f_error (cons V825 ())) ())))

(defun shen.sys-error (V826) (simple-error (cn "system function " (shen.app V826 ": unexpected argument
" shen.a))))



