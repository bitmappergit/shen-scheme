"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen->kl (V549 V550) (compile (lambda V542 (shen.<define> V542)) (cons V549 V550) (lambda X (shen.shen-syntax-error V549 X))))

(defun shen.shen-syntax-error (V551 V552) (simple-error (cn "syntax error in " (shen.app V551 (cn " here:

 " (shen.app (shen.next-50 50 V552) "
" shen.a)) shen.a))))

(defun shen.<define> (V553) (let YaccParse (let Parse_shen.<name> (shen.<name> V553) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V553) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V554) (if (cons? (hd V554)) (let Parse_X (hd (hd V554)) (shen.pair (hd (shen.pair (tl (hd V554)) (shen.hdtl V554))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V555) (element? V555 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V556) (if (and (cons? (hd V556)) (= { (hd (hd V556)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V556)) (shen.hdtl V556))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V557) (cond ((and (cons? V557) (and (cons? (tl V557)) (and (= --> (hd (tl V557))) (and (cons? (tl (tl V557))) (and (cons? (tl (tl (tl V557)))) (= --> (hd (tl (tl (tl V557)))))))))) (shen.curry-type (cons (hd V557) (cons --> (cons (tl (tl V557)) ()))))) ((and (cons? V557) (and (cons? (tl V557)) (and (= * (hd (tl V557))) (and (cons? (tl (tl V557))) (and (cons? (tl (tl (tl V557)))) (= * (hd (tl (tl (tl V557)))))))))) (shen.curry-type (cons (hd V557) (cons * (cons (tl (tl V557)) ()))))) ((cons? V557) (map (lambda V543 (shen.curry-type V543)) V557)) (true V557)))

(defun shen.<signature-help> (V558) (let YaccParse (if (cons? (hd V558)) (let Parse_X (hd (hd V558)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V558)) (shen.hdtl V558))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V558) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V559) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V559) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V559) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V560) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V560) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V560) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V560) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V560) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V561 V562) (if (V561 V562) (fail) V562))

(defun shen.succeeds? (V567) (cond ((= V567 (fail)) false) (true true)))

(defun shen.<patterns> (V568) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V568) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V568) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V574) (let YaccParse (if (and (cons? (hd V574)) (cons? (hd (hd V574)))) (if (and (cons? (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (= @p (hd (hd (shen.pair (hd (hd V574)) (hd (tl V574))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (shen.hdtl (shen.pair (hd (hd V574)) (hd (tl V574)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V574)) (hd (tl V574)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V574)) (cons? (hd (hd V574)))) (if (and (cons? (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (= cons (hd (hd (shen.pair (hd (hd V574)) (hd (tl V574))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (shen.hdtl (shen.pair (hd (hd V574)) (hd (tl V574)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V574)) (hd (tl V574)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V574)) (cons? (hd (hd V574)))) (if (and (cons? (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (= @v (hd (hd (shen.pair (hd (hd V574)) (hd (tl V574))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (shen.hdtl (shen.pair (hd (hd V574)) (hd (tl V574)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V574)) (hd (tl V574)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V574)) (cons? (hd (hd V574)))) (if (and (cons? (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (= @s (hd (hd (shen.pair (hd (hd V574)) (hd (tl V574))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (shen.hdtl (shen.pair (hd (hd V574)) (hd (tl V574)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V574)) (hd (tl V574)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V574)) (cons? (hd (hd V574)))) (if (and (cons? (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (= vector (hd (hd (shen.pair (hd (hd V574)) (hd (tl V574))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (shen.hdtl (shen.pair (hd (hd V574)) (hd (tl V574))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V574)) (hd (tl V574))))) (shen.hdtl (shen.pair (hd (hd V574)) (hd (tl V574))))))))) (shen.pair (hd (shen.pair (tl (hd V574)) (hd (tl V574)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V574)) (let Parse_X (hd (hd V574)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V574)) (shen.hdtl V574))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V574) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V575) (simple-error (shen.app V575 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V576) (let YaccParse (if (cons? (hd V576)) (let Parse_X (hd (hd V576)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V576)) (shen.hdtl V576))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V576)) (let Parse_X (hd (hd V576)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V576)) (shen.hdtl V576))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V577) (let Parse_shen.<pattern> (shen.<pattern> V577) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V578) (let Parse_shen.<pattern> (shen.<pattern> V578) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V579) (if (cons? (hd V579)) (let Parse_X (hd (hd V579)) (shen.pair (hd (shen.pair (tl (hd V579)) (shen.hdtl V579))) Parse_X)) (fail)))

(defun shen.<guard> (V580) (if (cons? (hd V580)) (let Parse_X (hd (hd V580)) (shen.pair (hd (shen.pair (tl (hd V580)) (shen.hdtl V580))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V581 V582) (let Lambda+ (shen.compile_to_lambda+ V581 V582) (let KL (shen.compile_to_kl V581 Lambda+) (let Record (shen.record-source V581 KL) KL))))

(defun shen.record-source (V585 V586) (cond ((value shen.*installing-kl*) shen.skip) (true (put V585 shen.source V586 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V587 V588) (let Arity (shen.aritycheck V587 V588) (let Free (map (lambda Rule (shen.free_variable_check V587 Rule)) V588) (let Variables (shen.parameters Arity) (let Strip (map (lambda V544 (shen.strip-protect V544)) V588) (let Abstractions (map (lambda V545 (shen.abstract_rule V545)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ())))))))))

(defun shen.free_variable_check (V589 V590) (cond ((and (cons? V590) (and (cons? (tl V590)) (= () (tl (tl V590))))) (let Bound (shen.extract_vars (hd V590)) (let Free (shen.extract_free_vars Bound (hd (tl V590))) (shen.free_variable_warnings V589 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V591) (cond ((variable? V591) (cons V591 ())) ((cons? V591) (union (shen.extract_vars (hd V591)) (shen.extract_vars (tl V591)))) (true ())))

(defun shen.extract_free_vars (V601 V602) (cond ((and (cons? V602) (and (cons? (tl V602)) (and (= () (tl (tl V602))) (= (hd V602) protect)))) ()) ((and (variable? V602) (not (element? V602 V601))) (cons V602 ())) ((and (cons? V602) (and (= lambda (hd V602)) (and (cons? (tl V602)) (and (cons? (tl (tl V602))) (= () (tl (tl (tl V602)))))))) (shen.extract_free_vars (cons (hd (tl V602)) V601) (hd (tl (tl V602))))) ((and (cons? V602) (and (= let (hd V602)) (and (cons? (tl V602)) (and (cons? (tl (tl V602))) (and (cons? (tl (tl (tl V602)))) (= () (tl (tl (tl (tl V602)))))))))) (union (shen.extract_free_vars V601 (hd (tl (tl V602)))) (shen.extract_free_vars (cons (hd (tl V602)) V601) (hd (tl (tl (tl V602))))))) ((cons? V602) (union (shen.extract_free_vars V601 (hd V602)) (shen.extract_free_vars V601 (tl V602)))) (true ())))

(defun shen.free_variable_warnings (V605 V606) (cond ((= () V606) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V605 (cn ": " (shen.app (shen.list_variables V606) "" shen.a)) shen.a))))))

(defun shen.list_variables (V607) (cond ((and (cons? V607) (= () (tl V607))) (cn (str (hd V607)) ".")) ((cons? V607) (cn (str (hd V607)) (cn ", " (shen.list_variables (tl V607))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V608) (cond ((and (cons? V608) (and (cons? (tl V608)) (and (= () (tl (tl V608))) (= (hd V608) protect)))) (shen.strip-protect (hd (tl V608)))) ((cons? V608) (map (lambda V546 (shen.strip-protect V546)) V608)) (true V608)))

(defun shen.linearise (V609) (cond ((and (cons? V609) (and (cons? (tl V609)) (= () (tl (tl V609))))) (shen.linearise_help (shen.flatten (hd V609)) (hd V609) (hd (tl V609)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V610) (cond ((= () V610) ()) ((cons? V610) (append (shen.flatten (hd V610)) (shen.flatten (tl V610)))) (true (cons V610 ()))))

(defun shen.linearise_help (V611 V612 V613) (cond ((= () V611) (cons V612 (cons V613 ()))) ((cons? V611) (if (and (variable? (hd V611)) (element? (hd V611) (tl V611))) (let Var (gensym (hd V611)) (let NewAction (cons where (cons (cons = (cons (hd V611) (cons Var ()))) (cons V613 ()))) (let NewPatts (shen.linearise_X (hd V611) Var V612) (shen.linearise_help (tl V611) NewPatts NewAction)))) (shen.linearise_help (tl V611) V612 V613))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V623 V624 V625) (cond ((= V625 V623) V624) ((cons? V625) (let L (shen.linearise_X V623 V624 (hd V625)) (if (= L (hd V625)) (cons (hd V625) (shen.linearise_X V623 V624 (tl V625))) (cons L (tl V625))))) (true V625)))

(defun shen.aritycheck (V626 V627) (cond ((and (cons? V627) (and (cons? (hd V627)) (and (cons? (tl (hd V627))) (and (= () (tl (tl (hd V627)))) (= () (tl V627)))))) (do (shen.aritycheck-action (hd (tl (hd V627)))) (shen.aritycheck-name V626 (arity V626) (length (hd (hd V627)))))) ((and (cons? V627) (and (cons? (hd V627)) (and (cons? (tl (hd V627))) (and (= () (tl (tl (hd V627)))) (and (cons? (tl V627)) (and (cons? (hd (tl V627))) (and (cons? (tl (hd (tl V627)))) (= () (tl (tl (hd (tl V627)))))))))))) (if (= (length (hd (hd V627))) (length (hd (hd (tl V627))))) (do (shen.aritycheck-action (hd (tl (hd V627)))) (shen.aritycheck V626 (tl V627))) (simple-error (cn "arity error in " (shen.app V626 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V637 V638 V639) (cond ((= -1 V638) V639) ((= V639 V638) V639) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V637 " can cause errors.
" shen.a)) (stoutput)) V639))))

(defun shen.aritycheck-action (V644) (cond ((cons? V644) (do (shen.aah (hd V644) (tl V644)) (map (lambda V547 (shen.aritycheck-action V547)) V644))) (true shen.skip)))

(defun shen.aah (V645 V646) (let Arity (arity V645) (let Len (length V646) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V645 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V647) (cond ((and (cons? V647) (and (cons? (tl V647)) (= () (tl (tl V647))))) (shen.abstraction_build (hd V647) (hd (tl V647)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V648 V649) (cond ((= () V648) V649) ((cons? V648) (cons /. (cons (hd V648) (cons (shen.abstraction_build (tl V648) V649) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V650) (cond ((= 0 V650) ()) (true (cons (gensym V) (shen.parameters (- V650 1))))))

(defun shen.application_build (V651 V652) (cond ((= () V651) V652) ((cons? V651) (shen.application_build (tl V651) (cons V652 (cons (hd V651) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V653 V654) (cond ((and (cons? V654) (and (cons? (tl V654)) (= () (tl (tl V654))))) (let Arity (shen.store-arity V653 (length (hd V654))) (let Reduce (map (lambda V548 (shen.reduce V548)) (hd (tl V654))) (let CondExpression (shen.cond-expression V653 (hd V654) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V653) (hd V654)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V654) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V653 (cons (hd V654) (cons TypedCondExpression ())))) KL))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V659) (cond ((cons? V659) shen.skip) (true (let FType (assoc V659 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V668 V669) (cond ((and (cons? V668) (and (cons? (tl V668)) (and (= --> (hd (tl V668))) (and (cons? (tl (tl V668))) (and (= () (tl (tl (tl V668)))) (cons? V669)))))) (if (variable? (hd V668)) (shen.typextable (hd (tl (tl V668))) (tl V669)) (cons (cons (hd V669) (hd V668)) (shen.typextable (hd (tl (tl V668))) (tl V669))))) (true ())))

(defun shen.assign-types (V670 V671 V672) (cond ((and (cons? V672) (and (= let (hd V672)) (and (cons? (tl V672)) (and (cons? (tl (tl V672))) (and (cons? (tl (tl (tl V672)))) (= () (tl (tl (tl (tl V672)))))))))) (cons let (cons (hd (tl V672)) (cons (shen.assign-types V670 V671 (hd (tl (tl V672)))) (cons (shen.assign-types (cons (hd (tl V672)) V670) V671 (hd (tl (tl (tl V672))))) ()))))) ((and (cons? V672) (and (= lambda (hd V672)) (and (cons? (tl V672)) (and (cons? (tl (tl V672))) (= () (tl (tl (tl V672)))))))) (cons lambda (cons (hd (tl V672)) (cons (shen.assign-types (cons (hd (tl V672)) V670) V671 (hd (tl (tl V672)))) ())))) ((and (cons? V672) (= cond (hd V672))) (cons cond (map (lambda Y (cons (shen.assign-types V670 V671 (hd Y)) (cons (shen.assign-types V670 V671 (hd (tl Y))) ()))) (tl V672)))) ((cons? V672) (let NewTable (shen.typextable (shen.get-type (hd V672)) (tl V672)) (cons (hd V672) (map (lambda Y (shen.assign-types V670 (append V671 NewTable) Y)) (tl V672))))) (true (let AtomType (assoc V672 V671) (if (cons? AtomType) (cons type (cons V672 (cons (tl AtomType) ()))) (if (element? V672 V670) V672 (shen.atom-type V672)))))))

(defun shen.atom-type (V673) (if (string? V673) (cons type (cons V673 (cons string ()))) (if (number? V673) (cons type (cons V673 (cons number ()))) (if (boolean? V673) (cons type (cons V673 (cons boolean ()))) (if (symbol? V673) (cons type (cons V673 (cons symbol ()))) V673)))))

(defun shen.store-arity (V676 V677) (cond ((value shen.*installing-kl*) shen.skip) (true (put V676 arity V677 (value *property-vector*)))))

(defun shen.reduce (V678) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V678) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V679) (cond ((and (cons? V679) (and (cons? (hd V679)) (and (= /. (hd (hd V679))) (and (cons? (tl (hd V679))) (and (cons? (hd (tl (hd V679)))) (and (= cons (hd (hd (tl (hd V679))))) (and (cons? (tl (hd (tl (hd V679))))) (and (cons? (tl (tl (hd (tl (hd V679)))))) (and (= () (tl (tl (tl (hd (tl (hd V679))))))) (and (cons? (tl (tl (hd V679)))) (and (= () (tl (tl (tl (hd V679))))) (and (cons? (tl V679)) (= () (tl (tl V679))))))))))))))) (do (shen.add_test (cons cons? (tl V679))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V679))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V679)))))) (cons (shen.ebr (hd (tl V679)) (hd (tl (hd V679))) (hd (tl (tl (hd V679))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V679)) ())) (cons (cons tl (tl V679)) ())) (shen.reduce_help Application))))) ((and (cons? V679) (and (cons? (hd V679)) (and (= /. (hd (hd V679))) (and (cons? (tl (hd V679))) (and (cons? (hd (tl (hd V679)))) (and (= @p (hd (hd (tl (hd V679))))) (and (cons? (tl (hd (tl (hd V679))))) (and (cons? (tl (tl (hd (tl (hd V679)))))) (and (= () (tl (tl (tl (hd (tl (hd V679))))))) (and (cons? (tl (tl (hd V679)))) (and (= () (tl (tl (tl (hd V679))))) (and (cons? (tl V679)) (= () (tl (tl V679))))))))))))))) (do (shen.add_test (cons tuple? (tl V679))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V679))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V679)))))) (cons (shen.ebr (hd (tl V679)) (hd (tl (hd V679))) (hd (tl (tl (hd V679))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V679)) ())) (cons (cons snd (tl V679)) ())) (shen.reduce_help Application))))) ((and (cons? V679) (and (cons? (hd V679)) (and (= /. (hd (hd V679))) (and (cons? (tl (hd V679))) (and (cons? (hd (tl (hd V679)))) (and (= @v (hd (hd (tl (hd V679))))) (and (cons? (tl (hd (tl (hd V679))))) (and (cons? (tl (tl (hd (tl (hd V679)))))) (and (= () (tl (tl (tl (hd (tl (hd V679))))))) (and (cons? (tl (tl (hd V679)))) (and (= () (tl (tl (tl (hd V679))))) (and (cons? (tl V679)) (= () (tl (tl V679))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V679))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V679))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V679)))))) (cons (shen.ebr (hd (tl V679)) (hd (tl (hd V679))) (hd (tl (tl (hd V679))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V679)) ())) (cons (cons tlv (tl V679)) ())) (shen.reduce_help Application))))) ((and (cons? V679) (and (cons? (hd V679)) (and (= /. (hd (hd V679))) (and (cons? (tl (hd V679))) (and (cons? (hd (tl (hd V679)))) (and (= @s (hd (hd (tl (hd V679))))) (and (cons? (tl (hd (tl (hd V679))))) (and (cons? (tl (tl (hd (tl (hd V679)))))) (and (= () (tl (tl (tl (hd (tl (hd V679))))))) (and (cons? (tl (tl (hd V679)))) (and (= () (tl (tl (tl (hd V679))))) (and (cons? (tl V679)) (= () (tl (tl V679))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V679))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V679))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V679)))))) (cons (shen.ebr (hd (tl V679)) (hd (tl (hd V679))) (hd (tl (tl (hd V679))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V679)) (cons 0 ()))) ())) (cons (cons tlstr (tl V679)) ())) (shen.reduce_help Application))))) ((and (cons? V679) (and (cons? (hd V679)) (and (= /. (hd (hd V679))) (and (cons? (tl (hd V679))) (and (cons? (tl (tl (hd V679)))) (and (= () (tl (tl (tl (hd V679))))) (and (cons? (tl V679)) (and (= () (tl (tl V679))) (not (variable? (hd (tl (hd V679))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V679))) (tl V679)))) (shen.reduce_help (hd (tl (tl (hd V679))))))) ((and (cons? V679) (and (cons? (hd V679)) (and (= /. (hd (hd V679))) (and (cons? (tl (hd V679))) (and (cons? (tl (tl (hd V679)))) (and (= () (tl (tl (tl (hd V679))))) (and (cons? (tl V679)) (= () (tl (tl V679)))))))))) (shen.reduce_help (shen.ebr (hd (tl V679)) (hd (tl (hd V679))) (hd (tl (tl (hd V679))))))) ((and (cons? V679) (and (= where (hd V679)) (and (cons? (tl V679)) (and (cons? (tl (tl V679))) (= () (tl (tl (tl V679)))))))) (do (shen.add_test (hd (tl V679))) (shen.reduce_help (hd (tl (tl V679)))))) ((and (cons? V679) (and (cons? (tl V679)) (= () (tl (tl V679))))) (let Z (shen.reduce_help (hd V679)) (if (= (hd V679) Z) V679 (shen.reduce_help (cons Z (tl V679)))))) (true V679)))

(defun shen.+string? (V680) (cond ((= "" V680) false) (true (string? V680))))

(defun shen.+vector (V681) (cond ((= V681 (vector 0)) false) (true (vector? V681))))

(defun shen.ebr (V692 V693 V694) (cond ((= V694 V693) V692) ((and (cons? V694) (and (= /. (hd V694)) (and (cons? (tl V694)) (and (cons? (tl (tl V694))) (and (= () (tl (tl (tl V694)))) (> (occurrences V693 (hd (tl V694))) 0)))))) V694) ((and (cons? V694) (and (= let (hd V694)) (and (cons? (tl V694)) (and (cons? (tl (tl V694))) (and (cons? (tl (tl (tl V694)))) (and (= () (tl (tl (tl (tl V694))))) (= (hd (tl V694)) V693))))))) (cons let (cons (hd (tl V694)) (cons (shen.ebr V692 (hd (tl V694)) (hd (tl (tl V694)))) (tl (tl (tl V694))))))) ((cons? V694) (cons (shen.ebr V692 V693 (hd V694)) (shen.ebr V692 V693 (tl V694)))) (true V694)))

(defun shen.add_test (V695) (set shen.*teststack* (cons V695 (value shen.*teststack*))))

(defun shen.cond-expression (V696 V697 V698) (let Err (shen.err-condition V696) (let Cases (shen.case-form V698 Err) (let EncodeChoices (shen.encode-choices Cases V696) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V701) (cond ((and (cons? V701) (and (cons? (hd V701)) (and (= true (hd (hd V701))) (and (cons? (tl (hd V701))) (= () (tl (tl (hd V701)))))))) (hd (tl (hd V701)))) (true (cons cond V701))))

(defun shen.encode-choices (V704 V705) (cond ((= () V704) ()) ((and (cons? V704) (and (cons? (hd V704)) (and (= true (hd (hd V704))) (and (cons? (tl (hd V704))) (and (cons? (hd (tl (hd V704)))) (and (= shen.choicepoint! (hd (hd (tl (hd V704))))) (and (cons? (tl (hd (tl (hd V704))))) (and (= () (tl (tl (hd (tl (hd V704)))))) (and (= () (tl (tl (hd V704)))) (= () (tl V704))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V704))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V705 ())) (cons shen.f_error (cons V705 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V704) (and (cons? (hd V704)) (and (= true (hd (hd V704))) (and (cons? (tl (hd V704))) (and (cons? (hd (tl (hd V704)))) (and (= shen.choicepoint! (hd (hd (tl (hd V704))))) (and (cons? (tl (hd (tl (hd V704))))) (and (= () (tl (tl (hd (tl (hd V704)))))) (= () (tl (tl (hd V704)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V704))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V704) V705)) (cons Result ())))) ())))) ())) ())) ((and (cons? V704) (and (cons? (hd V704)) (and (cons? (tl (hd V704))) (and (cons? (hd (tl (hd V704)))) (and (= shen.choicepoint! (hd (hd (tl (hd V704))))) (and (cons? (tl (hd (tl (hd V704))))) (and (= () (tl (tl (hd (tl (hd V704)))))) (= () (tl (tl (hd V704))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V704) V705)) ())) (cons (cons if (cons (hd (hd V704)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V704))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V704) (and (cons? (hd V704)) (and (cons? (tl (hd V704))) (= () (tl (tl (hd V704))))))) (cons (hd V704) (shen.encode-choices (tl V704) V705))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V710 V711) (cond ((= () V710) (cons V711 ())) ((and (cons? V710) (and (cons? (hd V710)) (and (cons? (hd (hd V710))) (and (= : (hd (hd (hd V710)))) (and (cons? (tl (hd (hd V710)))) (and (= shen.tests (hd (tl (hd (hd V710))))) (and (= () (tl (tl (hd (hd V710))))) (and (cons? (tl (hd V710))) (and (cons? (hd (tl (hd V710)))) (and (= shen.choicepoint! (hd (hd (tl (hd V710))))) (and (cons? (tl (hd (tl (hd V710))))) (and (= () (tl (tl (hd (tl (hd V710)))))) (= () (tl (tl (hd V710)))))))))))))))) (cons (cons true (tl (hd V710))) (shen.case-form (tl V710) V711))) ((and (cons? V710) (and (cons? (hd V710)) (and (cons? (hd (hd V710))) (and (= : (hd (hd (hd V710)))) (and (cons? (tl (hd (hd V710)))) (and (= shen.tests (hd (tl (hd (hd V710))))) (and (= () (tl (tl (hd (hd V710))))) (and (cons? (tl (hd V710))) (= () (tl (tl (hd V710)))))))))))) (cons (cons true (tl (hd V710))) ())) ((and (cons? V710) (and (cons? (hd V710)) (and (cons? (hd (hd V710))) (and (= : (hd (hd (hd V710)))) (and (cons? (tl (hd (hd V710)))) (and (= shen.tests (hd (tl (hd (hd V710))))) (and (cons? (tl (hd V710))) (= () (tl (tl (hd V710))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V710))))) (tl (hd V710))) (shen.case-form (tl V710) V711))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V712) (cond ((and (cons? V712) (= () (tl V712))) (hd V712)) ((cons? V712) (cons and (cons (hd V712) (cons (shen.embed-and (tl V712)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V713) (cons true (cons (cons shen.f_error (cons V713 ())) ())))

(defun shen.sys-error (V714) (simple-error (cn "system function " (shen.app V714 ": unexpected argument
" shen.a))))



