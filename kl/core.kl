"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen->kl (V1232 V1233) (compile (lambda X (shen.<define> X)) (cons V1232 V1233) (lambda X (shen-syntax-error V1232 X))))

(defun shen-syntax-error (V1240 V1241) (cond ((cons? V1241) (simple-error (cn "syntax error in " (shen.app V1240 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1241)) "
" shen.a)) shen.a)))) (true (simple-error (cn "syntax error in " (shen.app V1240 "
" shen.a))))))

(defun shen.<define> (V1243) (let YaccParse (let Parse_shen.<name> (shen.<name> V1243) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<name> (shen.<name> V1243) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) YaccParse)))

(defun shen.<name> (V1245) (if (cons? (hd V1245)) (let Parse_X (hd (hd V1245)) (shen.pair (hd (shen.pair (tl (hd V1245)) (shen.hdtl V1245))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)))

(defun shen.sysfunc? (V1247) (element? V1247 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V1249) (if (and (cons? (hd V1249)) (= { (hd (hd V1249)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1249)) (shen.hdtl V1249))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)))

(defun shen.curry-type (V1251) (cond ((and (cons? V1251) (and (cons? (tl V1251)) (and (= --> (hd (tl V1251))) (and (cons? (tl (tl V1251))) (and (cons? (tl (tl (tl V1251)))) (= --> (hd (tl (tl (tl V1251)))))))))) (shen.curry-type (cons (hd V1251) (cons --> (cons (tl (tl V1251)) ()))))) ((and (cons? V1251) (and (cons? (tl V1251)) (and (= * (hd (tl V1251))) (and (cons? (tl (tl V1251))) (and (cons? (tl (tl (tl V1251)))) (= * (hd (tl (tl (tl V1251)))))))))) (shen.curry-type (cons (hd V1251) (cons * (cons (tl (tl V1251)) ()))))) ((cons? V1251) (map (lambda Z (shen.curry-type Z)) V1251)) (true V1251)))

(defun shen.<signature-help> (V1253) (let YaccParse (if (cons? (hd V1253)) (let Parse_X (hd (hd V1253)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V1253)) (shen.hdtl V1253))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1253) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<rules> (V1255) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V1255) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V1255) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) YaccParse)))

(defun shen.<rule> (V1257) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1257) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1257) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<patterns> (shen.<patterns> V1257) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<patterns> (shen.<patterns> V1257) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) YaccParse)) YaccParse)) YaccParse)))

(defun shen.fail_if (V1260 V1261) (if (V1260 V1261) (fail) V1261))

(defun shen.succeeds? (V1267) (cond ((= V1267 (fail)) false) (true true)))

(defun shen.<patterns> (V1269) (let YaccParse (let Parse_shen.<pattern> (shen.<pattern> V1269) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1269) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<pattern> (V1276) (let YaccParse (if (and (cons? (hd V1276)) (cons? (hd (hd V1276)))) (if (and (cons? (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (= @p (hd (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (shen.hdtl (shen.pair (hd (hd V1276)) (hd (tl V1276)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1276)) (hd (tl V1276)))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1276)) (cons? (hd (hd V1276)))) (if (and (cons? (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (= cons (hd (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (shen.hdtl (shen.pair (hd (hd V1276)) (hd (tl V1276)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1276)) (hd (tl V1276)))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1276)) (cons? (hd (hd V1276)))) (if (and (cons? (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (= @v (hd (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (shen.hdtl (shen.pair (hd (hd V1276)) (hd (tl V1276)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1276)) (hd (tl V1276)))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1276)) (cons? (hd (hd V1276)))) (if (and (cons? (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (= @s (hd (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (shen.hdtl (shen.pair (hd (hd V1276)) (hd (tl V1276)))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd (shen.pair (tl (hd V1276)) (hd (tl V1276)))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ())))) (fail))) (fail))) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (and (cons? (hd V1276)) (cons? (hd (hd V1276)))) (if (and (cons? (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (= vector (hd (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (shen.hdtl (shen.pair (hd (hd V1276)) (hd (tl V1276))))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V1276)) (hd (tl V1276))))) (shen.hdtl (shen.pair (hd (hd V1276)) (hd (tl V1276))))))))) (shen.pair (hd (shen.pair (tl (hd V1276)) (hd (tl V1276)))) (cons vector (cons 0 ()))) (fail)) (fail)) (fail)) (if (= YaccParse (fail)) (let YaccParse (if (cons? (hd V1276)) (let Parse_X (hd (hd V1276)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1276)) (shen.hdtl V1276))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= YaccParse (fail)) (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V1276) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.constructor-error (V1278) (simple-error (shen.app V1278 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V1280) (let YaccParse (if (cons? (hd V1280)) (let Parse_X (hd (hd V1280)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V1280)) (shen.hdtl V1280))) (gensym Parse_Y)) (fail))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1280)) (let Parse_X (hd (hd V1280)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V1280)) (shen.hdtl V1280))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<pattern1> (V1282) (let Parse_shen.<pattern> (shen.<pattern> V1282) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<pattern2> (V1284) (let Parse_shen.<pattern> (shen.<pattern> V1284) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))))

(defun shen.<action> (V1286) (if (cons? (hd V1286)) (let Parse_X (hd (hd V1286)) (shen.pair (hd (shen.pair (tl (hd V1286)) (shen.hdtl V1286))) Parse_X)) (fail)))

(defun shen.<guard> (V1288) (if (cons? (hd V1288)) (let Parse_X (hd (hd V1288)) (shen.pair (hd (shen.pair (tl (hd V1288)) (shen.hdtl V1288))) Parse_X)) (fail)))

(defun shen.compile_to_machine_code (V1291 V1292) (let Lambda+ (shen.compile_to_lambda+ V1291 V1292) (let KL (shen.compile_to_kl V1291 Lambda+) (let Record (shen.record-source V1291 KL) KL))))

(defun shen.record-source (V1297 V1298) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1297 shen.source V1298 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V1301 V1302) (let Arity (shen.aritycheck V1301 V1302) (let UpDateSymbolTable (shen.update-symbol-table V1301 Arity) (let Free (map (lambda Rule (shen.free_variable_check V1301 Rule)) V1302) (let Variables (shen.parameters Arity) (let Strip (map (lambda X (shen.strip-protect X)) V1302) (let Abstractions (map (lambda X (shen.abstract_rule X)) Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ()))))))))))

(defun shen.update-symbol-table (V1305 V1306) (set shen.*symbol-table* (shen.update-symbol-table-h V1305 V1306 (value shen.*symbol-table*) ())))

(defun shen.update-symbol-table-h (V1314 V1315 V1316 V1317) (cond ((= () V1316) (let NewEntry (cons V1314 (eval-kl (shen.lambda-form V1314 V1315))) (cons NewEntry V1317))) ((and (cons? V1316) (and (cons? (hd V1316)) (= (hd (hd V1316)) V1314))) (let ChangedEntry (cons (hd (hd V1316)) (eval-kl (shen.lambda-form (hd (hd V1316)) V1315))) (append (tl V1316) (cons ChangedEntry V1317)))) ((cons? V1316) (shen.update-symbol-table-h V1314 V1315 (tl V1316) (cons (hd V1316) V1317))) (true (shen.f_error shen.update-symbol-table-h))))

(defun shen.free_variable_check (V1320 V1321) (cond ((and (cons? V1321) (and (cons? (tl V1321)) (= () (tl (tl V1321))))) (let Bound (shen.extract_vars (hd V1321)) (let Free (shen.extract_free_vars Bound (hd (tl V1321))) (shen.free_variable_warnings V1320 Free)))) (true (shen.f_error shen.free_variable_check))))

(defun shen.extract_vars (V1323) (cond ((variable? V1323) (cons V1323 ())) ((cons? V1323) (union (shen.extract_vars (hd V1323)) (shen.extract_vars (tl V1323)))) (true ())))

(defun shen.extract_free_vars (V1335 V1336) (cond ((and (cons? V1336) (and (cons? (tl V1336)) (and (= () (tl (tl V1336))) (= (hd V1336) protect)))) ()) ((and (variable? V1336) (not (element? V1336 V1335))) (cons V1336 ())) ((and (cons? V1336) (and (= lambda (hd V1336)) (and (cons? (tl V1336)) (and (cons? (tl (tl V1336))) (= () (tl (tl (tl V1336)))))))) (shen.extract_free_vars (cons (hd (tl V1336)) V1335) (hd (tl (tl V1336))))) ((and (cons? V1336) (and (= let (hd V1336)) (and (cons? (tl V1336)) (and (cons? (tl (tl V1336))) (and (cons? (tl (tl (tl V1336)))) (= () (tl (tl (tl (tl V1336)))))))))) (union (shen.extract_free_vars V1335 (hd (tl (tl V1336)))) (shen.extract_free_vars (cons (hd (tl V1336)) V1335) (hd (tl (tl (tl V1336))))))) ((cons? V1336) (union (shen.extract_free_vars V1335 (hd V1336)) (shen.extract_free_vars V1335 (tl V1336)))) (true ())))

(defun shen.free_variable_warnings (V1341 V1342) (cond ((= () V1342) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V1341 (cn ": " (shen.app (shen.list_variables V1342) "" shen.a)) shen.a))))))

(defun shen.list_variables (V1344) (cond ((and (cons? V1344) (= () (tl V1344))) (cn (str (hd V1344)) ".")) ((cons? V1344) (cn (str (hd V1344)) (cn ", " (shen.list_variables (tl V1344))))) (true (shen.f_error shen.list_variables))))

(defun shen.strip-protect (V1346) (cond ((and (cons? V1346) (and (cons? (tl V1346)) (and (= () (tl (tl V1346))) (= (hd V1346) protect)))) (shen.strip-protect (hd (tl V1346)))) ((cons? V1346) (map (lambda Z (shen.strip-protect Z)) V1346)) (true V1346)))

(defun shen.linearise (V1348) (cond ((and (cons? V1348) (and (cons? (tl V1348)) (= () (tl (tl V1348))))) (shen.linearise_help (shen.flatten (hd V1348)) (hd V1348) (hd (tl V1348)))) (true (shen.f_error shen.linearise))))

(defun shen.flatten (V1350) (cond ((= () V1350) ()) ((cons? V1350) (append (shen.flatten (hd V1350)) (shen.flatten (tl V1350)))) (true (cons V1350 ()))))

(defun shen.linearise_help (V1354 V1355 V1356) (cond ((= () V1354) (cons V1355 (cons V1356 ()))) ((cons? V1354) (if (and (variable? (hd V1354)) (element? (hd V1354) (tl V1354))) (let Var (gensym (hd V1354)) (let NewAction (cons where (cons (cons = (cons (hd V1354) (cons Var ()))) (cons V1356 ()))) (let NewPatts (shen.linearise_X (hd V1354) Var V1355) (shen.linearise_help (tl V1354) NewPatts NewAction)))) (shen.linearise_help (tl V1354) V1355 V1356))) (true (shen.f_error shen.linearise_help))))

(defun shen.linearise_X (V1369 V1370 V1371) (cond ((= V1371 V1369) V1370) ((cons? V1371) (let L (shen.linearise_X V1369 V1370 (hd V1371)) (if (= L (hd V1371)) (cons (hd V1371) (shen.linearise_X V1369 V1370 (tl V1371))) (cons L (tl V1371))))) (true V1371)))

(defun shen.aritycheck (V1374 V1375) (cond ((and (cons? V1375) (and (cons? (hd V1375)) (and (cons? (tl (hd V1375))) (and (= () (tl (tl (hd V1375)))) (= () (tl V1375)))))) (do (shen.aritycheck-action (hd (tl (hd V1375)))) (shen.aritycheck-name V1374 (arity V1374) (length (hd (hd V1375)))))) ((and (cons? V1375) (and (cons? (hd V1375)) (and (cons? (tl (hd V1375))) (and (= () (tl (tl (hd V1375)))) (and (cons? (tl V1375)) (and (cons? (hd (tl V1375))) (and (cons? (tl (hd (tl V1375)))) (= () (tl (tl (hd (tl V1375)))))))))))) (if (= (length (hd (hd V1375))) (length (hd (hd (tl V1375))))) (do (shen.aritycheck-action (hd (tl (hd V1375)))) (shen.aritycheck V1374 (tl V1375))) (simple-error (cn "arity error in " (shen.app V1374 "
" shen.a))))) (true (shen.f_error shen.aritycheck))))

(defun shen.aritycheck-name (V1388 V1389 V1390) (cond ((= -1 V1389) V1390) ((= V1390 V1389) V1390) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V1388 " can cause errors.
" shen.a)) (stoutput)) V1390))))

(defun shen.aritycheck-action (V1396) (cond ((cons? V1396) (do (shen.aah (hd V1396) (tl V1396)) (map (lambda Y (shen.aritycheck-action Y)) V1396))) (true shen.skip)))

(defun shen.aah (V1399 V1400) (let Arity (arity V1399) (let Len (length V1400) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V1399 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V1402) (cond ((and (cons? V1402) (and (cons? (tl V1402)) (= () (tl (tl V1402))))) (shen.abstraction_build (hd V1402) (hd (tl V1402)))) (true (shen.f_error shen.abstract_rule))))

(defun shen.abstraction_build (V1405 V1406) (cond ((= () V1405) V1406) ((cons? V1405) (cons /. (cons (hd V1405) (cons (shen.abstraction_build (tl V1405) V1406) ())))) (true (shen.f_error shen.abstraction_build))))

(defun shen.parameters (V1408) (cond ((= 0 V1408) ()) (true (cons (gensym V) (shen.parameters (- V1408 1))))))

(defun shen.application_build (V1411 V1412) (cond ((= () V1411) V1412) ((cons? V1411) (shen.application_build (tl V1411) (cons V1412 (cons (hd V1411) ())))) (true (shen.f_error shen.application_build))))

(defun shen.compile_to_kl (V1415 V1416) (cond ((and (cons? V1416) (and (cons? (tl V1416)) (= () (tl (tl V1416))))) (let Arity (shen.store-arity V1415 (length (hd V1416))) (let Reduce (map (lambda X (shen.reduce X)) (hd (tl V1416))) (let CondExpression (shen.cond-expression V1415 (hd V1416) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V1415) (hd V1416)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V1416) TypeTable CondExpression) CondExpression) (cons defun (cons V1415 (cons (hd V1416) (cons TypedCondExpression ())))))))))) (true (shen.f_error shen.compile_to_kl))))

(defun shen.get-type (V1422) (cond ((cons? V1422) shen.skip) (true (let FType (assoc V1422 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V1433 V1434) (cond ((and (cons? V1433) (and (cons? (tl V1433)) (and (= --> (hd (tl V1433))) (and (cons? (tl (tl V1433))) (and (= () (tl (tl (tl V1433)))) (cons? V1434)))))) (if (variable? (hd V1433)) (shen.typextable (hd (tl (tl V1433))) (tl V1434)) (cons (cons (hd V1434) (hd V1433)) (shen.typextable (hd (tl (tl V1433))) (tl V1434))))) (true ())))

(defun shen.assign-types (V1438 V1439 V1440) (cond ((and (cons? V1440) (and (= let (hd V1440)) (and (cons? (tl V1440)) (and (cons? (tl (tl V1440))) (and (cons? (tl (tl (tl V1440)))) (= () (tl (tl (tl (tl V1440)))))))))) (cons let (cons (hd (tl V1440)) (cons (shen.assign-types V1438 V1439 (hd (tl (tl V1440)))) (cons (shen.assign-types (cons (hd (tl V1440)) V1438) V1439 (hd (tl (tl (tl V1440))))) ()))))) ((and (cons? V1440) (and (= lambda (hd V1440)) (and (cons? (tl V1440)) (and (cons? (tl (tl V1440))) (= () (tl (tl (tl V1440)))))))) (cons lambda (cons (hd (tl V1440)) (cons (shen.assign-types (cons (hd (tl V1440)) V1438) V1439 (hd (tl (tl V1440)))) ())))) ((and (cons? V1440) (= cond (hd V1440))) (cons cond (map (lambda Y (cons (shen.assign-types V1438 V1439 (hd Y)) (cons (shen.assign-types V1438 V1439 (hd (tl Y))) ()))) (tl V1440)))) ((cons? V1440) (let NewTable (shen.typextable (shen.get-type (hd V1440)) (tl V1440)) (cons (hd V1440) (map (lambda Y (shen.assign-types V1438 (append V1439 NewTable) Y)) (tl V1440))))) (true (let AtomType (assoc V1440 V1439) (if (cons? AtomType) (cons type (cons V1440 (cons (tl AtomType) ()))) (if (element? V1440 V1438) V1440 (shen.atom-type V1440)))))))

(defun shen.atom-type (V1442) (if (string? V1442) (cons type (cons V1442 (cons string ()))) (if (number? V1442) (cons type (cons V1442 (cons number ()))) (if (boolean? V1442) (cons type (cons V1442 (cons boolean ()))) (if (symbol? V1442) (cons type (cons V1442 (cons symbol ()))) V1442)))))

(defun shen.store-arity (V1447 V1448) (cond ((value shen.*installing-kl*) shen.skip) (true (put V1447 arity V1448 (value *property-vector*)))))

(defun shen.reduce (V1450) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V1450) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V1452) (cond ((and (cons? V1452) (and (cons? (hd V1452)) (and (= /. (hd (hd V1452))) (and (cons? (tl (hd V1452))) (and (cons? (hd (tl (hd V1452)))) (and (= cons (hd (hd (tl (hd V1452))))) (and (cons? (tl (hd (tl (hd V1452))))) (and (cons? (tl (tl (hd (tl (hd V1452)))))) (and (= () (tl (tl (tl (hd (tl (hd V1452))))))) (and (cons? (tl (tl (hd V1452)))) (and (= () (tl (tl (tl (hd V1452))))) (and (cons? (tl V1452)) (= () (tl (tl V1452))))))))))))))) (do (shen.add_test (cons cons? (tl V1452))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1452))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1452)))))) (cons (shen.ebr (hd (tl V1452)) (hd (tl (hd V1452))) (hd (tl (tl (hd V1452))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V1452)) ())) (cons (cons tl (tl V1452)) ())) (shen.reduce_help Application))))) ((and (cons? V1452) (and (cons? (hd V1452)) (and (= /. (hd (hd V1452))) (and (cons? (tl (hd V1452))) (and (cons? (hd (tl (hd V1452)))) (and (= @p (hd (hd (tl (hd V1452))))) (and (cons? (tl (hd (tl (hd V1452))))) (and (cons? (tl (tl (hd (tl (hd V1452)))))) (and (= () (tl (tl (tl (hd (tl (hd V1452))))))) (and (cons? (tl (tl (hd V1452)))) (and (= () (tl (tl (tl (hd V1452))))) (and (cons? (tl V1452)) (= () (tl (tl V1452))))))))))))))) (do (shen.add_test (cons tuple? (tl V1452))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1452))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1452)))))) (cons (shen.ebr (hd (tl V1452)) (hd (tl (hd V1452))) (hd (tl (tl (hd V1452))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V1452)) ())) (cons (cons snd (tl V1452)) ())) (shen.reduce_help Application))))) ((and (cons? V1452) (and (cons? (hd V1452)) (and (= /. (hd (hd V1452))) (and (cons? (tl (hd V1452))) (and (cons? (hd (tl (hd V1452)))) (and (= @v (hd (hd (tl (hd V1452))))) (and (cons? (tl (hd (tl (hd V1452))))) (and (cons? (tl (tl (hd (tl (hd V1452)))))) (and (= () (tl (tl (tl (hd (tl (hd V1452))))))) (and (cons? (tl (tl (hd V1452)))) (and (= () (tl (tl (tl (hd V1452))))) (and (cons? (tl V1452)) (= () (tl (tl V1452))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V1452))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1452))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1452)))))) (cons (shen.ebr (hd (tl V1452)) (hd (tl (hd V1452))) (hd (tl (tl (hd V1452))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V1452)) ())) (cons (cons tlv (tl V1452)) ())) (shen.reduce_help Application))))) ((and (cons? V1452) (and (cons? (hd V1452)) (and (= /. (hd (hd V1452))) (and (cons? (tl (hd V1452))) (and (cons? (hd (tl (hd V1452)))) (and (= @s (hd (hd (tl (hd V1452))))) (and (cons? (tl (hd (tl (hd V1452))))) (and (cons? (tl (tl (hd (tl (hd V1452)))))) (and (= () (tl (tl (tl (hd (tl (hd V1452))))))) (and (cons? (tl (tl (hd V1452)))) (and (= () (tl (tl (tl (hd V1452))))) (and (cons? (tl V1452)) (= () (tl (tl V1452))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V1452))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V1452))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V1452)))))) (cons (shen.ebr (hd (tl V1452)) (hd (tl (hd V1452))) (hd (tl (tl (hd V1452))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V1452)) (cons 0 ()))) ())) (cons (cons tlstr (tl V1452)) ())) (shen.reduce_help Application))))) ((and (cons? V1452) (and (cons? (hd V1452)) (and (= /. (hd (hd V1452))) (and (cons? (tl (hd V1452))) (and (cons? (tl (tl (hd V1452)))) (and (= () (tl (tl (tl (hd V1452))))) (and (cons? (tl V1452)) (and (= () (tl (tl V1452))) (not (variable? (hd (tl (hd V1452))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V1452))) (tl V1452)))) (shen.reduce_help (hd (tl (tl (hd V1452))))))) ((and (cons? V1452) (and (cons? (hd V1452)) (and (= /. (hd (hd V1452))) (and (cons? (tl (hd V1452))) (and (cons? (tl (tl (hd V1452)))) (and (= () (tl (tl (tl (hd V1452))))) (and (cons? (tl V1452)) (= () (tl (tl V1452)))))))))) (shen.reduce_help (shen.ebr (hd (tl V1452)) (hd (tl (hd V1452))) (hd (tl (tl (hd V1452))))))) ((and (cons? V1452) (and (= where (hd V1452)) (and (cons? (tl V1452)) (and (cons? (tl (tl V1452))) (= () (tl (tl (tl V1452)))))))) (do (shen.add_test (hd (tl V1452))) (shen.reduce_help (hd (tl (tl V1452)))))) ((and (cons? V1452) (and (cons? (tl V1452)) (= () (tl (tl V1452))))) (let Z (shen.reduce_help (hd V1452)) (if (= (hd V1452) Z) V1452 (shen.reduce_help (cons Z (tl V1452)))))) (true V1452)))

(defun shen.+string? (V1454) (cond ((= "" V1454) false) (true (string? V1454))))

(defun shen.+vector (V1456) (cond ((= V1456 (vector 0)) false) (true (vector? V1456))))

(defun shen.ebr (V1470 V1471 V1472) (cond ((= V1472 V1471) V1470) ((and (cons? V1472) (and (= /. (hd V1472)) (and (cons? (tl V1472)) (and (cons? (tl (tl V1472))) (and (= () (tl (tl (tl V1472)))) (> (occurrences V1471 (hd (tl V1472))) 0)))))) V1472) ((and (cons? V1472) (and (= lambda (hd V1472)) (and (cons? (tl V1472)) (and (cons? (tl (tl V1472))) (and (= () (tl (tl (tl V1472)))) (> (occurrences V1471 (hd (tl V1472))) 0)))))) V1472) ((and (cons? V1472) (and (= let (hd V1472)) (and (cons? (tl V1472)) (and (cons? (tl (tl V1472))) (and (cons? (tl (tl (tl V1472)))) (and (= () (tl (tl (tl (tl V1472))))) (= (hd (tl V1472)) V1471))))))) (cons let (cons (hd (tl V1472)) (cons (shen.ebr V1470 (hd (tl V1472)) (hd (tl (tl V1472)))) (tl (tl (tl V1472))))))) ((cons? V1472) (cons (shen.ebr V1470 V1471 (hd V1472)) (shen.ebr V1470 V1471 (tl V1472)))) (true V1472)))

(defun shen.add_test (V1474) (set shen.*teststack* (cons V1474 (value shen.*teststack*))))

(defun shen.cond-expression (V1478 V1479 V1480) (let Err (shen.err-condition V1478) (let Cases (shen.case-form V1480 Err) (let EncodeChoices (shen.encode-choices Cases V1478) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V1484) (cond ((and (cons? V1484) (and (cons? (hd V1484)) (and (= true (hd (hd V1484))) (and (cons? (tl (hd V1484))) (= () (tl (tl (hd V1484)))))))) (hd (tl (hd V1484)))) (true (cons cond V1484))))

(defun shen.encode-choices (V1489 V1490) (cond ((= () V1489) ()) ((and (cons? V1489) (and (cons? (hd V1489)) (and (= true (hd (hd V1489))) (and (cons? (tl (hd V1489))) (and (cons? (hd (tl (hd V1489)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1489))))) (and (cons? (tl (hd (tl (hd V1489))))) (and (= () (tl (tl (hd (tl (hd V1489)))))) (and (= () (tl (tl (hd V1489)))) (= () (tl V1489))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1489))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V1490 ())) (cons shen.f_error (cons V1490 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V1489) (and (cons? (hd V1489)) (and (= true (hd (hd V1489))) (and (cons? (tl (hd V1489))) (and (cons? (hd (tl (hd V1489)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1489))))) (and (cons? (tl (hd (tl (hd V1489))))) (and (= () (tl (tl (hd (tl (hd V1489)))))) (= () (tl (tl (hd V1489)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1489))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V1489) V1490)) (cons Result ())))) ())))) ())) ())) ((and (cons? V1489) (and (cons? (hd V1489)) (and (cons? (tl (hd V1489))) (and (cons? (hd (tl (hd V1489)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1489))))) (and (cons? (tl (hd (tl (hd V1489))))) (and (= () (tl (tl (hd (tl (hd V1489)))))) (= () (tl (tl (hd V1489))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V1489) V1490)) ())) (cons (cons if (cons (hd (hd V1489)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V1489))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V1489) (and (cons? (hd V1489)) (and (cons? (tl (hd V1489))) (= () (tl (tl (hd V1489))))))) (cons (hd V1489) (shen.encode-choices (tl V1489) V1490))) (true (shen.f_error shen.encode-choices))))

(defun shen.case-form (V1497 V1498) (cond ((= () V1497) (cons V1498 ())) ((and (cons? V1497) (and (cons? (hd V1497)) (and (cons? (hd (hd V1497))) (and (= : (hd (hd (hd V1497)))) (and (cons? (tl (hd (hd V1497)))) (and (= shen.tests (hd (tl (hd (hd V1497))))) (and (= () (tl (tl (hd (hd V1497))))) (and (cons? (tl (hd V1497))) (and (cons? (hd (tl (hd V1497)))) (and (= shen.choicepoint! (hd (hd (tl (hd V1497))))) (and (cons? (tl (hd (tl (hd V1497))))) (and (= () (tl (tl (hd (tl (hd V1497)))))) (= () (tl (tl (hd V1497)))))))))))))))) (cons (cons true (tl (hd V1497))) (shen.case-form (tl V1497) V1498))) ((and (cons? V1497) (and (cons? (hd V1497)) (and (cons? (hd (hd V1497))) (and (= : (hd (hd (hd V1497)))) (and (cons? (tl (hd (hd V1497)))) (and (= shen.tests (hd (tl (hd (hd V1497))))) (and (= () (tl (tl (hd (hd V1497))))) (and (cons? (tl (hd V1497))) (= () (tl (tl (hd V1497)))))))))))) (cons (cons true (tl (hd V1497))) ())) ((and (cons? V1497) (and (cons? (hd V1497)) (and (cons? (hd (hd V1497))) (and (= : (hd (hd (hd V1497)))) (and (cons? (tl (hd (hd V1497)))) (and (= shen.tests (hd (tl (hd (hd V1497))))) (and (cons? (tl (hd V1497))) (= () (tl (tl (hd V1497))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V1497))))) (tl (hd V1497))) (shen.case-form (tl V1497) V1498))) (true (shen.f_error shen.case-form))))

(defun shen.embed-and (V1500) (cond ((and (cons? V1500) (= () (tl V1500))) (hd V1500)) ((cons? V1500) (cons and (cons (hd V1500) (cons (shen.embed-and (tl V1500)) ())))) (true (shen.f_error shen.embed-and))))

(defun shen.err-condition (V1502) (cons true (cons (cons shen.f_error (cons V1502 ())) ())))

(defun shen.sys-error (V1504) (simple-error (cn "system function " (shen.app V1504 ": unexpected argument
" shen.a))))



