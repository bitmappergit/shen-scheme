"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3427 V3428) (let Curry (shen.curry V3427) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3428)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3430) (cond ((and (cons? V3430) (shen.special? (hd V3430))) (cons (hd V3430) (map (lambda Y (shen.curry Y)) (tl V3430)))) ((and (cons? V3430) (and (cons? (tl V3430)) (shen.extraspecial? (hd V3430)))) V3430) ((and (cons? V3430) (and (= type (hd V3430)) (and (cons? (tl V3430)) (and (cons? (tl (tl V3430))) (= () (tl (tl (tl V3430)))))))) (cons type (cons (shen.curry (hd (tl V3430))) (tl (tl V3430))))) ((and (cons? V3430) (and (cons? (tl V3430)) (cons? (tl (tl V3430))))) (shen.curry (cons (cons (hd V3430) (cons (hd (tl V3430)) ())) (tl (tl V3430))))) ((and (cons? V3430) (and (cons? (tl V3430)) (= () (tl (tl V3430))))) (cons (shen.curry (hd V3430)) (cons (shen.curry (hd (tl V3430))) ()))) (true V3430)))

(defun shen.special? (V3432) (element? V3432 (value shen.*special*)))

(defun shen.extraspecial? (V3434) (element? V3434 (value shen.*extraspecial*)))

(defun shen.t* (V3439 V3440 V3441 V3442) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3441) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3441 (freeze (bind Error (shen.errormaxinfs) V3441 V3442))))) (if (= Case false) (let Case (let V3419 (shen.lazyderef V3439 V3441) (if (= fail V3419) (do (shen.incinfs) (cut Throwcontrol V3441 (freeze (shen.prolog-failure V3441 V3442)))) false)) (if (= Case false) (let Case (let V3420 (shen.lazyderef V3439 V3441) (if (cons? V3420) (let X (hd V3420) (let V3421 (shen.lazyderef (tl V3420) V3441) (if (cons? V3421) (let V3422 (shen.lazyderef (hd V3421) V3441) (if (= : V3422) (let V3423 (shen.lazyderef (tl V3421) V3441) (if (cons? V3423) (let A (hd V3423) (let V3424 (shen.lazyderef (tl V3423) V3441) (if (= () V3424) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3441 (freeze (cut Throwcontrol V3441 (freeze (shen.th* X A V3440 V3441 V3442)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3441) (do (shen.incinfs) (shen.show V3439 V3440 V3441 (freeze (bind Datatypes (value shen.*datatypes*) V3441 (freeze (shen.udefs* V3439 V3440 Datatypes V3441 V3442))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3448) (cond ((= + V3448) (set shen.*shen-type-theory-enabled?* true)) ((= - V3448) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3459 V3460) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3466 V3467 V3468 V3469 V3470) (let Case (let V3415 (shen.lazyderef V3468 V3469) (if (cons? V3415) (let D (hd V3415) (do (shen.incinfs) (call (cons D (cons V3466 (cons V3467 ()))) V3469 V3470))) false)) (if (= Case false) (let V3416 (shen.lazyderef V3468 V3469) (if (cons? V3416) (let Ds (tl V3416) (do (shen.incinfs) (shen.udefs* V3466 V3467 Ds V3469 V3470))) false)) Case)))

(defun shen.th* (V3476 V3477 V3478 V3479 V3480) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3476 (cons : (cons V3477 ()))) V3478 V3479 (freeze (fwhen false V3479 V3480)))) (if (= Case false) (let Case (let F (shen.newpv V3479) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3476 V3479)) V3479 (freeze (bind F (shen.sigf (shen.lazyderef V3476 V3479)) V3479 (freeze (call (cons F (cons V3477 ())) V3479 V3480))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3476 V3477 V3479 V3480)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3476 V3477 V3478 V3479 V3480)) (if (= Case false) (let Case (let V3311 (shen.lazyderef V3476 V3479) (if (cons? V3311) (let F (hd V3311) (let V3312 (shen.lazyderef (tl V3311) V3479) (if (= () V3312) (do (shen.incinfs) (shen.th* F (cons --> (cons V3477 ())) V3478 V3479 V3480)) false))) false)) (if (= Case false) (let Case (let V3313 (shen.lazyderef V3476 V3479) (if (cons? V3313) (let F (hd V3313) (let V3314 (shen.lazyderef (tl V3313) V3479) (if (cons? V3314) (let X (hd V3314) (let V3315 (shen.lazyderef (tl V3314) V3479) (if (= () V3315) (let B (shen.newpv V3479) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3477 ()))) V3478 V3479 (freeze (shen.th* X B V3478 V3479 V3480))))) false))) false))) false)) (if (= Case false) (let Case (let V3316 (shen.lazyderef V3476 V3479) (if (cons? V3316) (let V3317 (shen.lazyderef (hd V3316) V3479) (if (= cons V3317) (let V3318 (shen.lazyderef (tl V3316) V3479) (if (cons? V3318) (let X (hd V3318) (let V3319 (shen.lazyderef (tl V3318) V3479) (if (cons? V3319) (let Y (hd V3319) (let V3320 (shen.lazyderef (tl V3319) V3479) (if (= () V3320) (let V3321 (shen.lazyderef V3477 V3479) (if (cons? V3321) (let V3322 (shen.lazyderef (hd V3321) V3479) (if (= list V3322) (let V3323 (shen.lazyderef (tl V3321) V3479) (if (cons? V3323) (let A (hd V3323) (let V3324 (shen.lazyderef (tl V3323) V3479) (if (= () V3324) (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (if (shen.pvar? V3324) (do (shen.bindv V3324 () V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3324 V3479) Result))) false)))) (if (shen.pvar? V3323) (let A (shen.newpv V3479) (do (shen.bindv V3323 (cons A ()) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3323 V3479) Result)))) false))) (if (shen.pvar? V3322) (do (shen.bindv V3322 list V3479) (let Result (let V3325 (shen.lazyderef (tl V3321) V3479) (if (cons? V3325) (let A (hd V3325) (let V3326 (shen.lazyderef (tl V3325) V3479) (if (= () V3326) (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (if (shen.pvar? V3326) (do (shen.bindv V3326 () V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3326 V3479) Result))) false)))) (if (shen.pvar? V3325) (let A (shen.newpv V3479) (do (shen.bindv V3325 (cons A ()) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3325 V3479) Result)))) false))) (do (shen.unbindv V3322 V3479) Result))) false))) (if (shen.pvar? V3321) (let A (shen.newpv V3479) (do (shen.bindv V3321 (cons list (cons A ())) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons list (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3321 V3479) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3327 (shen.lazyderef V3476 V3479) (if (cons? V3327) (let V3328 (shen.lazyderef (hd V3327) V3479) (if (= @p V3328) (let V3329 (shen.lazyderef (tl V3327) V3479) (if (cons? V3329) (let X (hd V3329) (let V3330 (shen.lazyderef (tl V3329) V3479) (if (cons? V3330) (let Y (hd V3330) (let V3331 (shen.lazyderef (tl V3330) V3479) (if (= () V3331) (let V3332 (shen.lazyderef V3477 V3479) (if (cons? V3332) (let A (hd V3332) (let V3333 (shen.lazyderef (tl V3332) V3479) (if (cons? V3333) (let V3334 (shen.lazyderef (hd V3333) V3479) (if (= * V3334) (let V3335 (shen.lazyderef (tl V3333) V3479) (if (cons? V3335) (let B (hd V3335) (let V3336 (shen.lazyderef (tl V3335) V3479) (if (= () V3336) (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (if (shen.pvar? V3336) (do (shen.bindv V3336 () V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (do (shen.unbindv V3336 V3479) Result))) false)))) (if (shen.pvar? V3335) (let B (shen.newpv V3479) (do (shen.bindv V3335 (cons B ()) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (do (shen.unbindv V3335 V3479) Result)))) false))) (if (shen.pvar? V3334) (do (shen.bindv V3334 * V3479) (let Result (let V3337 (shen.lazyderef (tl V3333) V3479) (if (cons? V3337) (let B (hd V3337) (let V3338 (shen.lazyderef (tl V3337) V3479) (if (= () V3338) (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (if (shen.pvar? V3338) (do (shen.bindv V3338 () V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (do (shen.unbindv V3338 V3479) Result))) false)))) (if (shen.pvar? V3337) (let B (shen.newpv V3479) (do (shen.bindv V3337 (cons B ()) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (do (shen.unbindv V3337 V3479) Result)))) false))) (do (shen.unbindv V3334 V3479) Result))) false))) (if (shen.pvar? V3333) (let B (shen.newpv V3479) (do (shen.bindv V3333 (cons * (cons B ())) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (do (shen.unbindv V3333 V3479) Result)))) false)))) (if (shen.pvar? V3332) (let A (shen.newpv V3479) (let B (shen.newpv V3479) (do (shen.bindv V3332 (cons A (cons * (cons B ()))) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y B V3478 V3479 V3480)))) (do (shen.unbindv V3332 V3479) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3339 (shen.lazyderef V3476 V3479) (if (cons? V3339) (let V3340 (shen.lazyderef (hd V3339) V3479) (if (= @v V3340) (let V3341 (shen.lazyderef (tl V3339) V3479) (if (cons? V3341) (let X (hd V3341) (let V3342 (shen.lazyderef (tl V3341) V3479) (if (cons? V3342) (let Y (hd V3342) (let V3343 (shen.lazyderef (tl V3342) V3479) (if (= () V3343) (let V3344 (shen.lazyderef V3477 V3479) (if (cons? V3344) (let V3345 (shen.lazyderef (hd V3344) V3479) (if (= vector V3345) (let V3346 (shen.lazyderef (tl V3344) V3479) (if (cons? V3346) (let A (hd V3346) (let V3347 (shen.lazyderef (tl V3346) V3479) (if (= () V3347) (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (if (shen.pvar? V3347) (do (shen.bindv V3347 () V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3347 V3479) Result))) false)))) (if (shen.pvar? V3346) (let A (shen.newpv V3479) (do (shen.bindv V3346 (cons A ()) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3346 V3479) Result)))) false))) (if (shen.pvar? V3345) (do (shen.bindv V3345 vector V3479) (let Result (let V3348 (shen.lazyderef (tl V3344) V3479) (if (cons? V3348) (let A (hd V3348) (let V3349 (shen.lazyderef (tl V3348) V3479) (if (= () V3349) (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (if (shen.pvar? V3349) (do (shen.bindv V3349 () V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3349 V3479) Result))) false)))) (if (shen.pvar? V3348) (let A (shen.newpv V3479) (do (shen.bindv V3348 (cons A ()) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3348 V3479) Result)))) false))) (do (shen.unbindv V3345 V3479) Result))) false))) (if (shen.pvar? V3344) (let A (shen.newpv V3479) (do (shen.bindv V3344 (cons vector (cons A ())) V3479) (let Result (do (shen.incinfs) (shen.th* X A V3478 V3479 (freeze (shen.th* Y (cons vector (cons A ())) V3478 V3479 V3480)))) (do (shen.unbindv V3344 V3479) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3350 (shen.lazyderef V3476 V3479) (if (cons? V3350) (let V3351 (shen.lazyderef (hd V3350) V3479) (if (= @s V3351) (let V3352 (shen.lazyderef (tl V3350) V3479) (if (cons? V3352) (let X (hd V3352) (let V3353 (shen.lazyderef (tl V3352) V3479) (if (cons? V3353) (let Y (hd V3353) (let V3354 (shen.lazyderef (tl V3353) V3479) (if (= () V3354) (let V3355 (shen.lazyderef V3477 V3479) (if (= string V3355) (do (shen.incinfs) (shen.th* X string V3478 V3479 (freeze (shen.th* Y string V3478 V3479 V3480)))) (if (shen.pvar? V3355) (do (shen.bindv V3355 string V3479) (let Result (do (shen.incinfs) (shen.th* X string V3478 V3479 (freeze (shen.th* Y string V3478 V3479 V3480)))) (do (shen.unbindv V3355 V3479) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3356 (shen.lazyderef V3476 V3479) (if (cons? V3356) (let V3357 (shen.lazyderef (hd V3356) V3479) (if (= lambda V3357) (let V3358 (shen.lazyderef (tl V3356) V3479) (if (cons? V3358) (let X (hd V3358) (let V3359 (shen.lazyderef (tl V3358) V3479) (if (cons? V3359) (let Y (hd V3359) (let V3360 (shen.lazyderef (tl V3359) V3479) (if (= () V3360) (let V3361 (shen.lazyderef V3477 V3479) (if (cons? V3361) (let A (hd V3361) (let V3362 (shen.lazyderef (tl V3361) V3479) (if (cons? V3362) (let V3363 (shen.lazyderef (hd V3362) V3479) (if (= --> V3363) (let V3364 (shen.lazyderef (tl V3362) V3479) (if (cons? V3364) (let B (hd V3364) (let V3365 (shen.lazyderef (tl V3364) V3479) (if (= () V3365) (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (if (shen.pvar? V3365) (do (shen.bindv V3365 () V3479) (let Result (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (do (shen.unbindv V3365 V3479) Result))) false)))) (if (shen.pvar? V3364) (let B (shen.newpv V3479) (do (shen.bindv V3364 (cons B ()) V3479) (let Result (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (do (shen.unbindv V3364 V3479) Result)))) false))) (if (shen.pvar? V3363) (do (shen.bindv V3363 --> V3479) (let Result (let V3366 (shen.lazyderef (tl V3362) V3479) (if (cons? V3366) (let B (hd V3366) (let V3367 (shen.lazyderef (tl V3366) V3479) (if (= () V3367) (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (if (shen.pvar? V3367) (do (shen.bindv V3367 () V3479) (let Result (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (do (shen.unbindv V3367 V3479) Result))) false)))) (if (shen.pvar? V3366) (let B (shen.newpv V3479) (do (shen.bindv V3366 (cons B ()) V3479) (let Result (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (do (shen.unbindv V3366 V3479) Result)))) false))) (do (shen.unbindv V3363 V3479) Result))) false))) (if (shen.pvar? V3362) (let B (shen.newpv V3479) (do (shen.bindv V3362 (cons --> (cons B ())) V3479) (let Result (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (do (shen.unbindv V3362 V3479) Result)))) false)))) (if (shen.pvar? V3361) (let A (shen.newpv V3479) (let B (shen.newpv V3479) (do (shen.bindv V3361 (cons A (cons --> (cons B ()))) V3479) (let Result (let Z (shen.newpv V3479) (let X&& (shen.newpv V3479) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Y V3479)) V3479 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3478) V3479 V3480)))))))))) (do (shen.unbindv V3361 V3479) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3368 (shen.lazyderef V3476 V3479) (if (cons? V3368) (let V3369 (shen.lazyderef (hd V3368) V3479) (if (= let V3369) (let V3370 (shen.lazyderef (tl V3368) V3479) (if (cons? V3370) (let X (hd V3370) (let V3371 (shen.lazyderef (tl V3370) V3479) (if (cons? V3371) (let Y (hd V3371) (let V3372 (shen.lazyderef (tl V3371) V3479) (if (cons? V3372) (let Z (hd V3372) (let V3373 (shen.lazyderef (tl V3372) V3479) (if (= () V3373) (let W (shen.newpv V3479) (let X&& (shen.newpv V3479) (let B (shen.newpv V3479) (do (shen.incinfs) (shen.th* Y B V3478 V3479 (freeze (bind X&& (shen.placeholder) V3479 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3479) (shen.lazyderef X V3479) (shen.lazyderef Z V3479)) V3479 (freeze (shen.th* W V3477 (cons (cons X&& (cons : (cons B ()))) V3478) V3479 V3480))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3374 (shen.lazyderef V3476 V3479) (if (cons? V3374) (let V3375 (shen.lazyderef (hd V3374) V3479) (if (= open V3375) (let V3376 (shen.lazyderef (tl V3374) V3479) (if (cons? V3376) (let FileName (hd V3376) (let V3377 (shen.lazyderef (tl V3376) V3479) (if (cons? V3377) (let Direction3307 (hd V3377) (let V3378 (shen.lazyderef (tl V3377) V3479) (if (= () V3378) (let V3379 (shen.lazyderef V3477 V3479) (if (cons? V3379) (let V3380 (shen.lazyderef (hd V3379) V3479) (if (= stream V3380) (let V3381 (shen.lazyderef (tl V3379) V3479) (if (cons? V3381) (let Direction (hd V3381) (let V3382 (shen.lazyderef (tl V3381) V3479) (if (= () V3382) (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (if (shen.pvar? V3382) (do (shen.bindv V3382 () V3479) (let Result (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (do (shen.unbindv V3382 V3479) Result))) false)))) (if (shen.pvar? V3381) (let Direction (shen.newpv V3479) (do (shen.bindv V3381 (cons Direction ()) V3479) (let Result (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (do (shen.unbindv V3381 V3479) Result)))) false))) (if (shen.pvar? V3380) (do (shen.bindv V3380 stream V3479) (let Result (let V3383 (shen.lazyderef (tl V3379) V3479) (if (cons? V3383) (let Direction (hd V3383) (let V3384 (shen.lazyderef (tl V3383) V3479) (if (= () V3384) (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (if (shen.pvar? V3384) (do (shen.bindv V3384 () V3479) (let Result (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (do (shen.unbindv V3384 V3479) Result))) false)))) (if (shen.pvar? V3383) (let Direction (shen.newpv V3479) (do (shen.bindv V3383 (cons Direction ()) V3479) (let Result (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (do (shen.unbindv V3383 V3479) Result)))) false))) (do (shen.unbindv V3380 V3479) Result))) false))) (if (shen.pvar? V3379) (let Direction (shen.newpv V3479) (do (shen.bindv V3379 (cons stream (cons Direction ())) V3479) (let Result (do (shen.incinfs) (unify! Direction Direction3307 V3479 (freeze (cut Throwcontrol V3479 (freeze (fwhen (element? (shen.lazyderef Direction V3479) (cons in (cons out ()))) V3479 (freeze (shen.th* FileName string V3478 V3479 V3480)))))))) (do (shen.unbindv V3379 V3479) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3385 (shen.lazyderef V3476 V3479) (if (cons? V3385) (let V3386 (shen.lazyderef (hd V3385) V3479) (if (= type V3386) (let V3387 (shen.lazyderef (tl V3385) V3479) (if (cons? V3387) (let X (hd V3387) (let V3388 (shen.lazyderef (tl V3387) V3479) (if (cons? V3388) (let A (hd V3388) (let V3389 (shen.lazyderef (tl V3388) V3479) (if (= () V3389) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (unify A V3477 V3479 (freeze (shen.th* X A V3478 V3479 V3480)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3390 (shen.lazyderef V3476 V3479) (if (cons? V3390) (let V3391 (shen.lazyderef (hd V3390) V3479) (if (= input+ V3391) (let V3392 (shen.lazyderef (tl V3390) V3479) (if (cons? V3392) (let A (hd V3392) (let V3393 (shen.lazyderef (tl V3392) V3479) (if (cons? V3393) (let Stream (hd V3393) (let V3394 (shen.lazyderef (tl V3393) V3479) (if (= () V3394) (let C (shen.newpv V3479) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3479)) V3479 (freeze (unify V3477 C V3479 (freeze (shen.th* Stream (cons stream (cons in ())) V3478 V3479 V3480))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3395 (shen.lazyderef V3476 V3479) (if (cons? V3395) (let V3396 (shen.lazyderef (hd V3395) V3479) (if (= set V3396) (let V3397 (shen.lazyderef (tl V3395) V3479) (if (cons? V3397) (let Var (hd V3397) (let V3398 (shen.lazyderef (tl V3397) V3479) (if (cons? V3398) (let Val (hd V3398) (let V3399 (shen.lazyderef (tl V3398) V3479) (if (= () V3399) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (shen.th* Var symbol V3478 V3479 (freeze (cut Throwcontrol V3479 (freeze (shen.th* (cons value (cons Var ())) V3477 V3478 V3479 (freeze (shen.th* Val V3477 V3478 V3479 V3480)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3479) (do (shen.incinfs) (shen.t*-hyps V3478 NewHyp V3479 (freeze (shen.th* V3476 V3477 NewHyp V3479 V3480))))) (if (= Case false) (let Case (let V3400 (shen.lazyderef V3476 V3479) (if (cons? V3400) (let V3401 (shen.lazyderef (hd V3400) V3479) (if (= define V3401) (let V3402 (shen.lazyderef (tl V3400) V3479) (if (cons? V3402) (let F (hd V3402) (let X (tl V3402) (do (shen.incinfs) (cut Throwcontrol V3479 (freeze (shen.t*-def (cons define (cons F X)) V3477 V3478 V3479 V3480)))))) false)) false)) false)) (if (= Case false) (let Case (let V3403 (shen.lazyderef V3476 V3479) (if (cons? V3403) (let V3404 (shen.lazyderef (hd V3403) V3479) (if (= defmacro V3404) (let V3405 (shen.lazyderef V3477 V3479) (if (= unit V3405) (do (shen.incinfs) (cut Throwcontrol V3479 V3480)) (if (shen.pvar? V3405) (do (shen.bindv V3405 unit V3479) (let Result (do (shen.incinfs) (cut Throwcontrol V3479 V3480)) (do (shen.unbindv V3405 V3479) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3406 (shen.lazyderef V3476 V3479) (if (cons? V3406) (let V3407 (shen.lazyderef (hd V3406) V3479) (if (= shen.process-datatype V3407) (let V3408 (shen.lazyderef V3477 V3479) (if (= symbol V3408) (do (shen.incinfs) (thaw V3480)) (if (shen.pvar? V3408) (do (shen.bindv V3408 symbol V3479) (let Result (do (shen.incinfs) (thaw V3480)) (do (shen.unbindv V3408 V3479) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3409 (shen.lazyderef V3476 V3479) (if (cons? V3409) (let V3410 (shen.lazyderef (hd V3409) V3479) (if (= shen.synonyms-help V3410) (let V3411 (shen.lazyderef V3477 V3479) (if (= symbol V3411) (do (shen.incinfs) (thaw V3480)) (if (shen.pvar? V3411) (do (shen.bindv V3411 symbol V3479) (let Result (do (shen.incinfs) (thaw V3480)) (do (shen.unbindv V3411 V3479) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3479) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3479 (freeze (shen.udefs* (cons V3476 (cons : (cons V3477 ()))) V3478 Datatypes V3479 V3480))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3485 V3486 V3487 V3488) (let Case (let V3222 (shen.lazyderef V3485 V3487) (if (cons? V3222) (let V3223 (shen.lazyderef (hd V3222) V3487) (if (cons? V3223) (let V3224 (shen.lazyderef (hd V3223) V3487) (if (cons? V3224) (let V3225 (shen.lazyderef (hd V3224) V3487) (if (= cons V3225) (let V3226 (shen.lazyderef (tl V3224) V3487) (if (cons? V3226) (let X (hd V3226) (let V3227 (shen.lazyderef (tl V3226) V3487) (if (cons? V3227) (let Y (hd V3227) (let V3228 (shen.lazyderef (tl V3227) V3487) (if (= () V3228) (let V3229 (shen.lazyderef (tl V3223) V3487) (if (cons? V3229) (let V3230 (shen.lazyderef (hd V3229) V3487) (if (= : V3230) (let V3231 (shen.lazyderef (tl V3229) V3487) (if (cons? V3231) (let V3232 (shen.lazyderef (hd V3231) V3487) (if (cons? V3232) (let V3233 (shen.lazyderef (hd V3232) V3487) (if (= list V3233) (let V3234 (shen.lazyderef (tl V3232) V3487) (if (cons? V3234) (let A (hd V3234) (let V3235 (shen.lazyderef (tl V3234) V3487) (if (= () V3235) (let V3236 (shen.lazyderef (tl V3231) V3487) (if (= () V3236) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3236) (do (shen.bindv V3236 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3236 V3487) Result))) false))) (if (shen.pvar? V3235) (do (shen.bindv V3235 () V3487) (let Result (let V3237 (shen.lazyderef (tl V3231) V3487) (if (= () V3237) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3237) (do (shen.bindv V3237 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3237 V3487) Result))) false))) (do (shen.unbindv V3235 V3487) Result))) false)))) (if (shen.pvar? V3234) (let A (shen.newpv V3487) (do (shen.bindv V3234 (cons A ()) V3487) (let Result (let V3238 (shen.lazyderef (tl V3231) V3487) (if (= () V3238) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3238) (do (shen.bindv V3238 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3238 V3487) Result))) false))) (do (shen.unbindv V3234 V3487) Result)))) false))) (if (shen.pvar? V3233) (do (shen.bindv V3233 list V3487) (let Result (let V3239 (shen.lazyderef (tl V3232) V3487) (if (cons? V3239) (let A (hd V3239) (let V3240 (shen.lazyderef (tl V3239) V3487) (if (= () V3240) (let V3241 (shen.lazyderef (tl V3231) V3487) (if (= () V3241) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3241) (do (shen.bindv V3241 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3241 V3487) Result))) false))) (if (shen.pvar? V3240) (do (shen.bindv V3240 () V3487) (let Result (let V3242 (shen.lazyderef (tl V3231) V3487) (if (= () V3242) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3242) (do (shen.bindv V3242 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3242 V3487) Result))) false))) (do (shen.unbindv V3240 V3487) Result))) false)))) (if (shen.pvar? V3239) (let A (shen.newpv V3487) (do (shen.bindv V3239 (cons A ()) V3487) (let Result (let V3243 (shen.lazyderef (tl V3231) V3487) (if (= () V3243) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3243) (do (shen.bindv V3243 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3243 V3487) Result))) false))) (do (shen.unbindv V3239 V3487) Result)))) false))) (do (shen.unbindv V3233 V3487) Result))) false))) (if (shen.pvar? V3232) (let A (shen.newpv V3487) (do (shen.bindv V3232 (cons list (cons A ())) V3487) (let Result (let V3244 (shen.lazyderef (tl V3231) V3487) (if (= () V3244) (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3244) (do (shen.bindv V3244 () V3487) (let Result (let Hyp (tl V3222) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons list (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3244 V3487) Result))) false))) (do (shen.unbindv V3232 V3487) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3245 (shen.lazyderef V3485 V3487) (if (cons? V3245) (let V3246 (shen.lazyderef (hd V3245) V3487) (if (cons? V3246) (let V3247 (shen.lazyderef (hd V3246) V3487) (if (cons? V3247) (let V3248 (shen.lazyderef (hd V3247) V3487) (if (= @p V3248) (let V3249 (shen.lazyderef (tl V3247) V3487) (if (cons? V3249) (let X (hd V3249) (let V3250 (shen.lazyderef (tl V3249) V3487) (if (cons? V3250) (let Y (hd V3250) (let V3251 (shen.lazyderef (tl V3250) V3487) (if (= () V3251) (let V3252 (shen.lazyderef (tl V3246) V3487) (if (cons? V3252) (let V3253 (shen.lazyderef (hd V3252) V3487) (if (= : V3253) (let V3254 (shen.lazyderef (tl V3252) V3487) (if (cons? V3254) (let V3255 (shen.lazyderef (hd V3254) V3487) (if (cons? V3255) (let A (hd V3255) (let V3256 (shen.lazyderef (tl V3255) V3487) (if (cons? V3256) (let V3257 (shen.lazyderef (hd V3256) V3487) (if (= * V3257) (let V3258 (shen.lazyderef (tl V3256) V3487) (if (cons? V3258) (let B (hd V3258) (let V3259 (shen.lazyderef (tl V3258) V3487) (if (= () V3259) (let V3260 (shen.lazyderef (tl V3254) V3487) (if (= () V3260) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3260) (do (shen.bindv V3260 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3260 V3487) Result))) false))) (if (shen.pvar? V3259) (do (shen.bindv V3259 () V3487) (let Result (let V3261 (shen.lazyderef (tl V3254) V3487) (if (= () V3261) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3261) (do (shen.bindv V3261 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3261 V3487) Result))) false))) (do (shen.unbindv V3259 V3487) Result))) false)))) (if (shen.pvar? V3258) (let B (shen.newpv V3487) (do (shen.bindv V3258 (cons B ()) V3487) (let Result (let V3262 (shen.lazyderef (tl V3254) V3487) (if (= () V3262) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3262) (do (shen.bindv V3262 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3262 V3487) Result))) false))) (do (shen.unbindv V3258 V3487) Result)))) false))) (if (shen.pvar? V3257) (do (shen.bindv V3257 * V3487) (let Result (let V3263 (shen.lazyderef (tl V3256) V3487) (if (cons? V3263) (let B (hd V3263) (let V3264 (shen.lazyderef (tl V3263) V3487) (if (= () V3264) (let V3265 (shen.lazyderef (tl V3254) V3487) (if (= () V3265) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3265) (do (shen.bindv V3265 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3265 V3487) Result))) false))) (if (shen.pvar? V3264) (do (shen.bindv V3264 () V3487) (let Result (let V3266 (shen.lazyderef (tl V3254) V3487) (if (= () V3266) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3266) (do (shen.bindv V3266 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3266 V3487) Result))) false))) (do (shen.unbindv V3264 V3487) Result))) false)))) (if (shen.pvar? V3263) (let B (shen.newpv V3487) (do (shen.bindv V3263 (cons B ()) V3487) (let Result (let V3267 (shen.lazyderef (tl V3254) V3487) (if (= () V3267) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3267) (do (shen.bindv V3267 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3267 V3487) Result))) false))) (do (shen.unbindv V3263 V3487) Result)))) false))) (do (shen.unbindv V3257 V3487) Result))) false))) (if (shen.pvar? V3256) (let B (shen.newpv V3487) (do (shen.bindv V3256 (cons * (cons B ())) V3487) (let Result (let V3268 (shen.lazyderef (tl V3254) V3487) (if (= () V3268) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3268) (do (shen.bindv V3268 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3268 V3487) Result))) false))) (do (shen.unbindv V3256 V3487) Result)))) false)))) (if (shen.pvar? V3255) (let A (shen.newpv V3487) (let B (shen.newpv V3487) (do (shen.bindv V3255 (cons A (cons * (cons B ()))) V3487) (let Result (let V3269 (shen.lazyderef (tl V3254) V3487) (if (= () V3269) (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3269) (do (shen.bindv V3269 () V3487) (let Result (let Hyp (tl V3245) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (shen.lazyderef B V3487) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3269 V3487) Result))) false))) (do (shen.unbindv V3255 V3487) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3270 (shen.lazyderef V3485 V3487) (if (cons? V3270) (let V3271 (shen.lazyderef (hd V3270) V3487) (if (cons? V3271) (let V3272 (shen.lazyderef (hd V3271) V3487) (if (cons? V3272) (let V3273 (shen.lazyderef (hd V3272) V3487) (if (= @v V3273) (let V3274 (shen.lazyderef (tl V3272) V3487) (if (cons? V3274) (let X (hd V3274) (let V3275 (shen.lazyderef (tl V3274) V3487) (if (cons? V3275) (let Y (hd V3275) (let V3276 (shen.lazyderef (tl V3275) V3487) (if (= () V3276) (let V3277 (shen.lazyderef (tl V3271) V3487) (if (cons? V3277) (let V3278 (shen.lazyderef (hd V3277) V3487) (if (= : V3278) (let V3279 (shen.lazyderef (tl V3277) V3487) (if (cons? V3279) (let V3280 (shen.lazyderef (hd V3279) V3487) (if (cons? V3280) (let V3281 (shen.lazyderef (hd V3280) V3487) (if (= vector V3281) (let V3282 (shen.lazyderef (tl V3280) V3487) (if (cons? V3282) (let A (hd V3282) (let V3283 (shen.lazyderef (tl V3282) V3487) (if (= () V3283) (let V3284 (shen.lazyderef (tl V3279) V3487) (if (= () V3284) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3284) (do (shen.bindv V3284 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3284 V3487) Result))) false))) (if (shen.pvar? V3283) (do (shen.bindv V3283 () V3487) (let Result (let V3285 (shen.lazyderef (tl V3279) V3487) (if (= () V3285) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3285) (do (shen.bindv V3285 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3285 V3487) Result))) false))) (do (shen.unbindv V3283 V3487) Result))) false)))) (if (shen.pvar? V3282) (let A (shen.newpv V3487) (do (shen.bindv V3282 (cons A ()) V3487) (let Result (let V3286 (shen.lazyderef (tl V3279) V3487) (if (= () V3286) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3286) (do (shen.bindv V3286 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3286 V3487) Result))) false))) (do (shen.unbindv V3282 V3487) Result)))) false))) (if (shen.pvar? V3281) (do (shen.bindv V3281 vector V3487) (let Result (let V3287 (shen.lazyderef (tl V3280) V3487) (if (cons? V3287) (let A (hd V3287) (let V3288 (shen.lazyderef (tl V3287) V3487) (if (= () V3288) (let V3289 (shen.lazyderef (tl V3279) V3487) (if (= () V3289) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3289) (do (shen.bindv V3289 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3289 V3487) Result))) false))) (if (shen.pvar? V3288) (do (shen.bindv V3288 () V3487) (let Result (let V3290 (shen.lazyderef (tl V3279) V3487) (if (= () V3290) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3290) (do (shen.bindv V3290 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3290 V3487) Result))) false))) (do (shen.unbindv V3288 V3487) Result))) false)))) (if (shen.pvar? V3287) (let A (shen.newpv V3487) (do (shen.bindv V3287 (cons A ()) V3487) (let Result (let V3291 (shen.lazyderef (tl V3279) V3487) (if (= () V3291) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3291) (do (shen.bindv V3291 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3291 V3487) Result))) false))) (do (shen.unbindv V3287 V3487) Result)))) false))) (do (shen.unbindv V3281 V3487) Result))) false))) (if (shen.pvar? V3280) (let A (shen.newpv V3487) (do (shen.bindv V3280 (cons vector (cons A ())) V3487) (let Result (let V3292 (shen.lazyderef (tl V3279) V3487) (if (= () V3292) (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3292) (do (shen.bindv V3292 () V3487) (let Result (let Hyp (tl V3270) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons (shen.lazyderef A V3487) ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons (cons vector (cons (shen.lazyderef A V3487) ())) ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3292 V3487) Result))) false))) (do (shen.unbindv V3280 V3487) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3293 (shen.lazyderef V3485 V3487) (if (cons? V3293) (let V3294 (shen.lazyderef (hd V3293) V3487) (if (cons? V3294) (let V3295 (shen.lazyderef (hd V3294) V3487) (if (cons? V3295) (let V3296 (shen.lazyderef (hd V3295) V3487) (if (= @s V3296) (let V3297 (shen.lazyderef (tl V3295) V3487) (if (cons? V3297) (let X (hd V3297) (let V3298 (shen.lazyderef (tl V3297) V3487) (if (cons? V3298) (let Y (hd V3298) (let V3299 (shen.lazyderef (tl V3298) V3487) (if (= () V3299) (let V3300 (shen.lazyderef (tl V3294) V3487) (if (cons? V3300) (let V3301 (shen.lazyderef (hd V3300) V3487) (if (= : V3301) (let V3302 (shen.lazyderef (tl V3300) V3487) (if (cons? V3302) (let V3303 (shen.lazyderef (hd V3302) V3487) (if (= string V3303) (let V3304 (shen.lazyderef (tl V3302) V3487) (if (= () V3304) (let Hyp (tl V3293) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons string ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3304) (do (shen.bindv V3304 () V3487) (let Result (let Hyp (tl V3293) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons string ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3304 V3487) Result))) false))) (if (shen.pvar? V3303) (do (shen.bindv V3303 string V3487) (let Result (let V3305 (shen.lazyderef (tl V3302) V3487) (if (= () V3305) (let Hyp (tl V3293) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons string ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (if (shen.pvar? V3305) (do (shen.bindv V3305 () V3487) (let Result (let Hyp (tl V3293) (do (shen.incinfs) (bind V3486 (cons (cons (shen.lazyderef X V3487) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3487) (cons : (cons string ()))) (shen.lazyderef Hyp V3487))) V3487 V3488))) (do (shen.unbindv V3305 V3487) Result))) false))) (do (shen.unbindv V3303 V3487) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3306 (shen.lazyderef V3485 V3487) (if (cons? V3306) (let X (hd V3306) (let Hyp (tl V3306) (let NewHyps (shen.newpv V3487) (do (shen.incinfs) (bind V3486 (cons (shen.lazyderef X V3487) (shen.lazyderef NewHyps V3487)) V3487 (freeze (shen.t*-hyps Hyp NewHyps V3487 V3488))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3505 V3506 V3507 V3508) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3505 V3507)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3506 V3507) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3508))))))))) (true (thaw V3508))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3510) (cond ((and (cons? V3510) (and (cons? (tl V3510)) (and (= : (hd (tl V3510))) (and (cons? (tl (tl V3510))) (= () (tl (tl (tl V3510)))))))) (shen.prhush (shen.app (hd V3510) (cn " : " (shen.app (hd (tl (tl V3510))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3510 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3515 V3516) (cond ((= () V3515) shen.skip) ((cons? V3515) (do (shen.prhush (shen.app V3516 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3515)) (do (nl 1) (shen.show-assumptions (tl V3515) (+ V3516 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3518) (cons? (assoc V3518 (value shen.*signedfuncs*))))

(defun shen.sigf (V3520) (concat shen.type-signature-of- V3520))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3525 V3526 V3527 V3528) (let Case (let V3209 (shen.lazyderef V3526 V3527) (if (= number V3209) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3525 V3527)) V3527 V3528)) (if (shen.pvar? V3209) (do (shen.bindv V3209 number V3527) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3525 V3527)) V3527 V3528)) (do (shen.unbindv V3209 V3527) Result))) false))) (if (= Case false) (let Case (let V3210 (shen.lazyderef V3526 V3527) (if (= boolean V3210) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3525 V3527)) V3527 V3528)) (if (shen.pvar? V3210) (do (shen.bindv V3210 boolean V3527) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3525 V3527)) V3527 V3528)) (do (shen.unbindv V3210 V3527) Result))) false))) (if (= Case false) (let Case (let V3211 (shen.lazyderef V3526 V3527) (if (= string V3211) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3525 V3527)) V3527 V3528)) (if (shen.pvar? V3211) (do (shen.bindv V3211 string V3527) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3525 V3527)) V3527 V3528)) (do (shen.unbindv V3211 V3527) Result))) false))) (if (= Case false) (let Case (let V3212 (shen.lazyderef V3526 V3527) (if (= symbol V3212) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3525 V3527)) V3527 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3525 V3527))) V3527 V3528)))) (if (shen.pvar? V3212) (do (shen.bindv V3212 symbol V3527) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3525 V3527)) V3527 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3525 V3527))) V3527 V3528)))) (do (shen.unbindv V3212 V3527) Result))) false))) (if (= Case false) (let V3213 (shen.lazyderef V3525 V3527) (if (= () V3213) (let V3214 (shen.lazyderef V3526 V3527) (if (cons? V3214) (let V3215 (shen.lazyderef (hd V3214) V3527) (if (= list V3215) (let V3216 (shen.lazyderef (tl V3214) V3527) (if (cons? V3216) (let A (hd V3216) (let V3217 (shen.lazyderef (tl V3216) V3527) (if (= () V3217) (do (shen.incinfs) (thaw V3528)) (if (shen.pvar? V3217) (do (shen.bindv V3217 () V3527) (let Result (do (shen.incinfs) (thaw V3528)) (do (shen.unbindv V3217 V3527) Result))) false)))) (if (shen.pvar? V3216) (let A (shen.newpv V3527) (do (shen.bindv V3216 (cons A ()) V3527) (let Result (do (shen.incinfs) (thaw V3528)) (do (shen.unbindv V3216 V3527) Result)))) false))) (if (shen.pvar? V3215) (do (shen.bindv V3215 list V3527) (let Result (let V3218 (shen.lazyderef (tl V3214) V3527) (if (cons? V3218) (let A (hd V3218) (let V3219 (shen.lazyderef (tl V3218) V3527) (if (= () V3219) (do (shen.incinfs) (thaw V3528)) (if (shen.pvar? V3219) (do (shen.bindv V3219 () V3527) (let Result (do (shen.incinfs) (thaw V3528)) (do (shen.unbindv V3219 V3527) Result))) false)))) (if (shen.pvar? V3218) (let A (shen.newpv V3527) (do (shen.bindv V3218 (cons A ()) V3527) (let Result (do (shen.incinfs) (thaw V3528)) (do (shen.unbindv V3218 V3527) Result)))) false))) (do (shen.unbindv V3215 V3527) Result))) false))) (if (shen.pvar? V3214) (let A (shen.newpv V3527) (do (shen.bindv V3214 (cons list (cons A ())) V3527) (let Result (do (shen.incinfs) (thaw V3528)) (do (shen.unbindv V3214 V3527) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3534 V3535 V3536 V3537 V3538) (let Case (let V3200 (shen.lazyderef V3536 V3537) (if (cons? V3200) (let V3201 (shen.lazyderef (hd V3200) V3537) (if (cons? V3201) (let Y (hd V3201) (let V3202 (shen.lazyderef (tl V3201) V3537) (if (cons? V3202) (let V3203 (shen.lazyderef (hd V3202) V3537) (if (= : V3203) (let V3204 (shen.lazyderef (tl V3202) V3537) (if (cons? V3204) (let B (hd V3204) (let V3205 (shen.lazyderef (tl V3204) V3537) (if (= () V3205) (do (shen.incinfs) (identical V3534 Y V3537 (freeze (unify! V3535 B V3537 V3538)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3206 (shen.lazyderef V3536 V3537) (if (cons? V3206) (let Hyp (tl V3206) (do (shen.incinfs) (shen.by_hypothesis V3534 V3535 Hyp V3537 V3538))) false)) Case)))

(defun shen.t*-def (V3544 V3545 V3546 V3547 V3548) (let V3194 (shen.lazyderef V3544 V3547) (if (cons? V3194) (let V3195 (shen.lazyderef (hd V3194) V3547) (if (= define V3195) (let V3196 (shen.lazyderef (tl V3194) V3547) (if (cons? V3196) (let F (hd V3196) (let X (tl V3196) (let Y (shen.newpv V3547) (let E (shen.newpv V3547) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3545 V3546 V3547 V3548)))))) false)) false)) false)))

(defun shen.t*-defh (V3555 V3556 V3557 V3558 V3559 V3560) (let V3190 (shen.lazyderef V3555 V3559) (if (cons? V3190) (let Sig (hd V3190) (let Rules (tl V3190) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3556 V3557 V3558 Rules V3559 V3560)))) false)))

(defun shen.t*-defhh (V3569 V3570 V3571 V3572 V3573 V3574 V3575 V3576) (do (shen.incinfs) (shen.t*-rules V3574 V3570 1 V3571 (cons (cons V3571 (cons : (cons V3570 ()))) V3573) V3575 (freeze (shen.memo V3571 V3569 V3572 V3575 V3576)))))

(defun shen.memo (V3582 V3583 V3584 V3585 V3586) (let Jnk (shen.newpv V3585) (do (shen.incinfs) (unify! V3584 V3583 V3585 (freeze (bind Jnk (declare (shen.lazyderef V3582 V3585) (shen.lazyderef V3584 V3585)) V3585 V3586))))))

(defun shen.<sig+rules> (V3588) (let Parse_shen.<signature> (shen.<signature> V3588) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3590) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3590) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3590) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3592) (cond ((and (cons? V3592) (and (cons? (tl V3592)) (and (= () (tl (tl V3592))) (= (hd V3592) protect)))) V3592) ((cons? V3592) (map (lambda Z (shen.ue Z)) V3592)) ((variable? V3592) (concat && V3592)) (true V3592)))

(defun shen.ue-sig (V3594) (cond ((cons? V3594) (map (lambda Z (shen.ue-sig Z)) V3594)) ((variable? V3594) (concat &&& V3594)) (true V3594)))

(defun shen.ues (V3600) (cond ((shen.ue? V3600) (cons V3600 ())) ((cons? V3600) (union (shen.ues (hd V3600)) (shen.ues (tl V3600)))) (true ())))

(defun shen.ue? (V3602) (and (symbol? V3602) (shen.ue-h? (str V3602))))

(defun shen.ue-h? (V3610) (cond ((and (shen.+string? V3610) (and (= "&" (pos V3610 0)) (and (shen.+string? (tlstr V3610)) (= "&" (pos (tlstr V3610) 0))))) true) (true false)))

(defun shen.t*-rules (V3618 V3619 V3620 V3621 V3622 V3623 V3624) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3174 (shen.lazyderef V3618 V3623) (if (= () V3174) (do (shen.incinfs) (thaw V3624)) false)) (if (= Case false) (let Case (let V3175 (shen.lazyderef V3618 V3623) (if (cons? V3175) (let Rule (hd V3175) (let Rules (tl V3175) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3619 V3622 V3623 (freeze (cut Throwcontrol V3623 (freeze (shen.t*-rules Rules V3619 (+ V3620 1) V3621 V3622 V3623 V3624)))))))) false)) (if (= Case false) (let Err (shen.newpv V3623) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3620 V3623) (cn " of " (shen.app (shen.lazyderef V3621 V3623) "" shen.a)) shen.a))) V3623 V3624))) Case)) Case)))))

(defun shen.t*-rule (V3630 V3631 V3632 V3633 V3634) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3166 (shen.lazyderef V3630 V3633) (if (cons? V3166) (let Patterns (hd V3166) (let V3167 (shen.lazyderef (tl V3166) V3633) (if (cons? V3167) (let Action (hd V3167) (let V3168 (shen.lazyderef (tl V3167) V3633) (if (= () V3168) (let NewHyps (shen.newpv V3633) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3632 NewHyps V3633 (freeze (shen.t*-patterns Patterns V3631 NewHyps V3633 (freeze (cut Throwcontrol V3633 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3631) (shen.patthyps Patterns V3631 V3632) V3633 V3634))))))))) false))) false))) false)))))

(defun shen.placeholders (V3640) (cond ((shen.ue? V3640) (cons V3640 ())) ((cons? V3640) (union (shen.placeholders (hd V3640)) (shen.placeholders (tl V3640)))) (true ())))

(defun shen.newhyps (V3646 V3647 V3648 V3649 V3650) (let Case (let V3153 (shen.lazyderef V3646 V3649) (if (= () V3153) (do (shen.incinfs) (unify! V3648 V3647 V3649 V3650)) false)) (if (= Case false) (let V3154 (shen.lazyderef V3646 V3649) (if (cons? V3154) (let V3149 (hd V3154) (let Vs (tl V3154) (let V3155 (shen.lazyderef V3648 V3649) (if (cons? V3155) (let V3156 (shen.lazyderef (hd V3155) V3649) (if (cons? V3156) (let V (hd V3156) (let V3157 (shen.lazyderef (tl V3156) V3649) (if (cons? V3157) (let V3158 (shen.lazyderef (hd V3157) V3649) (if (= : V3158) (let V3159 (shen.lazyderef (tl V3157) V3649) (if (cons? V3159) (let A (hd V3159) (let V3160 (shen.lazyderef (tl V3159) V3649) (if (= () V3160) (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (if (shen.pvar? V3160) (do (shen.bindv V3160 () V3649) (let Result (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (do (shen.unbindv V3160 V3649) Result))) false)))) (if (shen.pvar? V3159) (let A (shen.newpv V3649) (do (shen.bindv V3159 (cons A ()) V3649) (let Result (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (do (shen.unbindv V3159 V3649) Result)))) false))) (if (shen.pvar? V3158) (do (shen.bindv V3158 : V3649) (let Result (let V3161 (shen.lazyderef (tl V3157) V3649) (if (cons? V3161) (let A (hd V3161) (let V3162 (shen.lazyderef (tl V3161) V3649) (if (= () V3162) (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (if (shen.pvar? V3162) (do (shen.bindv V3162 () V3649) (let Result (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (do (shen.unbindv V3162 V3649) Result))) false)))) (if (shen.pvar? V3161) (let A (shen.newpv V3649) (do (shen.bindv V3161 (cons A ()) V3649) (let Result (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (do (shen.unbindv V3161 V3649) Result)))) false))) (do (shen.unbindv V3158 V3649) Result))) false))) (if (shen.pvar? V3157) (let A (shen.newpv V3649) (do (shen.bindv V3157 (cons : (cons A ())) V3649) (let Result (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (do (shen.unbindv V3157 V3649) Result)))) false)))) (if (shen.pvar? V3156) (let V (shen.newpv V3649) (let A (shen.newpv V3649) (do (shen.bindv V3156 (cons V (cons : (cons A ()))) V3649) (let Result (let NewHyp (tl V3155) (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650))))) (do (shen.unbindv V3156 V3649) Result))))) false))) (if (shen.pvar? V3155) (let V (shen.newpv V3649) (let A (shen.newpv V3649) (let NewHyp (shen.newpv V3649) (do (shen.bindv V3155 (cons (cons V (cons : (cons A ()))) NewHyp) V3649) (let Result (do (shen.incinfs) (unify! V V3149 V3649 (freeze (shen.newhyps Vs V3647 NewHyp V3649 V3650)))) (do (shen.unbindv V3155 V3649) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3656 V3657 V3658) (cond ((= () V3656) V3658) ((and (cons? V3656) (and (cons? V3657) (and (cons? (tl V3657)) (and (= --> (hd (tl V3657))) (and (cons? (tl (tl V3657))) (= () (tl (tl (tl V3657))))))))) (adjoin (cons (hd V3656) (cons : (cons (hd V3657) ()))) (shen.patthyps (tl V3656) (hd (tl (tl V3657))) V3658))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3665 V3666) (cond ((and (= () V3665) (and (cons? V3666) (and (= --> (hd V3666)) (and (cons? (tl V3666)) (= () (tl (tl V3666))))))) (hd (tl V3666))) ((= () V3665) V3666) ((and (cons? V3665) (and (cons? V3666) (and (cons? (tl V3666)) (and (= --> (hd (tl V3666))) (and (cons? (tl (tl V3666))) (= () (tl (tl (tl V3666))))))))) (shen.result-type (tl V3665) (hd (tl (tl V3666))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3672 V3673 V3674 V3675 V3676) (let Case (let V3141 (shen.lazyderef V3672 V3675) (if (= () V3141) (do (shen.incinfs) (thaw V3676)) false)) (if (= Case false) (let V3142 (shen.lazyderef V3672 V3675) (if (cons? V3142) (let Pattern (hd V3142) (let Patterns (tl V3142) (let V3143 (shen.lazyderef V3673 V3675) (if (cons? V3143) (let A (hd V3143) (let V3144 (shen.lazyderef (tl V3143) V3675) (if (cons? V3144) (let V3145 (shen.lazyderef (hd V3144) V3675) (if (= --> V3145) (let V3146 (shen.lazyderef (tl V3144) V3675) (if (cons? V3146) (let B (hd V3146) (let V3147 (shen.lazyderef (tl V3146) V3675) (if (= () V3147) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3674 V3675 (freeze (shen.t*-patterns Patterns B V3674 V3675 V3676)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3682 V3683 V3684 V3685 V3686) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3118 (shen.lazyderef V3682 V3685) (if (cons? V3118) (let V3119 (shen.lazyderef (hd V3118) V3685) (if (= where V3119) (let V3120 (shen.lazyderef (tl V3118) V3685) (if (cons? V3120) (let P (hd V3120) (let V3121 (shen.lazyderef (tl V3120) V3685) (if (cons? V3121) (let Action (hd V3121) (let V3122 (shen.lazyderef (tl V3121) V3685) (if (= () V3122) (do (shen.incinfs) (cut Throwcontrol V3685 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3684 V3685 (freeze (cut Throwcontrol V3685 (freeze (shen.t*-action Action V3683 (cons (cons P (cons : (cons verified ()))) V3684) V3685 V3686)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3123 (shen.lazyderef V3682 V3685) (if (cons? V3123) (let V3124 (shen.lazyderef (hd V3123) V3685) (if (= shen.choicepoint! V3124) (let V3125 (shen.lazyderef (tl V3123) V3685) (if (cons? V3125) (let V3126 (shen.lazyderef (hd V3125) V3685) (if (cons? V3126) (let V3127 (shen.lazyderef (hd V3126) V3685) (if (cons? V3127) (let V3128 (shen.lazyderef (hd V3127) V3685) (if (= fail-if V3128) (let V3129 (shen.lazyderef (tl V3127) V3685) (if (cons? V3129) (let F (hd V3129) (let V3130 (shen.lazyderef (tl V3129) V3685) (if (= () V3130) (let V3131 (shen.lazyderef (tl V3126) V3685) (if (cons? V3131) (let Action (hd V3131) (let V3132 (shen.lazyderef (tl V3131) V3685) (if (= () V3132) (let V3133 (shen.lazyderef (tl V3125) V3685) (if (= () V3133) (do (shen.incinfs) (cut Throwcontrol V3685 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3683 V3684 V3685 V3686)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3134 (shen.lazyderef V3682 V3685) (if (cons? V3134) (let V3135 (shen.lazyderef (hd V3134) V3685) (if (= shen.choicepoint! V3135) (let V3136 (shen.lazyderef (tl V3134) V3685) (if (cons? V3136) (let Action (hd V3136) (let V3137 (shen.lazyderef (tl V3136) V3685) (if (= () V3137) (do (shen.incinfs) (cut Throwcontrol V3685 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3683 V3684 V3685 V3686)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3682 (cons : (cons V3683 ()))) V3684 V3685 V3686)) Case)) Case)) Case)))))

(defun findall (V3692 V3693 V3694 V3695 V3696) (let B (shen.newpv V3695) (let A (shen.newpv V3695) (do (shen.incinfs) (bind A (gensym shen.a) V3695 (freeze (bind B (set (shen.lazyderef A V3695) ()) V3695 (freeze (shen.findallhelp V3692 V3693 V3694 A V3695 V3696)))))))))

(defun shen.findallhelp (V3703 V3704 V3705 V3706 V3707 V3708) (let Case (do (shen.incinfs) (call V3704 V3707 (freeze (shen.remember V3706 V3703 V3707 (freeze (fwhen false V3707 V3708)))))) (if (= Case false) (do (shen.incinfs) (bind V3705 (value (shen.lazyderef V3706 V3707)) V3707 V3708)) Case)))

(defun shen.remember (V3713 V3714 V3715 V3716) (let B (shen.newpv V3715) (do (shen.incinfs) (bind B (set (shen.deref V3713 V3715) (cons (shen.deref V3714 V3715) (value (shen.deref V3713 V3715)))) V3715 V3716))))



