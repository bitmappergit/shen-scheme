"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V3377 V3378) (let Curry (shen.curry V3377) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V3378)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V3380) (cond ((and (cons? V3380) (shen.special? (hd V3380))) (cons (hd V3380) (map (lambda Y (shen.curry Y)) (tl V3380)))) ((and (cons? V3380) (and (cons? (tl V3380)) (shen.extraspecial? (hd V3380)))) V3380) ((and (cons? V3380) (and (= type (hd V3380)) (and (cons? (tl V3380)) (and (cons? (tl (tl V3380))) (= () (tl (tl (tl V3380)))))))) (cons type (cons (shen.curry (hd (tl V3380))) (tl (tl V3380))))) ((and (cons? V3380) (and (cons? (tl V3380)) (cons? (tl (tl V3380))))) (shen.curry (cons (cons (hd V3380) (cons (hd (tl V3380)) ())) (tl (tl V3380))))) ((and (cons? V3380) (and (cons? (tl V3380)) (= () (tl (tl V3380))))) (cons (shen.curry (hd V3380)) (cons (shen.curry (hd (tl V3380))) ()))) (true V3380)))

(defun shen.special? (V3382) (element? V3382 (value shen.*special*)))

(defun shen.extraspecial? (V3384) (element? V3384 (value shen.*extraspecial*)))

(defun shen.t* (V3389 V3390 V3391 V3392) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V3391) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V3391 (freeze (bind Error (shen.errormaxinfs) V3391 V3392))))) (if (= Case false) (let Case (let V3369 (shen.lazyderef V3389 V3391) (if (= fail V3369) (do (shen.incinfs) (cut Throwcontrol V3391 (freeze (shen.prolog-failure V3391 V3392)))) false)) (if (= Case false) (let Case (let V3370 (shen.lazyderef V3389 V3391) (if (cons? V3370) (let X (hd V3370) (let V3371 (shen.lazyderef (tl V3370) V3391) (if (cons? V3371) (let V3372 (shen.lazyderef (hd V3371) V3391) (if (= : V3372) (let V3373 (shen.lazyderef (tl V3371) V3391) (if (cons? V3373) (let A (hd V3373) (let V3374 (shen.lazyderef (tl V3373) V3391) (if (= () V3374) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V3391 (freeze (cut Throwcontrol V3391 (freeze (shen.th* X A V3390 V3391 V3392)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V3391) (do (shen.incinfs) (shen.show V3389 V3390 V3391 (freeze (bind Datatypes (value shen.*datatypes*) V3391 (freeze (shen.udefs* V3389 V3390 Datatypes V3391 V3392))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V3398) (cond ((= + V3398) (set shen.*shen-type-theory-enabled?* true)) ((= - V3398) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V3409 V3410) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V3416 V3417 V3418 V3419 V3420) (let Case (let V3365 (shen.lazyderef V3418 V3419) (if (cons? V3365) (let D (hd V3365) (do (shen.incinfs) (call (cons D (cons V3416 (cons V3417 ()))) V3419 V3420))) false)) (if (= Case false) (let V3366 (shen.lazyderef V3418 V3419) (if (cons? V3366) (let Ds (tl V3366) (do (shen.incinfs) (shen.udefs* V3416 V3417 Ds V3419 V3420))) false)) Case)))

(defun shen.th* (V3426 V3427 V3428 V3429 V3430) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V3426 (cons : (cons V3427 ()))) V3428 V3429 (freeze (fwhen false V3429 V3430)))) (if (= Case false) (let Case (let F (shen.newpv V3429) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V3426 V3429)) V3429 (freeze (bind F (shen.sigf (shen.lazyderef V3426 V3429)) V3429 (freeze (call (cons F (cons V3427 ())) V3429 V3430))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V3426 V3427 V3429 V3430)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V3426 V3427 V3428 V3429 V3430)) (if (= Case false) (let Case (let V3261 (shen.lazyderef V3426 V3429) (if (cons? V3261) (let F (hd V3261) (let V3262 (shen.lazyderef (tl V3261) V3429) (if (= () V3262) (do (shen.incinfs) (shen.th* F (cons --> (cons V3427 ())) V3428 V3429 V3430)) false))) false)) (if (= Case false) (let Case (let V3263 (shen.lazyderef V3426 V3429) (if (cons? V3263) (let F (hd V3263) (let V3264 (shen.lazyderef (tl V3263) V3429) (if (cons? V3264) (let X (hd V3264) (let V3265 (shen.lazyderef (tl V3264) V3429) (if (= () V3265) (let B (shen.newpv V3429) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V3427 ()))) V3428 V3429 (freeze (shen.th* X B V3428 V3429 V3430))))) false))) false))) false)) (if (= Case false) (let Case (let V3266 (shen.lazyderef V3426 V3429) (if (cons? V3266) (let V3267 (shen.lazyderef (hd V3266) V3429) (if (= cons V3267) (let V3268 (shen.lazyderef (tl V3266) V3429) (if (cons? V3268) (let X (hd V3268) (let V3269 (shen.lazyderef (tl V3268) V3429) (if (cons? V3269) (let Y (hd V3269) (let V3270 (shen.lazyderef (tl V3269) V3429) (if (= () V3270) (let V3271 (shen.lazyderef V3427 V3429) (if (cons? V3271) (let V3272 (shen.lazyderef (hd V3271) V3429) (if (= list V3272) (let V3273 (shen.lazyderef (tl V3271) V3429) (if (cons? V3273) (let A (hd V3273) (let V3274 (shen.lazyderef (tl V3273) V3429) (if (= () V3274) (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (if (shen.pvar? V3274) (do (shen.bindv V3274 () V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3274 V3429) Result))) false)))) (if (shen.pvar? V3273) (let A (shen.newpv V3429) (do (shen.bindv V3273 (cons A ()) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3273 V3429) Result)))) false))) (if (shen.pvar? V3272) (do (shen.bindv V3272 list V3429) (let Result (let V3275 (shen.lazyderef (tl V3271) V3429) (if (cons? V3275) (let A (hd V3275) (let V3276 (shen.lazyderef (tl V3275) V3429) (if (= () V3276) (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (if (shen.pvar? V3276) (do (shen.bindv V3276 () V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3276 V3429) Result))) false)))) (if (shen.pvar? V3275) (let A (shen.newpv V3429) (do (shen.bindv V3275 (cons A ()) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3275 V3429) Result)))) false))) (do (shen.unbindv V3272 V3429) Result))) false))) (if (shen.pvar? V3271) (let A (shen.newpv V3429) (do (shen.bindv V3271 (cons list (cons A ())) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons list (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3271 V3429) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3277 (shen.lazyderef V3426 V3429) (if (cons? V3277) (let V3278 (shen.lazyderef (hd V3277) V3429) (if (= @p V3278) (let V3279 (shen.lazyderef (tl V3277) V3429) (if (cons? V3279) (let X (hd V3279) (let V3280 (shen.lazyderef (tl V3279) V3429) (if (cons? V3280) (let Y (hd V3280) (let V3281 (shen.lazyderef (tl V3280) V3429) (if (= () V3281) (let V3282 (shen.lazyderef V3427 V3429) (if (cons? V3282) (let A (hd V3282) (let V3283 (shen.lazyderef (tl V3282) V3429) (if (cons? V3283) (let V3284 (shen.lazyderef (hd V3283) V3429) (if (= * V3284) (let V3285 (shen.lazyderef (tl V3283) V3429) (if (cons? V3285) (let B (hd V3285) (let V3286 (shen.lazyderef (tl V3285) V3429) (if (= () V3286) (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (if (shen.pvar? V3286) (do (shen.bindv V3286 () V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (do (shen.unbindv V3286 V3429) Result))) false)))) (if (shen.pvar? V3285) (let B (shen.newpv V3429) (do (shen.bindv V3285 (cons B ()) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (do (shen.unbindv V3285 V3429) Result)))) false))) (if (shen.pvar? V3284) (do (shen.bindv V3284 * V3429) (let Result (let V3287 (shen.lazyderef (tl V3283) V3429) (if (cons? V3287) (let B (hd V3287) (let V3288 (shen.lazyderef (tl V3287) V3429) (if (= () V3288) (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (if (shen.pvar? V3288) (do (shen.bindv V3288 () V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (do (shen.unbindv V3288 V3429) Result))) false)))) (if (shen.pvar? V3287) (let B (shen.newpv V3429) (do (shen.bindv V3287 (cons B ()) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (do (shen.unbindv V3287 V3429) Result)))) false))) (do (shen.unbindv V3284 V3429) Result))) false))) (if (shen.pvar? V3283) (let B (shen.newpv V3429) (do (shen.bindv V3283 (cons * (cons B ())) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (do (shen.unbindv V3283 V3429) Result)))) false)))) (if (shen.pvar? V3282) (let A (shen.newpv V3429) (let B (shen.newpv V3429) (do (shen.bindv V3282 (cons A (cons * (cons B ()))) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y B V3428 V3429 V3430)))) (do (shen.unbindv V3282 V3429) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3289 (shen.lazyderef V3426 V3429) (if (cons? V3289) (let V3290 (shen.lazyderef (hd V3289) V3429) (if (= @v V3290) (let V3291 (shen.lazyderef (tl V3289) V3429) (if (cons? V3291) (let X (hd V3291) (let V3292 (shen.lazyderef (tl V3291) V3429) (if (cons? V3292) (let Y (hd V3292) (let V3293 (shen.lazyderef (tl V3292) V3429) (if (= () V3293) (let V3294 (shen.lazyderef V3427 V3429) (if (cons? V3294) (let V3295 (shen.lazyderef (hd V3294) V3429) (if (= vector V3295) (let V3296 (shen.lazyderef (tl V3294) V3429) (if (cons? V3296) (let A (hd V3296) (let V3297 (shen.lazyderef (tl V3296) V3429) (if (= () V3297) (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (if (shen.pvar? V3297) (do (shen.bindv V3297 () V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3297 V3429) Result))) false)))) (if (shen.pvar? V3296) (let A (shen.newpv V3429) (do (shen.bindv V3296 (cons A ()) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3296 V3429) Result)))) false))) (if (shen.pvar? V3295) (do (shen.bindv V3295 vector V3429) (let Result (let V3298 (shen.lazyderef (tl V3294) V3429) (if (cons? V3298) (let A (hd V3298) (let V3299 (shen.lazyderef (tl V3298) V3429) (if (= () V3299) (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (if (shen.pvar? V3299) (do (shen.bindv V3299 () V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3299 V3429) Result))) false)))) (if (shen.pvar? V3298) (let A (shen.newpv V3429) (do (shen.bindv V3298 (cons A ()) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3298 V3429) Result)))) false))) (do (shen.unbindv V3295 V3429) Result))) false))) (if (shen.pvar? V3294) (let A (shen.newpv V3429) (do (shen.bindv V3294 (cons vector (cons A ())) V3429) (let Result (do (shen.incinfs) (shen.th* X A V3428 V3429 (freeze (shen.th* Y (cons vector (cons A ())) V3428 V3429 V3430)))) (do (shen.unbindv V3294 V3429) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3300 (shen.lazyderef V3426 V3429) (if (cons? V3300) (let V3301 (shen.lazyderef (hd V3300) V3429) (if (= @s V3301) (let V3302 (shen.lazyderef (tl V3300) V3429) (if (cons? V3302) (let X (hd V3302) (let V3303 (shen.lazyderef (tl V3302) V3429) (if (cons? V3303) (let Y (hd V3303) (let V3304 (shen.lazyderef (tl V3303) V3429) (if (= () V3304) (let V3305 (shen.lazyderef V3427 V3429) (if (= string V3305) (do (shen.incinfs) (shen.th* X string V3428 V3429 (freeze (shen.th* Y string V3428 V3429 V3430)))) (if (shen.pvar? V3305) (do (shen.bindv V3305 string V3429) (let Result (do (shen.incinfs) (shen.th* X string V3428 V3429 (freeze (shen.th* Y string V3428 V3429 V3430)))) (do (shen.unbindv V3305 V3429) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3306 (shen.lazyderef V3426 V3429) (if (cons? V3306) (let V3307 (shen.lazyderef (hd V3306) V3429) (if (= lambda V3307) (let V3308 (shen.lazyderef (tl V3306) V3429) (if (cons? V3308) (let X (hd V3308) (let V3309 (shen.lazyderef (tl V3308) V3429) (if (cons? V3309) (let Y (hd V3309) (let V3310 (shen.lazyderef (tl V3309) V3429) (if (= () V3310) (let V3311 (shen.lazyderef V3427 V3429) (if (cons? V3311) (let A (hd V3311) (let V3312 (shen.lazyderef (tl V3311) V3429) (if (cons? V3312) (let V3313 (shen.lazyderef (hd V3312) V3429) (if (= --> V3313) (let V3314 (shen.lazyderef (tl V3312) V3429) (if (cons? V3314) (let B (hd V3314) (let V3315 (shen.lazyderef (tl V3314) V3429) (if (= () V3315) (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (if (shen.pvar? V3315) (do (shen.bindv V3315 () V3429) (let Result (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (do (shen.unbindv V3315 V3429) Result))) false)))) (if (shen.pvar? V3314) (let B (shen.newpv V3429) (do (shen.bindv V3314 (cons B ()) V3429) (let Result (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (do (shen.unbindv V3314 V3429) Result)))) false))) (if (shen.pvar? V3313) (do (shen.bindv V3313 --> V3429) (let Result (let V3316 (shen.lazyderef (tl V3312) V3429) (if (cons? V3316) (let B (hd V3316) (let V3317 (shen.lazyderef (tl V3316) V3429) (if (= () V3317) (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (if (shen.pvar? V3317) (do (shen.bindv V3317 () V3429) (let Result (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (do (shen.unbindv V3317 V3429) Result))) false)))) (if (shen.pvar? V3316) (let B (shen.newpv V3429) (do (shen.bindv V3316 (cons B ()) V3429) (let Result (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (do (shen.unbindv V3316 V3429) Result)))) false))) (do (shen.unbindv V3313 V3429) Result))) false))) (if (shen.pvar? V3312) (let B (shen.newpv V3429) (do (shen.bindv V3312 (cons --> (cons B ())) V3429) (let Result (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (do (shen.unbindv V3312 V3429) Result)))) false)))) (if (shen.pvar? V3311) (let A (shen.newpv V3429) (let B (shen.newpv V3429) (do (shen.bindv V3311 (cons A (cons --> (cons B ()))) V3429) (let Result (let Z (shen.newpv V3429) (let X&& (shen.newpv V3429) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Y V3429)) V3429 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V3428) V3429 V3430)))))))))) (do (shen.unbindv V3311 V3429) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3318 (shen.lazyderef V3426 V3429) (if (cons? V3318) (let V3319 (shen.lazyderef (hd V3318) V3429) (if (= let V3319) (let V3320 (shen.lazyderef (tl V3318) V3429) (if (cons? V3320) (let X (hd V3320) (let V3321 (shen.lazyderef (tl V3320) V3429) (if (cons? V3321) (let Y (hd V3321) (let V3322 (shen.lazyderef (tl V3321) V3429) (if (cons? V3322) (let Z (hd V3322) (let V3323 (shen.lazyderef (tl V3322) V3429) (if (= () V3323) (let W (shen.newpv V3429) (let X&& (shen.newpv V3429) (let B (shen.newpv V3429) (do (shen.incinfs) (shen.th* Y B V3428 V3429 (freeze (bind X&& (shen.placeholder) V3429 (freeze (bind W (shen.ebr (shen.lazyderef X&& V3429) (shen.lazyderef X V3429) (shen.lazyderef Z V3429)) V3429 (freeze (shen.th* W V3427 (cons (cons X&& (cons : (cons B ()))) V3428) V3429 V3430))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3324 (shen.lazyderef V3426 V3429) (if (cons? V3324) (let V3325 (shen.lazyderef (hd V3324) V3429) (if (= open V3325) (let V3326 (shen.lazyderef (tl V3324) V3429) (if (cons? V3326) (let FileName (hd V3326) (let V3327 (shen.lazyderef (tl V3326) V3429) (if (cons? V3327) (let Direction3257 (hd V3327) (let V3328 (shen.lazyderef (tl V3327) V3429) (if (= () V3328) (let V3329 (shen.lazyderef V3427 V3429) (if (cons? V3329) (let V3330 (shen.lazyderef (hd V3329) V3429) (if (= stream V3330) (let V3331 (shen.lazyderef (tl V3329) V3429) (if (cons? V3331) (let Direction (hd V3331) (let V3332 (shen.lazyderef (tl V3331) V3429) (if (= () V3332) (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (if (shen.pvar? V3332) (do (shen.bindv V3332 () V3429) (let Result (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (do (shen.unbindv V3332 V3429) Result))) false)))) (if (shen.pvar? V3331) (let Direction (shen.newpv V3429) (do (shen.bindv V3331 (cons Direction ()) V3429) (let Result (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (do (shen.unbindv V3331 V3429) Result)))) false))) (if (shen.pvar? V3330) (do (shen.bindv V3330 stream V3429) (let Result (let V3333 (shen.lazyderef (tl V3329) V3429) (if (cons? V3333) (let Direction (hd V3333) (let V3334 (shen.lazyderef (tl V3333) V3429) (if (= () V3334) (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (if (shen.pvar? V3334) (do (shen.bindv V3334 () V3429) (let Result (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (do (shen.unbindv V3334 V3429) Result))) false)))) (if (shen.pvar? V3333) (let Direction (shen.newpv V3429) (do (shen.bindv V3333 (cons Direction ()) V3429) (let Result (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (do (shen.unbindv V3333 V3429) Result)))) false))) (do (shen.unbindv V3330 V3429) Result))) false))) (if (shen.pvar? V3329) (let Direction (shen.newpv V3429) (do (shen.bindv V3329 (cons stream (cons Direction ())) V3429) (let Result (do (shen.incinfs) (unify! Direction Direction3257 V3429 (freeze (cut Throwcontrol V3429 (freeze (fwhen (element? (shen.lazyderef Direction V3429) (cons in (cons out ()))) V3429 (freeze (shen.th* FileName string V3428 V3429 V3430)))))))) (do (shen.unbindv V3329 V3429) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3335 (shen.lazyderef V3426 V3429) (if (cons? V3335) (let V3336 (shen.lazyderef (hd V3335) V3429) (if (= type V3336) (let V3337 (shen.lazyderef (tl V3335) V3429) (if (cons? V3337) (let X (hd V3337) (let V3338 (shen.lazyderef (tl V3337) V3429) (if (cons? V3338) (let A (hd V3338) (let V3339 (shen.lazyderef (tl V3338) V3429) (if (= () V3339) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (unify A V3427 V3429 (freeze (shen.th* X A V3428 V3429 V3430)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3340 (shen.lazyderef V3426 V3429) (if (cons? V3340) (let V3341 (shen.lazyderef (hd V3340) V3429) (if (= input+ V3341) (let V3342 (shen.lazyderef (tl V3340) V3429) (if (cons? V3342) (let A (hd V3342) (let V3343 (shen.lazyderef (tl V3342) V3429) (if (cons? V3343) (let Stream (hd V3343) (let V3344 (shen.lazyderef (tl V3343) V3429) (if (= () V3344) (let C (shen.newpv V3429) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V3429)) V3429 (freeze (unify V3427 C V3429 (freeze (shen.th* Stream (cons stream (cons in ())) V3428 V3429 V3430))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3345 (shen.lazyderef V3426 V3429) (if (cons? V3345) (let V3346 (shen.lazyderef (hd V3345) V3429) (if (= set V3346) (let V3347 (shen.lazyderef (tl V3345) V3429) (if (cons? V3347) (let Var (hd V3347) (let V3348 (shen.lazyderef (tl V3347) V3429) (if (cons? V3348) (let Val (hd V3348) (let V3349 (shen.lazyderef (tl V3348) V3429) (if (= () V3349) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (shen.th* Var symbol V3428 V3429 (freeze (cut Throwcontrol V3429 (freeze (shen.th* (cons value (cons Var ())) V3427 V3428 V3429 (freeze (shen.th* Val V3427 V3428 V3429 V3430)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V3429) (do (shen.incinfs) (shen.t*-hyps V3428 NewHyp V3429 (freeze (shen.th* V3426 V3427 NewHyp V3429 V3430))))) (if (= Case false) (let Case (let V3350 (shen.lazyderef V3426 V3429) (if (cons? V3350) (let V3351 (shen.lazyderef (hd V3350) V3429) (if (= define V3351) (let V3352 (shen.lazyderef (tl V3350) V3429) (if (cons? V3352) (let F (hd V3352) (let X (tl V3352) (do (shen.incinfs) (cut Throwcontrol V3429 (freeze (shen.t*-def (cons define (cons F X)) V3427 V3428 V3429 V3430)))))) false)) false)) false)) (if (= Case false) (let Case (let V3353 (shen.lazyderef V3426 V3429) (if (cons? V3353) (let V3354 (shen.lazyderef (hd V3353) V3429) (if (= defmacro V3354) (let V3355 (shen.lazyderef V3427 V3429) (if (= unit V3355) (do (shen.incinfs) (cut Throwcontrol V3429 V3430)) (if (shen.pvar? V3355) (do (shen.bindv V3355 unit V3429) (let Result (do (shen.incinfs) (cut Throwcontrol V3429 V3430)) (do (shen.unbindv V3355 V3429) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3356 (shen.lazyderef V3426 V3429) (if (cons? V3356) (let V3357 (shen.lazyderef (hd V3356) V3429) (if (= shen.process-datatype V3357) (let V3358 (shen.lazyderef V3427 V3429) (if (= symbol V3358) (do (shen.incinfs) (thaw V3430)) (if (shen.pvar? V3358) (do (shen.bindv V3358 symbol V3429) (let Result (do (shen.incinfs) (thaw V3430)) (do (shen.unbindv V3358 V3429) Result))) false))) false)) false)) (if (= Case false) (let Case (let V3359 (shen.lazyderef V3426 V3429) (if (cons? V3359) (let V3360 (shen.lazyderef (hd V3359) V3429) (if (= shen.synonyms-help V3360) (let V3361 (shen.lazyderef V3427 V3429) (if (= symbol V3361) (do (shen.incinfs) (thaw V3430)) (if (shen.pvar? V3361) (do (shen.bindv V3361 symbol V3429) (let Result (do (shen.incinfs) (thaw V3430)) (do (shen.unbindv V3361 V3429) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V3429) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V3429 (freeze (shen.udefs* (cons V3426 (cons : (cons V3427 ()))) V3428 Datatypes V3429 V3430))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V3435 V3436 V3437 V3438) (let Case (let V3172 (shen.lazyderef V3435 V3437) (if (cons? V3172) (let V3173 (shen.lazyderef (hd V3172) V3437) (if (cons? V3173) (let V3174 (shen.lazyderef (hd V3173) V3437) (if (cons? V3174) (let V3175 (shen.lazyderef (hd V3174) V3437) (if (= cons V3175) (let V3176 (shen.lazyderef (tl V3174) V3437) (if (cons? V3176) (let X (hd V3176) (let V3177 (shen.lazyderef (tl V3176) V3437) (if (cons? V3177) (let Y (hd V3177) (let V3178 (shen.lazyderef (tl V3177) V3437) (if (= () V3178) (let V3179 (shen.lazyderef (tl V3173) V3437) (if (cons? V3179) (let V3180 (shen.lazyderef (hd V3179) V3437) (if (= : V3180) (let V3181 (shen.lazyderef (tl V3179) V3437) (if (cons? V3181) (let V3182 (shen.lazyderef (hd V3181) V3437) (if (cons? V3182) (let V3183 (shen.lazyderef (hd V3182) V3437) (if (= list V3183) (let V3184 (shen.lazyderef (tl V3182) V3437) (if (cons? V3184) (let A (hd V3184) (let V3185 (shen.lazyderef (tl V3184) V3437) (if (= () V3185) (let V3186 (shen.lazyderef (tl V3181) V3437) (if (= () V3186) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3186) (do (shen.bindv V3186 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3186 V3437) Result))) false))) (if (shen.pvar? V3185) (do (shen.bindv V3185 () V3437) (let Result (let V3187 (shen.lazyderef (tl V3181) V3437) (if (= () V3187) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3187) (do (shen.bindv V3187 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3187 V3437) Result))) false))) (do (shen.unbindv V3185 V3437) Result))) false)))) (if (shen.pvar? V3184) (let A (shen.newpv V3437) (do (shen.bindv V3184 (cons A ()) V3437) (let Result (let V3188 (shen.lazyderef (tl V3181) V3437) (if (= () V3188) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3188) (do (shen.bindv V3188 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3188 V3437) Result))) false))) (do (shen.unbindv V3184 V3437) Result)))) false))) (if (shen.pvar? V3183) (do (shen.bindv V3183 list V3437) (let Result (let V3189 (shen.lazyderef (tl V3182) V3437) (if (cons? V3189) (let A (hd V3189) (let V3190 (shen.lazyderef (tl V3189) V3437) (if (= () V3190) (let V3191 (shen.lazyderef (tl V3181) V3437) (if (= () V3191) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3191) (do (shen.bindv V3191 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3191 V3437) Result))) false))) (if (shen.pvar? V3190) (do (shen.bindv V3190 () V3437) (let Result (let V3192 (shen.lazyderef (tl V3181) V3437) (if (= () V3192) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3192) (do (shen.bindv V3192 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3192 V3437) Result))) false))) (do (shen.unbindv V3190 V3437) Result))) false)))) (if (shen.pvar? V3189) (let A (shen.newpv V3437) (do (shen.bindv V3189 (cons A ()) V3437) (let Result (let V3193 (shen.lazyderef (tl V3181) V3437) (if (= () V3193) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3193) (do (shen.bindv V3193 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3193 V3437) Result))) false))) (do (shen.unbindv V3189 V3437) Result)))) false))) (do (shen.unbindv V3183 V3437) Result))) false))) (if (shen.pvar? V3182) (let A (shen.newpv V3437) (do (shen.bindv V3182 (cons list (cons A ())) V3437) (let Result (let V3194 (shen.lazyderef (tl V3181) V3437) (if (= () V3194) (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3194) (do (shen.bindv V3194 () V3437) (let Result (let Hyp (tl V3172) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons list (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3194 V3437) Result))) false))) (do (shen.unbindv V3182 V3437) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3195 (shen.lazyderef V3435 V3437) (if (cons? V3195) (let V3196 (shen.lazyderef (hd V3195) V3437) (if (cons? V3196) (let V3197 (shen.lazyderef (hd V3196) V3437) (if (cons? V3197) (let V3198 (shen.lazyderef (hd V3197) V3437) (if (= @p V3198) (let V3199 (shen.lazyderef (tl V3197) V3437) (if (cons? V3199) (let X (hd V3199) (let V3200 (shen.lazyderef (tl V3199) V3437) (if (cons? V3200) (let Y (hd V3200) (let V3201 (shen.lazyderef (tl V3200) V3437) (if (= () V3201) (let V3202 (shen.lazyderef (tl V3196) V3437) (if (cons? V3202) (let V3203 (shen.lazyderef (hd V3202) V3437) (if (= : V3203) (let V3204 (shen.lazyderef (tl V3202) V3437) (if (cons? V3204) (let V3205 (shen.lazyderef (hd V3204) V3437) (if (cons? V3205) (let A (hd V3205) (let V3206 (shen.lazyderef (tl V3205) V3437) (if (cons? V3206) (let V3207 (shen.lazyderef (hd V3206) V3437) (if (= * V3207) (let V3208 (shen.lazyderef (tl V3206) V3437) (if (cons? V3208) (let B (hd V3208) (let V3209 (shen.lazyderef (tl V3208) V3437) (if (= () V3209) (let V3210 (shen.lazyderef (tl V3204) V3437) (if (= () V3210) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3210) (do (shen.bindv V3210 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3210 V3437) Result))) false))) (if (shen.pvar? V3209) (do (shen.bindv V3209 () V3437) (let Result (let V3211 (shen.lazyderef (tl V3204) V3437) (if (= () V3211) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3211) (do (shen.bindv V3211 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3211 V3437) Result))) false))) (do (shen.unbindv V3209 V3437) Result))) false)))) (if (shen.pvar? V3208) (let B (shen.newpv V3437) (do (shen.bindv V3208 (cons B ()) V3437) (let Result (let V3212 (shen.lazyderef (tl V3204) V3437) (if (= () V3212) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3212) (do (shen.bindv V3212 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3212 V3437) Result))) false))) (do (shen.unbindv V3208 V3437) Result)))) false))) (if (shen.pvar? V3207) (do (shen.bindv V3207 * V3437) (let Result (let V3213 (shen.lazyderef (tl V3206) V3437) (if (cons? V3213) (let B (hd V3213) (let V3214 (shen.lazyderef (tl V3213) V3437) (if (= () V3214) (let V3215 (shen.lazyderef (tl V3204) V3437) (if (= () V3215) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3215) (do (shen.bindv V3215 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3215 V3437) Result))) false))) (if (shen.pvar? V3214) (do (shen.bindv V3214 () V3437) (let Result (let V3216 (shen.lazyderef (tl V3204) V3437) (if (= () V3216) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3216) (do (shen.bindv V3216 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3216 V3437) Result))) false))) (do (shen.unbindv V3214 V3437) Result))) false)))) (if (shen.pvar? V3213) (let B (shen.newpv V3437) (do (shen.bindv V3213 (cons B ()) V3437) (let Result (let V3217 (shen.lazyderef (tl V3204) V3437) (if (= () V3217) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3217) (do (shen.bindv V3217 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3217 V3437) Result))) false))) (do (shen.unbindv V3213 V3437) Result)))) false))) (do (shen.unbindv V3207 V3437) Result))) false))) (if (shen.pvar? V3206) (let B (shen.newpv V3437) (do (shen.bindv V3206 (cons * (cons B ())) V3437) (let Result (let V3218 (shen.lazyderef (tl V3204) V3437) (if (= () V3218) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3218) (do (shen.bindv V3218 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3218 V3437) Result))) false))) (do (shen.unbindv V3206 V3437) Result)))) false)))) (if (shen.pvar? V3205) (let A (shen.newpv V3437) (let B (shen.newpv V3437) (do (shen.bindv V3205 (cons A (cons * (cons B ()))) V3437) (let Result (let V3219 (shen.lazyderef (tl V3204) V3437) (if (= () V3219) (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3219) (do (shen.bindv V3219 () V3437) (let Result (let Hyp (tl V3195) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (shen.lazyderef B V3437) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3219 V3437) Result))) false))) (do (shen.unbindv V3205 V3437) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3220 (shen.lazyderef V3435 V3437) (if (cons? V3220) (let V3221 (shen.lazyderef (hd V3220) V3437) (if (cons? V3221) (let V3222 (shen.lazyderef (hd V3221) V3437) (if (cons? V3222) (let V3223 (shen.lazyderef (hd V3222) V3437) (if (= @v V3223) (let V3224 (shen.lazyderef (tl V3222) V3437) (if (cons? V3224) (let X (hd V3224) (let V3225 (shen.lazyderef (tl V3224) V3437) (if (cons? V3225) (let Y (hd V3225) (let V3226 (shen.lazyderef (tl V3225) V3437) (if (= () V3226) (let V3227 (shen.lazyderef (tl V3221) V3437) (if (cons? V3227) (let V3228 (shen.lazyderef (hd V3227) V3437) (if (= : V3228) (let V3229 (shen.lazyderef (tl V3227) V3437) (if (cons? V3229) (let V3230 (shen.lazyderef (hd V3229) V3437) (if (cons? V3230) (let V3231 (shen.lazyderef (hd V3230) V3437) (if (= vector V3231) (let V3232 (shen.lazyderef (tl V3230) V3437) (if (cons? V3232) (let A (hd V3232) (let V3233 (shen.lazyderef (tl V3232) V3437) (if (= () V3233) (let V3234 (shen.lazyderef (tl V3229) V3437) (if (= () V3234) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3234) (do (shen.bindv V3234 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3234 V3437) Result))) false))) (if (shen.pvar? V3233) (do (shen.bindv V3233 () V3437) (let Result (let V3235 (shen.lazyderef (tl V3229) V3437) (if (= () V3235) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3235) (do (shen.bindv V3235 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3235 V3437) Result))) false))) (do (shen.unbindv V3233 V3437) Result))) false)))) (if (shen.pvar? V3232) (let A (shen.newpv V3437) (do (shen.bindv V3232 (cons A ()) V3437) (let Result (let V3236 (shen.lazyderef (tl V3229) V3437) (if (= () V3236) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3236) (do (shen.bindv V3236 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3236 V3437) Result))) false))) (do (shen.unbindv V3232 V3437) Result)))) false))) (if (shen.pvar? V3231) (do (shen.bindv V3231 vector V3437) (let Result (let V3237 (shen.lazyderef (tl V3230) V3437) (if (cons? V3237) (let A (hd V3237) (let V3238 (shen.lazyderef (tl V3237) V3437) (if (= () V3238) (let V3239 (shen.lazyderef (tl V3229) V3437) (if (= () V3239) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3239) (do (shen.bindv V3239 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3239 V3437) Result))) false))) (if (shen.pvar? V3238) (do (shen.bindv V3238 () V3437) (let Result (let V3240 (shen.lazyderef (tl V3229) V3437) (if (= () V3240) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3240) (do (shen.bindv V3240 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3240 V3437) Result))) false))) (do (shen.unbindv V3238 V3437) Result))) false)))) (if (shen.pvar? V3237) (let A (shen.newpv V3437) (do (shen.bindv V3237 (cons A ()) V3437) (let Result (let V3241 (shen.lazyderef (tl V3229) V3437) (if (= () V3241) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3241) (do (shen.bindv V3241 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3241 V3437) Result))) false))) (do (shen.unbindv V3237 V3437) Result)))) false))) (do (shen.unbindv V3231 V3437) Result))) false))) (if (shen.pvar? V3230) (let A (shen.newpv V3437) (do (shen.bindv V3230 (cons vector (cons A ())) V3437) (let Result (let V3242 (shen.lazyderef (tl V3229) V3437) (if (= () V3242) (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3242) (do (shen.bindv V3242 () V3437) (let Result (let Hyp (tl V3220) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons (shen.lazyderef A V3437) ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons (cons vector (cons (shen.lazyderef A V3437) ())) ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3242 V3437) Result))) false))) (do (shen.unbindv V3230 V3437) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3243 (shen.lazyderef V3435 V3437) (if (cons? V3243) (let V3244 (shen.lazyderef (hd V3243) V3437) (if (cons? V3244) (let V3245 (shen.lazyderef (hd V3244) V3437) (if (cons? V3245) (let V3246 (shen.lazyderef (hd V3245) V3437) (if (= @s V3246) (let V3247 (shen.lazyderef (tl V3245) V3437) (if (cons? V3247) (let X (hd V3247) (let V3248 (shen.lazyderef (tl V3247) V3437) (if (cons? V3248) (let Y (hd V3248) (let V3249 (shen.lazyderef (tl V3248) V3437) (if (= () V3249) (let V3250 (shen.lazyderef (tl V3244) V3437) (if (cons? V3250) (let V3251 (shen.lazyderef (hd V3250) V3437) (if (= : V3251) (let V3252 (shen.lazyderef (tl V3250) V3437) (if (cons? V3252) (let V3253 (shen.lazyderef (hd V3252) V3437) (if (= string V3253) (let V3254 (shen.lazyderef (tl V3252) V3437) (if (= () V3254) (let Hyp (tl V3243) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons string ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3254) (do (shen.bindv V3254 () V3437) (let Result (let Hyp (tl V3243) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons string ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3254 V3437) Result))) false))) (if (shen.pvar? V3253) (do (shen.bindv V3253 string V3437) (let Result (let V3255 (shen.lazyderef (tl V3252) V3437) (if (= () V3255) (let Hyp (tl V3243) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons string ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (if (shen.pvar? V3255) (do (shen.bindv V3255 () V3437) (let Result (let Hyp (tl V3243) (do (shen.incinfs) (bind V3436 (cons (cons (shen.lazyderef X V3437) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V3437) (cons : (cons string ()))) (shen.lazyderef Hyp V3437))) V3437 V3438))) (do (shen.unbindv V3255 V3437) Result))) false))) (do (shen.unbindv V3253 V3437) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V3256 (shen.lazyderef V3435 V3437) (if (cons? V3256) (let X (hd V3256) (let Hyp (tl V3256) (let NewHyps (shen.newpv V3437) (do (shen.incinfs) (bind V3436 (cons (shen.lazyderef X V3437) (shen.lazyderef NewHyps V3437)) V3437 (freeze (shen.t*-hyps Hyp NewHyps V3437 V3438))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V3455 V3456 V3457 V3458) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V3455 V3457)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V3456 V3457) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V3458))))))))) (true (thaw V3458))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V3460) (cond ((and (cons? V3460) (and (cons? (tl V3460)) (and (= : (hd (tl V3460))) (and (cons? (tl (tl V3460))) (= () (tl (tl (tl V3460)))))))) (shen.prhush (shen.app (hd V3460) (cn " : " (shen.app (hd (tl (tl V3460))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V3460 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V3465 V3466) (cond ((= () V3465) shen.skip) ((cons? V3465) (do (shen.prhush (shen.app V3466 ". " shen.a) (stoutput)) (do (shen.show-p (hd V3465)) (do (nl 1) (shen.show-assumptions (tl V3465) (+ V3466 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V3468) (cons? (assoc V3468 (value shen.*signedfuncs*))))

(defun shen.sigf (V3470) (concat shen.type-signature-of- V3470))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V3475 V3476 V3477 V3478) (let Case (let V3159 (shen.lazyderef V3476 V3477) (if (= number V3159) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3475 V3477)) V3477 V3478)) (if (shen.pvar? V3159) (do (shen.bindv V3159 number V3477) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V3475 V3477)) V3477 V3478)) (do (shen.unbindv V3159 V3477) Result))) false))) (if (= Case false) (let Case (let V3160 (shen.lazyderef V3476 V3477) (if (= boolean V3160) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3475 V3477)) V3477 V3478)) (if (shen.pvar? V3160) (do (shen.bindv V3160 boolean V3477) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V3475 V3477)) V3477 V3478)) (do (shen.unbindv V3160 V3477) Result))) false))) (if (= Case false) (let Case (let V3161 (shen.lazyderef V3476 V3477) (if (= string V3161) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3475 V3477)) V3477 V3478)) (if (shen.pvar? V3161) (do (shen.bindv V3161 string V3477) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V3475 V3477)) V3477 V3478)) (do (shen.unbindv V3161 V3477) Result))) false))) (if (= Case false) (let Case (let V3162 (shen.lazyderef V3476 V3477) (if (= symbol V3162) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3475 V3477)) V3477 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3475 V3477))) V3477 V3478)))) (if (shen.pvar? V3162) (do (shen.bindv V3162 symbol V3477) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V3475 V3477)) V3477 (freeze (fwhen (not (shen.ue? (shen.lazyderef V3475 V3477))) V3477 V3478)))) (do (shen.unbindv V3162 V3477) Result))) false))) (if (= Case false) (let V3163 (shen.lazyderef V3475 V3477) (if (= () V3163) (let V3164 (shen.lazyderef V3476 V3477) (if (cons? V3164) (let V3165 (shen.lazyderef (hd V3164) V3477) (if (= list V3165) (let V3166 (shen.lazyderef (tl V3164) V3477) (if (cons? V3166) (let A (hd V3166) (let V3167 (shen.lazyderef (tl V3166) V3477) (if (= () V3167) (do (shen.incinfs) (thaw V3478)) (if (shen.pvar? V3167) (do (shen.bindv V3167 () V3477) (let Result (do (shen.incinfs) (thaw V3478)) (do (shen.unbindv V3167 V3477) Result))) false)))) (if (shen.pvar? V3166) (let A (shen.newpv V3477) (do (shen.bindv V3166 (cons A ()) V3477) (let Result (do (shen.incinfs) (thaw V3478)) (do (shen.unbindv V3166 V3477) Result)))) false))) (if (shen.pvar? V3165) (do (shen.bindv V3165 list V3477) (let Result (let V3168 (shen.lazyderef (tl V3164) V3477) (if (cons? V3168) (let A (hd V3168) (let V3169 (shen.lazyderef (tl V3168) V3477) (if (= () V3169) (do (shen.incinfs) (thaw V3478)) (if (shen.pvar? V3169) (do (shen.bindv V3169 () V3477) (let Result (do (shen.incinfs) (thaw V3478)) (do (shen.unbindv V3169 V3477) Result))) false)))) (if (shen.pvar? V3168) (let A (shen.newpv V3477) (do (shen.bindv V3168 (cons A ()) V3477) (let Result (do (shen.incinfs) (thaw V3478)) (do (shen.unbindv V3168 V3477) Result)))) false))) (do (shen.unbindv V3165 V3477) Result))) false))) (if (shen.pvar? V3164) (let A (shen.newpv V3477) (do (shen.bindv V3164 (cons list (cons A ())) V3477) (let Result (do (shen.incinfs) (thaw V3478)) (do (shen.unbindv V3164 V3477) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V3484 V3485 V3486 V3487 V3488) (let Case (let V3150 (shen.lazyderef V3486 V3487) (if (cons? V3150) (let V3151 (shen.lazyderef (hd V3150) V3487) (if (cons? V3151) (let Y (hd V3151) (let V3152 (shen.lazyderef (tl V3151) V3487) (if (cons? V3152) (let V3153 (shen.lazyderef (hd V3152) V3487) (if (= : V3153) (let V3154 (shen.lazyderef (tl V3152) V3487) (if (cons? V3154) (let B (hd V3154) (let V3155 (shen.lazyderef (tl V3154) V3487) (if (= () V3155) (do (shen.incinfs) (identical V3484 Y V3487 (freeze (unify! V3485 B V3487 V3488)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V3156 (shen.lazyderef V3486 V3487) (if (cons? V3156) (let Hyp (tl V3156) (do (shen.incinfs) (shen.by_hypothesis V3484 V3485 Hyp V3487 V3488))) false)) Case)))

(defun shen.t*-def (V3494 V3495 V3496 V3497 V3498) (let V3144 (shen.lazyderef V3494 V3497) (if (cons? V3144) (let V3145 (shen.lazyderef (hd V3144) V3497) (if (= define V3145) (let V3146 (shen.lazyderef (tl V3144) V3497) (if (cons? V3146) (let F (hd V3146) (let X (tl V3146) (let Y (shen.newpv V3497) (let E (shen.newpv V3497) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V3495 V3496 V3497 V3498)))))) false)) false)) false)))

(defun shen.t*-defh (V3505 V3506 V3507 V3508 V3509 V3510) (let V3140 (shen.lazyderef V3505 V3509) (if (cons? V3140) (let Sig (hd V3140) (let Rules (tl V3140) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V3506 V3507 V3508 Rules V3509 V3510)))) false)))

(defun shen.t*-defhh (V3519 V3520 V3521 V3522 V3523 V3524 V3525 V3526) (do (shen.incinfs) (shen.t*-rules V3524 V3520 1 V3521 (cons (cons V3521 (cons : (cons V3520 ()))) V3523) V3525 (freeze (shen.memo V3521 V3519 V3522 V3525 V3526)))))

(defun shen.memo (V3532 V3533 V3534 V3535 V3536) (let Jnk (shen.newpv V3535) (do (shen.incinfs) (unify! V3534 V3533 V3535 (freeze (bind Jnk (declare (shen.lazyderef V3532 V3535) (shen.lazyderef V3534 V3535)) V3535 V3536))))))

(defun shen.<sig+rules> (V3538) (let Parse_shen.<signature> (shen.<signature> V3538) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V3540) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V3540) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V3540) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V3542) (cond ((and (cons? V3542) (and (cons? (tl V3542)) (and (= () (tl (tl V3542))) (= (hd V3542) protect)))) V3542) ((cons? V3542) (map (lambda Z (shen.ue Z)) V3542)) ((variable? V3542) (concat && V3542)) (true V3542)))

(defun shen.ue-sig (V3544) (cond ((cons? V3544) (map (lambda Z (shen.ue-sig Z)) V3544)) ((variable? V3544) (concat &&& V3544)) (true V3544)))

(defun shen.ues (V3550) (cond ((shen.ue? V3550) (cons V3550 ())) ((cons? V3550) (union (shen.ues (hd V3550)) (shen.ues (tl V3550)))) (true ())))

(defun shen.ue? (V3552) (and (symbol? V3552) (shen.ue-h? (str V3552))))

(defun shen.ue-h? (V3560) (cond ((and (shen.+string? V3560) (and (= "&" (pos V3560 0)) (and (shen.+string? (tlstr V3560)) (= "&" (pos (tlstr V3560) 0))))) true) (true false)))

(defun shen.t*-rules (V3568 V3569 V3570 V3571 V3572 V3573 V3574) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3124 (shen.lazyderef V3568 V3573) (if (= () V3124) (do (shen.incinfs) (thaw V3574)) false)) (if (= Case false) (let Case (let V3125 (shen.lazyderef V3568 V3573) (if (cons? V3125) (let Rule (hd V3125) (let Rules (tl V3125) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V3569 V3572 V3573 (freeze (cut Throwcontrol V3573 (freeze (shen.t*-rules Rules V3569 (+ V3570 1) V3571 V3572 V3573 V3574)))))))) false)) (if (= Case false) (let Err (shen.newpv V3573) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3570 V3573) (cn " of " (shen.app (shen.lazyderef V3571 V3573) "" shen.a)) shen.a))) V3573 V3574))) Case)) Case)))))

(defun shen.t*-rule (V3580 V3581 V3582 V3583 V3584) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V3116 (shen.lazyderef V3580 V3583) (if (cons? V3116) (let Patterns (hd V3116) (let V3117 (shen.lazyderef (tl V3116) V3583) (if (cons? V3117) (let Action (hd V3117) (let V3118 (shen.lazyderef (tl V3117) V3583) (if (= () V3118) (let NewHyps (shen.newpv V3583) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V3582 NewHyps V3583 (freeze (shen.t*-patterns Patterns V3581 NewHyps V3583 (freeze (cut Throwcontrol V3583 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V3581) (shen.patthyps Patterns V3581 V3582) V3583 V3584))))))))) false))) false))) false)))))

(defun shen.placeholders (V3590) (cond ((shen.ue? V3590) (cons V3590 ())) ((cons? V3590) (union (shen.placeholders (hd V3590)) (shen.placeholders (tl V3590)))) (true ())))

(defun shen.newhyps (V3596 V3597 V3598 V3599 V3600) (let Case (let V3103 (shen.lazyderef V3596 V3599) (if (= () V3103) (do (shen.incinfs) (unify! V3598 V3597 V3599 V3600)) false)) (if (= Case false) (let V3104 (shen.lazyderef V3596 V3599) (if (cons? V3104) (let V3099 (hd V3104) (let Vs (tl V3104) (let V3105 (shen.lazyderef V3598 V3599) (if (cons? V3105) (let V3106 (shen.lazyderef (hd V3105) V3599) (if (cons? V3106) (let V (hd V3106) (let V3107 (shen.lazyderef (tl V3106) V3599) (if (cons? V3107) (let V3108 (shen.lazyderef (hd V3107) V3599) (if (= : V3108) (let V3109 (shen.lazyderef (tl V3107) V3599) (if (cons? V3109) (let A (hd V3109) (let V3110 (shen.lazyderef (tl V3109) V3599) (if (= () V3110) (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (if (shen.pvar? V3110) (do (shen.bindv V3110 () V3599) (let Result (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (do (shen.unbindv V3110 V3599) Result))) false)))) (if (shen.pvar? V3109) (let A (shen.newpv V3599) (do (shen.bindv V3109 (cons A ()) V3599) (let Result (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (do (shen.unbindv V3109 V3599) Result)))) false))) (if (shen.pvar? V3108) (do (shen.bindv V3108 : V3599) (let Result (let V3111 (shen.lazyderef (tl V3107) V3599) (if (cons? V3111) (let A (hd V3111) (let V3112 (shen.lazyderef (tl V3111) V3599) (if (= () V3112) (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (if (shen.pvar? V3112) (do (shen.bindv V3112 () V3599) (let Result (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (do (shen.unbindv V3112 V3599) Result))) false)))) (if (shen.pvar? V3111) (let A (shen.newpv V3599) (do (shen.bindv V3111 (cons A ()) V3599) (let Result (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (do (shen.unbindv V3111 V3599) Result)))) false))) (do (shen.unbindv V3108 V3599) Result))) false))) (if (shen.pvar? V3107) (let A (shen.newpv V3599) (do (shen.bindv V3107 (cons : (cons A ())) V3599) (let Result (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (do (shen.unbindv V3107 V3599) Result)))) false)))) (if (shen.pvar? V3106) (let V (shen.newpv V3599) (let A (shen.newpv V3599) (do (shen.bindv V3106 (cons V (cons : (cons A ()))) V3599) (let Result (let NewHyp (tl V3105) (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600))))) (do (shen.unbindv V3106 V3599) Result))))) false))) (if (shen.pvar? V3105) (let V (shen.newpv V3599) (let A (shen.newpv V3599) (let NewHyp (shen.newpv V3599) (do (shen.bindv V3105 (cons (cons V (cons : (cons A ()))) NewHyp) V3599) (let Result (do (shen.incinfs) (unify! V V3099 V3599 (freeze (shen.newhyps Vs V3597 NewHyp V3599 V3600)))) (do (shen.unbindv V3105 V3599) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V3606 V3607 V3608) (cond ((= () V3606) V3608) ((and (cons? V3606) (and (cons? V3607) (and (cons? (tl V3607)) (and (= --> (hd (tl V3607))) (and (cons? (tl (tl V3607))) (= () (tl (tl (tl V3607))))))))) (adjoin (cons (hd V3606) (cons : (cons (hd V3607) ()))) (shen.patthyps (tl V3606) (hd (tl (tl V3607))) V3608))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V3615 V3616) (cond ((and (= () V3615) (and (cons? V3616) (and (= --> (hd V3616)) (and (cons? (tl V3616)) (= () (tl (tl V3616))))))) (hd (tl V3616))) ((= () V3615) V3616) ((and (cons? V3615) (and (cons? V3616) (and (cons? (tl V3616)) (and (= --> (hd (tl V3616))) (and (cons? (tl (tl V3616))) (= () (tl (tl (tl V3616))))))))) (shen.result-type (tl V3615) (hd (tl (tl V3616))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V3622 V3623 V3624 V3625 V3626) (let Case (let V3091 (shen.lazyderef V3622 V3625) (if (= () V3091) (do (shen.incinfs) (thaw V3626)) false)) (if (= Case false) (let V3092 (shen.lazyderef V3622 V3625) (if (cons? V3092) (let Pattern (hd V3092) (let Patterns (tl V3092) (let V3093 (shen.lazyderef V3623 V3625) (if (cons? V3093) (let A (hd V3093) (let V3094 (shen.lazyderef (tl V3093) V3625) (if (cons? V3094) (let V3095 (shen.lazyderef (hd V3094) V3625) (if (= --> V3095) (let V3096 (shen.lazyderef (tl V3094) V3625) (if (cons? V3096) (let B (hd V3096) (let V3097 (shen.lazyderef (tl V3096) V3625) (if (= () V3097) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V3624 V3625 (freeze (shen.t*-patterns Patterns B V3624 V3625 V3626)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V3632 V3633 V3634 V3635 V3636) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V3068 (shen.lazyderef V3632 V3635) (if (cons? V3068) (let V3069 (shen.lazyderef (hd V3068) V3635) (if (= where V3069) (let V3070 (shen.lazyderef (tl V3068) V3635) (if (cons? V3070) (let P (hd V3070) (let V3071 (shen.lazyderef (tl V3070) V3635) (if (cons? V3071) (let Action (hd V3071) (let V3072 (shen.lazyderef (tl V3071) V3635) (if (= () V3072) (do (shen.incinfs) (cut Throwcontrol V3635 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V3634 V3635 (freeze (cut Throwcontrol V3635 (freeze (shen.t*-action Action V3633 (cons (cons P (cons : (cons verified ()))) V3634) V3635 V3636)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V3073 (shen.lazyderef V3632 V3635) (if (cons? V3073) (let V3074 (shen.lazyderef (hd V3073) V3635) (if (= shen.choicepoint! V3074) (let V3075 (shen.lazyderef (tl V3073) V3635) (if (cons? V3075) (let V3076 (shen.lazyderef (hd V3075) V3635) (if (cons? V3076) (let V3077 (shen.lazyderef (hd V3076) V3635) (if (cons? V3077) (let V3078 (shen.lazyderef (hd V3077) V3635) (if (= fail-if V3078) (let V3079 (shen.lazyderef (tl V3077) V3635) (if (cons? V3079) (let F (hd V3079) (let V3080 (shen.lazyderef (tl V3079) V3635) (if (= () V3080) (let V3081 (shen.lazyderef (tl V3076) V3635) (if (cons? V3081) (let Action (hd V3081) (let V3082 (shen.lazyderef (tl V3081) V3635) (if (= () V3082) (let V3083 (shen.lazyderef (tl V3075) V3635) (if (= () V3083) (do (shen.incinfs) (cut Throwcontrol V3635 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V3633 V3634 V3635 V3636)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V3084 (shen.lazyderef V3632 V3635) (if (cons? V3084) (let V3085 (shen.lazyderef (hd V3084) V3635) (if (= shen.choicepoint! V3085) (let V3086 (shen.lazyderef (tl V3084) V3635) (if (cons? V3086) (let Action (hd V3086) (let V3087 (shen.lazyderef (tl V3086) V3635) (if (= () V3087) (do (shen.incinfs) (cut Throwcontrol V3635 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V3633 V3634 V3635 V3636)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V3632 (cons : (cons V3633 ()))) V3634 V3635 V3636)) Case)) Case)) Case)))))

(defun findall (V3642 V3643 V3644 V3645 V3646) (let B (shen.newpv V3645) (let A (shen.newpv V3645) (do (shen.incinfs) (bind A (gensym shen.a) V3645 (freeze (bind B (set (shen.lazyderef A V3645) ()) V3645 (freeze (shen.findallhelp V3642 V3643 V3644 A V3645 V3646)))))))))

(defun shen.findallhelp (V3653 V3654 V3655 V3656 V3657 V3658) (let Case (do (shen.incinfs) (call V3654 V3657 (freeze (shen.remember V3656 V3653 V3657 (freeze (fwhen false V3657 V3658)))))) (if (= Case false) (do (shen.incinfs) (bind V3655 (value (shen.lazyderef V3656 V3657)) V3657 V3658)) Case)))

(defun shen.remember (V3663 V3664 V3665 V3666) (let B (shen.newpv V3665) (do (shen.incinfs) (bind B (set (shen.deref V3663 V3665) (cons (shen.deref V3664 V3665) (value (shen.deref V3663 V3665)))) V3665 V3666))))



