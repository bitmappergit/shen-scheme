"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V2069 V2070) (let Curry (shen.curry V2069) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2070)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2071) (cond ((and (cons? V2071) (shen.special? (hd V2071))) (cons (hd V2071) (map (lambda V1746 (shen.curry V1746)) (tl V2071)))) ((and (cons? V2071) (and (cons? (tl V2071)) (shen.extraspecial? (hd V2071)))) V2071) ((and (cons? V2071) (and (= type (hd V2071)) (and (cons? (tl V2071)) (and (cons? (tl (tl V2071))) (= () (tl (tl (tl V2071)))))))) (cons type (cons (shen.curry (hd (tl V2071))) (tl (tl V2071))))) ((and (cons? V2071) (and (cons? (tl V2071)) (cons? (tl (tl V2071))))) (shen.curry (cons (cons (hd V2071) (cons (hd (tl V2071)) ())) (tl (tl V2071))))) ((and (cons? V2071) (and (cons? (tl V2071)) (= () (tl (tl V2071))))) (cons (shen.curry (hd V2071)) (cons (shen.curry (hd (tl V2071))) ()))) (true V2071)))

(defun shen.special? (V2072) (element? V2072 (value shen.*special*)))

(defun shen.extraspecial? (V2073) (element? V2073 (value shen.*extraspecial*)))

(defun shen.t* (V2074 V2075 V2076 V2077) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2076) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2076 (freeze (bind Error (shen.errormaxinfs) V2076 V2077))))) (if (= Case false) (let Case (let V2063 (shen.lazyderef V2074 V2076) (if (= fail V2063) (do (shen.incinfs) (cut Throwcontrol V2076 (freeze (shen.prolog-failure V2076 V2077)))) false)) (if (= Case false) (let Case (let V2064 (shen.lazyderef V2074 V2076) (if (cons? V2064) (let X (hd V2064) (let V2065 (shen.lazyderef (tl V2064) V2076) (if (cons? V2065) (let V2066 (shen.lazyderef (hd V2065) V2076) (if (= : V2066) (let V2067 (shen.lazyderef (tl V2065) V2076) (if (cons? V2067) (let A (hd V2067) (let V2068 (shen.lazyderef (tl V2067) V2076) (if (= () V2068) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2076 (freeze (cut Throwcontrol V2076 (freeze (shen.th* X A V2075 V2076 V2077)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2076) (do (shen.incinfs) (shen.show V2074 V2075 V2076 (freeze (bind Datatypes (value shen.*datatypes*) V2076 (freeze (shen.udefs* V2074 V2075 Datatypes V2076 V2077))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2082) (cond ((= + V2082) (set shen.*shen-type-theory-enabled?* true)) ((= - V2082) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2091 V2092) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2093 V2094 V2095 V2096 V2097) (let Case (let V2059 (shen.lazyderef V2095 V2096) (if (cons? V2059) (let D (hd V2059) (do (shen.incinfs) (call (cons D (cons V2093 (cons V2094 ()))) V2096 V2097))) false)) (if (= Case false) (let V2060 (shen.lazyderef V2095 V2096) (if (cons? V2060) (let Ds (tl V2060) (do (shen.incinfs) (shen.udefs* V2093 V2094 Ds V2096 V2097))) false)) Case)))

(defun shen.th* (V2098 V2099 V2100 V2101 V2102) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2098 (cons : (cons V2099 ()))) V2100 V2101 (freeze (fwhen false V2101 V2102)))) (if (= Case false) (let Case (let F (shen.newpv V2101) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2098 V2101)) V2101 (freeze (bind F (shen.sigf (shen.lazyderef V2098 V2101)) V2101 (freeze (call (cons F (cons V2099 ())) V2101 V2102))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2098 V2099 V2101 V2102)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2098 V2099 V2100 V2101 V2102)) (if (= Case false) (let Case (let V1955 (shen.lazyderef V2098 V2101) (if (cons? V1955) (let F (hd V1955) (let V1956 (shen.lazyderef (tl V1955) V2101) (if (= () V1956) (do (shen.incinfs) (shen.th* F (cons --> (cons V2099 ())) V2100 V2101 V2102)) false))) false)) (if (= Case false) (let Case (let V1957 (shen.lazyderef V2098 V2101) (if (cons? V1957) (let F (hd V1957) (let V1958 (shen.lazyderef (tl V1957) V2101) (if (cons? V1958) (let X (hd V1958) (let V1959 (shen.lazyderef (tl V1958) V2101) (if (= () V1959) (let B (shen.newpv V2101) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2099 ()))) V2100 V2101 (freeze (shen.th* X B V2100 V2101 V2102))))) false))) false))) false)) (if (= Case false) (let Case (let V1960 (shen.lazyderef V2098 V2101) (if (cons? V1960) (let V1961 (shen.lazyderef (hd V1960) V2101) (if (= cons V1961) (let V1962 (shen.lazyderef (tl V1960) V2101) (if (cons? V1962) (let X (hd V1962) (let V1963 (shen.lazyderef (tl V1962) V2101) (if (cons? V1963) (let Y (hd V1963) (let V1964 (shen.lazyderef (tl V1963) V2101) (if (= () V1964) (let V1965 (shen.lazyderef V2099 V2101) (if (cons? V1965) (let V1966 (shen.lazyderef (hd V1965) V2101) (if (= list V1966) (let V1967 (shen.lazyderef (tl V1965) V2101) (if (cons? V1967) (let A (hd V1967) (let V1968 (shen.lazyderef (tl V1967) V2101) (if (= () V1968) (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (if (shen.pvar? V1968) (do (shen.bindv V1968 () V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1968 V2101) Result))) false)))) (if (shen.pvar? V1967) (let A (shen.newpv V2101) (do (shen.bindv V1967 (cons A ()) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1967 V2101) Result)))) false))) (if (shen.pvar? V1966) (do (shen.bindv V1966 list V2101) (let Result (let V1969 (shen.lazyderef (tl V1965) V2101) (if (cons? V1969) (let A (hd V1969) (let V1970 (shen.lazyderef (tl V1969) V2101) (if (= () V1970) (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (if (shen.pvar? V1970) (do (shen.bindv V1970 () V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1970 V2101) Result))) false)))) (if (shen.pvar? V1969) (let A (shen.newpv V2101) (do (shen.bindv V1969 (cons A ()) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1969 V2101) Result)))) false))) (do (shen.unbindv V1966 V2101) Result))) false))) (if (shen.pvar? V1965) (let A (shen.newpv V2101) (do (shen.bindv V1965 (cons list (cons A ())) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons list (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1965 V2101) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1971 (shen.lazyderef V2098 V2101) (if (cons? V1971) (let V1972 (shen.lazyderef (hd V1971) V2101) (if (= @p V1972) (let V1973 (shen.lazyderef (tl V1971) V2101) (if (cons? V1973) (let X (hd V1973) (let V1974 (shen.lazyderef (tl V1973) V2101) (if (cons? V1974) (let Y (hd V1974) (let V1975 (shen.lazyderef (tl V1974) V2101) (if (= () V1975) (let V1976 (shen.lazyderef V2099 V2101) (if (cons? V1976) (let A (hd V1976) (let V1977 (shen.lazyderef (tl V1976) V2101) (if (cons? V1977) (let V1978 (shen.lazyderef (hd V1977) V2101) (if (= * V1978) (let V1979 (shen.lazyderef (tl V1977) V2101) (if (cons? V1979) (let B (hd V1979) (let V1980 (shen.lazyderef (tl V1979) V2101) (if (= () V1980) (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (if (shen.pvar? V1980) (do (shen.bindv V1980 () V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (do (shen.unbindv V1980 V2101) Result))) false)))) (if (shen.pvar? V1979) (let B (shen.newpv V2101) (do (shen.bindv V1979 (cons B ()) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (do (shen.unbindv V1979 V2101) Result)))) false))) (if (shen.pvar? V1978) (do (shen.bindv V1978 * V2101) (let Result (let V1981 (shen.lazyderef (tl V1977) V2101) (if (cons? V1981) (let B (hd V1981) (let V1982 (shen.lazyderef (tl V1981) V2101) (if (= () V1982) (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (if (shen.pvar? V1982) (do (shen.bindv V1982 () V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (do (shen.unbindv V1982 V2101) Result))) false)))) (if (shen.pvar? V1981) (let B (shen.newpv V2101) (do (shen.bindv V1981 (cons B ()) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (do (shen.unbindv V1981 V2101) Result)))) false))) (do (shen.unbindv V1978 V2101) Result))) false))) (if (shen.pvar? V1977) (let B (shen.newpv V2101) (do (shen.bindv V1977 (cons * (cons B ())) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (do (shen.unbindv V1977 V2101) Result)))) false)))) (if (shen.pvar? V1976) (let A (shen.newpv V2101) (let B (shen.newpv V2101) (do (shen.bindv V1976 (cons A (cons * (cons B ()))) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y B V2100 V2101 V2102)))) (do (shen.unbindv V1976 V2101) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1983 (shen.lazyderef V2098 V2101) (if (cons? V1983) (let V1984 (shen.lazyderef (hd V1983) V2101) (if (= @v V1984) (let V1985 (shen.lazyderef (tl V1983) V2101) (if (cons? V1985) (let X (hd V1985) (let V1986 (shen.lazyderef (tl V1985) V2101) (if (cons? V1986) (let Y (hd V1986) (let V1987 (shen.lazyderef (tl V1986) V2101) (if (= () V1987) (let V1988 (shen.lazyderef V2099 V2101) (if (cons? V1988) (let V1989 (shen.lazyderef (hd V1988) V2101) (if (= vector V1989) (let V1990 (shen.lazyderef (tl V1988) V2101) (if (cons? V1990) (let A (hd V1990) (let V1991 (shen.lazyderef (tl V1990) V2101) (if (= () V1991) (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (if (shen.pvar? V1991) (do (shen.bindv V1991 () V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1991 V2101) Result))) false)))) (if (shen.pvar? V1990) (let A (shen.newpv V2101) (do (shen.bindv V1990 (cons A ()) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1990 V2101) Result)))) false))) (if (shen.pvar? V1989) (do (shen.bindv V1989 vector V2101) (let Result (let V1992 (shen.lazyderef (tl V1988) V2101) (if (cons? V1992) (let A (hd V1992) (let V1993 (shen.lazyderef (tl V1992) V2101) (if (= () V1993) (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (if (shen.pvar? V1993) (do (shen.bindv V1993 () V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1993 V2101) Result))) false)))) (if (shen.pvar? V1992) (let A (shen.newpv V2101) (do (shen.bindv V1992 (cons A ()) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1992 V2101) Result)))) false))) (do (shen.unbindv V1989 V2101) Result))) false))) (if (shen.pvar? V1988) (let A (shen.newpv V2101) (do (shen.bindv V1988 (cons vector (cons A ())) V2101) (let Result (do (shen.incinfs) (shen.th* X A V2100 V2101 (freeze (shen.th* Y (cons vector (cons A ())) V2100 V2101 V2102)))) (do (shen.unbindv V1988 V2101) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1994 (shen.lazyderef V2098 V2101) (if (cons? V1994) (let V1995 (shen.lazyderef (hd V1994) V2101) (if (= @s V1995) (let V1996 (shen.lazyderef (tl V1994) V2101) (if (cons? V1996) (let X (hd V1996) (let V1997 (shen.lazyderef (tl V1996) V2101) (if (cons? V1997) (let Y (hd V1997) (let V1998 (shen.lazyderef (tl V1997) V2101) (if (= () V1998) (let V1999 (shen.lazyderef V2099 V2101) (if (= string V1999) (do (shen.incinfs) (shen.th* X string V2100 V2101 (freeze (shen.th* Y string V2100 V2101 V2102)))) (if (shen.pvar? V1999) (do (shen.bindv V1999 string V2101) (let Result (do (shen.incinfs) (shen.th* X string V2100 V2101 (freeze (shen.th* Y string V2100 V2101 V2102)))) (do (shen.unbindv V1999 V2101) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2000 (shen.lazyderef V2098 V2101) (if (cons? V2000) (let V2001 (shen.lazyderef (hd V2000) V2101) (if (= lambda V2001) (let V2002 (shen.lazyderef (tl V2000) V2101) (if (cons? V2002) (let X (hd V2002) (let V2003 (shen.lazyderef (tl V2002) V2101) (if (cons? V2003) (let Y (hd V2003) (let V2004 (shen.lazyderef (tl V2003) V2101) (if (= () V2004) (let V2005 (shen.lazyderef V2099 V2101) (if (cons? V2005) (let A (hd V2005) (let V2006 (shen.lazyderef (tl V2005) V2101) (if (cons? V2006) (let V2007 (shen.lazyderef (hd V2006) V2101) (if (= --> V2007) (let V2008 (shen.lazyderef (tl V2006) V2101) (if (cons? V2008) (let B (hd V2008) (let V2009 (shen.lazyderef (tl V2008) V2101) (if (= () V2009) (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (if (shen.pvar? V2009) (do (shen.bindv V2009 () V2101) (let Result (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (do (shen.unbindv V2009 V2101) Result))) false)))) (if (shen.pvar? V2008) (let B (shen.newpv V2101) (do (shen.bindv V2008 (cons B ()) V2101) (let Result (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (do (shen.unbindv V2008 V2101) Result)))) false))) (if (shen.pvar? V2007) (do (shen.bindv V2007 --> V2101) (let Result (let V2010 (shen.lazyderef (tl V2006) V2101) (if (cons? V2010) (let B (hd V2010) (let V2011 (shen.lazyderef (tl V2010) V2101) (if (= () V2011) (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (if (shen.pvar? V2011) (do (shen.bindv V2011 () V2101) (let Result (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (do (shen.unbindv V2011 V2101) Result))) false)))) (if (shen.pvar? V2010) (let B (shen.newpv V2101) (do (shen.bindv V2010 (cons B ()) V2101) (let Result (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (do (shen.unbindv V2010 V2101) Result)))) false))) (do (shen.unbindv V2007 V2101) Result))) false))) (if (shen.pvar? V2006) (let B (shen.newpv V2101) (do (shen.bindv V2006 (cons --> (cons B ())) V2101) (let Result (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (do (shen.unbindv V2006 V2101) Result)))) false)))) (if (shen.pvar? V2005) (let A (shen.newpv V2101) (let B (shen.newpv V2101) (do (shen.bindv V2005 (cons A (cons --> (cons B ()))) V2101) (let Result (let Z (shen.newpv V2101) (let X&& (shen.newpv V2101) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Y V2101)) V2101 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2100) V2101 V2102)))))))))) (do (shen.unbindv V2005 V2101) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2012 (shen.lazyderef V2098 V2101) (if (cons? V2012) (let V2013 (shen.lazyderef (hd V2012) V2101) (if (= let V2013) (let V2014 (shen.lazyderef (tl V2012) V2101) (if (cons? V2014) (let X (hd V2014) (let V2015 (shen.lazyderef (tl V2014) V2101) (if (cons? V2015) (let Y (hd V2015) (let V2016 (shen.lazyderef (tl V2015) V2101) (if (cons? V2016) (let Z (hd V2016) (let V2017 (shen.lazyderef (tl V2016) V2101) (if (= () V2017) (let W (shen.newpv V2101) (let X&& (shen.newpv V2101) (let B (shen.newpv V2101) (do (shen.incinfs) (shen.th* Y B V2100 V2101 (freeze (bind X&& (shen.placeholder) V2101 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2101) (shen.lazyderef X V2101) (shen.lazyderef Z V2101)) V2101 (freeze (shen.th* W V2099 (cons (cons X&& (cons : (cons B ()))) V2100) V2101 V2102))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2018 (shen.lazyderef V2098 V2101) (if (cons? V2018) (let V2019 (shen.lazyderef (hd V2018) V2101) (if (= open V2019) (let V2020 (shen.lazyderef (tl V2018) V2101) (if (cons? V2020) (let FileName (hd V2020) (let V2021 (shen.lazyderef (tl V2020) V2101) (if (cons? V2021) (let Direction1951 (hd V2021) (let V2022 (shen.lazyderef (tl V2021) V2101) (if (= () V2022) (let V2023 (shen.lazyderef V2099 V2101) (if (cons? V2023) (let V2024 (shen.lazyderef (hd V2023) V2101) (if (= stream V2024) (let V2025 (shen.lazyderef (tl V2023) V2101) (if (cons? V2025) (let Direction (hd V2025) (let V2026 (shen.lazyderef (tl V2025) V2101) (if (= () V2026) (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (if (shen.pvar? V2026) (do (shen.bindv V2026 () V2101) (let Result (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (do (shen.unbindv V2026 V2101) Result))) false)))) (if (shen.pvar? V2025) (let Direction (shen.newpv V2101) (do (shen.bindv V2025 (cons Direction ()) V2101) (let Result (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (do (shen.unbindv V2025 V2101) Result)))) false))) (if (shen.pvar? V2024) (do (shen.bindv V2024 stream V2101) (let Result (let V2027 (shen.lazyderef (tl V2023) V2101) (if (cons? V2027) (let Direction (hd V2027) (let V2028 (shen.lazyderef (tl V2027) V2101) (if (= () V2028) (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (if (shen.pvar? V2028) (do (shen.bindv V2028 () V2101) (let Result (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (do (shen.unbindv V2028 V2101) Result))) false)))) (if (shen.pvar? V2027) (let Direction (shen.newpv V2101) (do (shen.bindv V2027 (cons Direction ()) V2101) (let Result (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (do (shen.unbindv V2027 V2101) Result)))) false))) (do (shen.unbindv V2024 V2101) Result))) false))) (if (shen.pvar? V2023) (let Direction (shen.newpv V2101) (do (shen.bindv V2023 (cons stream (cons Direction ())) V2101) (let Result (do (shen.incinfs) (unify! Direction Direction1951 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* FileName string V2100 V2101 V2102)))))) (do (shen.unbindv V2023 V2101) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2029 (shen.lazyderef V2098 V2101) (if (cons? V2029) (let V2030 (shen.lazyderef (hd V2029) V2101) (if (= type V2030) (let V2031 (shen.lazyderef (tl V2029) V2101) (if (cons? V2031) (let X (hd V2031) (let V2032 (shen.lazyderef (tl V2031) V2101) (if (cons? V2032) (let A (hd V2032) (let V2033 (shen.lazyderef (tl V2032) V2101) (if (= () V2033) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (unify A V2099 V2101 (freeze (shen.th* X A V2100 V2101 V2102)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2034 (shen.lazyderef V2098 V2101) (if (cons? V2034) (let V2035 (shen.lazyderef (hd V2034) V2101) (if (= input+ V2035) (let V2036 (shen.lazyderef (tl V2034) V2101) (if (cons? V2036) (let A (hd V2036) (let V2037 (shen.lazyderef (tl V2036) V2101) (if (cons? V2037) (let Stream (hd V2037) (let V2038 (shen.lazyderef (tl V2037) V2101) (if (= () V2038) (let C (shen.newpv V2101) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2101)) V2101 (freeze (unify V2099 C V2101 (freeze (shen.th* Stream (cons stream (cons in ())) V2100 V2101 V2102))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2039 (shen.lazyderef V2098 V2101) (if (cons? V2039) (let V2040 (shen.lazyderef (hd V2039) V2101) (if (= set V2040) (let V2041 (shen.lazyderef (tl V2039) V2101) (if (cons? V2041) (let Var (hd V2041) (let V2042 (shen.lazyderef (tl V2041) V2101) (if (cons? V2042) (let Val (hd V2042) (let V2043 (shen.lazyderef (tl V2042) V2101) (if (= () V2043) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (shen.th* Var symbol V2100 V2101 (freeze (cut Throwcontrol V2101 (freeze (shen.th* (cons value (cons Var ())) V2099 V2100 V2101 (freeze (shen.th* Val V2099 V2100 V2101 V2102)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2101) (do (shen.incinfs) (shen.t*-hyps V2100 NewHyp V2101 (freeze (shen.th* V2098 V2099 NewHyp V2101 V2102))))) (if (= Case false) (let Case (let V2044 (shen.lazyderef V2098 V2101) (if (cons? V2044) (let V2045 (shen.lazyderef (hd V2044) V2101) (if (= define V2045) (let V2046 (shen.lazyderef (tl V2044) V2101) (if (cons? V2046) (let F (hd V2046) (let X (tl V2046) (do (shen.incinfs) (cut Throwcontrol V2101 (freeze (shen.t*-def (cons define (cons F X)) V2099 V2100 V2101 V2102)))))) false)) false)) false)) (if (= Case false) (let Case (let V2047 (shen.lazyderef V2098 V2101) (if (cons? V2047) (let V2048 (shen.lazyderef (hd V2047) V2101) (if (= defmacro V2048) (let V2049 (shen.lazyderef V2099 V2101) (if (= unit V2049) (do (shen.incinfs) (cut Throwcontrol V2101 V2102)) (if (shen.pvar? V2049) (do (shen.bindv V2049 unit V2101) (let Result (do (shen.incinfs) (cut Throwcontrol V2101 V2102)) (do (shen.unbindv V2049 V2101) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2050 (shen.lazyderef V2098 V2101) (if (cons? V2050) (let V2051 (shen.lazyderef (hd V2050) V2101) (if (= shen.process-datatype V2051) (let V2052 (shen.lazyderef V2099 V2101) (if (= symbol V2052) (do (shen.incinfs) (thaw V2102)) (if (shen.pvar? V2052) (do (shen.bindv V2052 symbol V2101) (let Result (do (shen.incinfs) (thaw V2102)) (do (shen.unbindv V2052 V2101) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2053 (shen.lazyderef V2098 V2101) (if (cons? V2053) (let V2054 (shen.lazyderef (hd V2053) V2101) (if (= shen.synonyms-help V2054) (let V2055 (shen.lazyderef V2099 V2101) (if (= symbol V2055) (do (shen.incinfs) (thaw V2102)) (if (shen.pvar? V2055) (do (shen.bindv V2055 symbol V2101) (let Result (do (shen.incinfs) (thaw V2102)) (do (shen.unbindv V2055 V2101) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2101) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2101 (freeze (shen.udefs* (cons V2098 (cons : (cons V2099 ()))) V2100 Datatypes V2101 V2102))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2103 V2104 V2105 V2106) (let Case (let V1866 (shen.lazyderef V2103 V2105) (if (cons? V1866) (let V1867 (shen.lazyderef (hd V1866) V2105) (if (cons? V1867) (let V1868 (shen.lazyderef (hd V1867) V2105) (if (cons? V1868) (let V1869 (shen.lazyderef (hd V1868) V2105) (if (= cons V1869) (let V1870 (shen.lazyderef (tl V1868) V2105) (if (cons? V1870) (let X (hd V1870) (let V1871 (shen.lazyderef (tl V1870) V2105) (if (cons? V1871) (let Y (hd V1871) (let V1872 (shen.lazyderef (tl V1871) V2105) (if (= () V1872) (let V1873 (shen.lazyderef (tl V1867) V2105) (if (cons? V1873) (let V1874 (shen.lazyderef (hd V1873) V2105) (if (= : V1874) (let V1875 (shen.lazyderef (tl V1873) V2105) (if (cons? V1875) (let V1876 (shen.lazyderef (hd V1875) V2105) (if (cons? V1876) (let V1877 (shen.lazyderef (hd V1876) V2105) (if (= list V1877) (let V1878 (shen.lazyderef (tl V1876) V2105) (if (cons? V1878) (let A (hd V1878) (let V1879 (shen.lazyderef (tl V1878) V2105) (if (= () V1879) (let V1880 (shen.lazyderef (tl V1875) V2105) (if (= () V1880) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1880) (do (shen.bindv V1880 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1880 V2105) Result))) false))) (if (shen.pvar? V1879) (do (shen.bindv V1879 () V2105) (let Result (let V1881 (shen.lazyderef (tl V1875) V2105) (if (= () V1881) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1881) (do (shen.bindv V1881 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1881 V2105) Result))) false))) (do (shen.unbindv V1879 V2105) Result))) false)))) (if (shen.pvar? V1878) (let A (shen.newpv V2105) (do (shen.bindv V1878 (cons A ()) V2105) (let Result (let V1882 (shen.lazyderef (tl V1875) V2105) (if (= () V1882) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1882) (do (shen.bindv V1882 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1882 V2105) Result))) false))) (do (shen.unbindv V1878 V2105) Result)))) false))) (if (shen.pvar? V1877) (do (shen.bindv V1877 list V2105) (let Result (let V1883 (shen.lazyderef (tl V1876) V2105) (if (cons? V1883) (let A (hd V1883) (let V1884 (shen.lazyderef (tl V1883) V2105) (if (= () V1884) (let V1885 (shen.lazyderef (tl V1875) V2105) (if (= () V1885) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1885) (do (shen.bindv V1885 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1885 V2105) Result))) false))) (if (shen.pvar? V1884) (do (shen.bindv V1884 () V2105) (let Result (let V1886 (shen.lazyderef (tl V1875) V2105) (if (= () V1886) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1886) (do (shen.bindv V1886 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1886 V2105) Result))) false))) (do (shen.unbindv V1884 V2105) Result))) false)))) (if (shen.pvar? V1883) (let A (shen.newpv V2105) (do (shen.bindv V1883 (cons A ()) V2105) (let Result (let V1887 (shen.lazyderef (tl V1875) V2105) (if (= () V1887) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1887) (do (shen.bindv V1887 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1887 V2105) Result))) false))) (do (shen.unbindv V1883 V2105) Result)))) false))) (do (shen.unbindv V1877 V2105) Result))) false))) (if (shen.pvar? V1876) (let A (shen.newpv V2105) (do (shen.bindv V1876 (cons list (cons A ())) V2105) (let Result (let V1888 (shen.lazyderef (tl V1875) V2105) (if (= () V1888) (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1888) (do (shen.bindv V1888 () V2105) (let Result (let Hyp (tl V1866) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons list (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1888 V2105) Result))) false))) (do (shen.unbindv V1876 V2105) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1889 (shen.lazyderef V2103 V2105) (if (cons? V1889) (let V1890 (shen.lazyderef (hd V1889) V2105) (if (cons? V1890) (let V1891 (shen.lazyderef (hd V1890) V2105) (if (cons? V1891) (let V1892 (shen.lazyderef (hd V1891) V2105) (if (= @p V1892) (let V1893 (shen.lazyderef (tl V1891) V2105) (if (cons? V1893) (let X (hd V1893) (let V1894 (shen.lazyderef (tl V1893) V2105) (if (cons? V1894) (let Y (hd V1894) (let V1895 (shen.lazyderef (tl V1894) V2105) (if (= () V1895) (let V1896 (shen.lazyderef (tl V1890) V2105) (if (cons? V1896) (let V1897 (shen.lazyderef (hd V1896) V2105) (if (= : V1897) (let V1898 (shen.lazyderef (tl V1896) V2105) (if (cons? V1898) (let V1899 (shen.lazyderef (hd V1898) V2105) (if (cons? V1899) (let A (hd V1899) (let V1900 (shen.lazyderef (tl V1899) V2105) (if (cons? V1900) (let V1901 (shen.lazyderef (hd V1900) V2105) (if (= * V1901) (let V1902 (shen.lazyderef (tl V1900) V2105) (if (cons? V1902) (let B (hd V1902) (let V1903 (shen.lazyderef (tl V1902) V2105) (if (= () V1903) (let V1904 (shen.lazyderef (tl V1898) V2105) (if (= () V1904) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1904) (do (shen.bindv V1904 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1904 V2105) Result))) false))) (if (shen.pvar? V1903) (do (shen.bindv V1903 () V2105) (let Result (let V1905 (shen.lazyderef (tl V1898) V2105) (if (= () V1905) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1905) (do (shen.bindv V1905 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1905 V2105) Result))) false))) (do (shen.unbindv V1903 V2105) Result))) false)))) (if (shen.pvar? V1902) (let B (shen.newpv V2105) (do (shen.bindv V1902 (cons B ()) V2105) (let Result (let V1906 (shen.lazyderef (tl V1898) V2105) (if (= () V1906) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1906) (do (shen.bindv V1906 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1906 V2105) Result))) false))) (do (shen.unbindv V1902 V2105) Result)))) false))) (if (shen.pvar? V1901) (do (shen.bindv V1901 * V2105) (let Result (let V1907 (shen.lazyderef (tl V1900) V2105) (if (cons? V1907) (let B (hd V1907) (let V1908 (shen.lazyderef (tl V1907) V2105) (if (= () V1908) (let V1909 (shen.lazyderef (tl V1898) V2105) (if (= () V1909) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1909) (do (shen.bindv V1909 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1909 V2105) Result))) false))) (if (shen.pvar? V1908) (do (shen.bindv V1908 () V2105) (let Result (let V1910 (shen.lazyderef (tl V1898) V2105) (if (= () V1910) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1910) (do (shen.bindv V1910 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1910 V2105) Result))) false))) (do (shen.unbindv V1908 V2105) Result))) false)))) (if (shen.pvar? V1907) (let B (shen.newpv V2105) (do (shen.bindv V1907 (cons B ()) V2105) (let Result (let V1911 (shen.lazyderef (tl V1898) V2105) (if (= () V1911) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1911) (do (shen.bindv V1911 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1911 V2105) Result))) false))) (do (shen.unbindv V1907 V2105) Result)))) false))) (do (shen.unbindv V1901 V2105) Result))) false))) (if (shen.pvar? V1900) (let B (shen.newpv V2105) (do (shen.bindv V1900 (cons * (cons B ())) V2105) (let Result (let V1912 (shen.lazyderef (tl V1898) V2105) (if (= () V1912) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1912) (do (shen.bindv V1912 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1912 V2105) Result))) false))) (do (shen.unbindv V1900 V2105) Result)))) false)))) (if (shen.pvar? V1899) (let A (shen.newpv V2105) (let B (shen.newpv V2105) (do (shen.bindv V1899 (cons A (cons * (cons B ()))) V2105) (let Result (let V1913 (shen.lazyderef (tl V1898) V2105) (if (= () V1913) (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1913) (do (shen.bindv V1913 () V2105) (let Result (let Hyp (tl V1889) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (shen.lazyderef B V2105) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1913 V2105) Result))) false))) (do (shen.unbindv V1899 V2105) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1914 (shen.lazyderef V2103 V2105) (if (cons? V1914) (let V1915 (shen.lazyderef (hd V1914) V2105) (if (cons? V1915) (let V1916 (shen.lazyderef (hd V1915) V2105) (if (cons? V1916) (let V1917 (shen.lazyderef (hd V1916) V2105) (if (= @v V1917) (let V1918 (shen.lazyderef (tl V1916) V2105) (if (cons? V1918) (let X (hd V1918) (let V1919 (shen.lazyderef (tl V1918) V2105) (if (cons? V1919) (let Y (hd V1919) (let V1920 (shen.lazyderef (tl V1919) V2105) (if (= () V1920) (let V1921 (shen.lazyderef (tl V1915) V2105) (if (cons? V1921) (let V1922 (shen.lazyderef (hd V1921) V2105) (if (= : V1922) (let V1923 (shen.lazyderef (tl V1921) V2105) (if (cons? V1923) (let V1924 (shen.lazyderef (hd V1923) V2105) (if (cons? V1924) (let V1925 (shen.lazyderef (hd V1924) V2105) (if (= vector V1925) (let V1926 (shen.lazyderef (tl V1924) V2105) (if (cons? V1926) (let A (hd V1926) (let V1927 (shen.lazyderef (tl V1926) V2105) (if (= () V1927) (let V1928 (shen.lazyderef (tl V1923) V2105) (if (= () V1928) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1928) (do (shen.bindv V1928 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1928 V2105) Result))) false))) (if (shen.pvar? V1927) (do (shen.bindv V1927 () V2105) (let Result (let V1929 (shen.lazyderef (tl V1923) V2105) (if (= () V1929) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1929) (do (shen.bindv V1929 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1929 V2105) Result))) false))) (do (shen.unbindv V1927 V2105) Result))) false)))) (if (shen.pvar? V1926) (let A (shen.newpv V2105) (do (shen.bindv V1926 (cons A ()) V2105) (let Result (let V1930 (shen.lazyderef (tl V1923) V2105) (if (= () V1930) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1930) (do (shen.bindv V1930 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1930 V2105) Result))) false))) (do (shen.unbindv V1926 V2105) Result)))) false))) (if (shen.pvar? V1925) (do (shen.bindv V1925 vector V2105) (let Result (let V1931 (shen.lazyderef (tl V1924) V2105) (if (cons? V1931) (let A (hd V1931) (let V1932 (shen.lazyderef (tl V1931) V2105) (if (= () V1932) (let V1933 (shen.lazyderef (tl V1923) V2105) (if (= () V1933) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1933) (do (shen.bindv V1933 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1933 V2105) Result))) false))) (if (shen.pvar? V1932) (do (shen.bindv V1932 () V2105) (let Result (let V1934 (shen.lazyderef (tl V1923) V2105) (if (= () V1934) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1934) (do (shen.bindv V1934 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1934 V2105) Result))) false))) (do (shen.unbindv V1932 V2105) Result))) false)))) (if (shen.pvar? V1931) (let A (shen.newpv V2105) (do (shen.bindv V1931 (cons A ()) V2105) (let Result (let V1935 (shen.lazyderef (tl V1923) V2105) (if (= () V1935) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1935) (do (shen.bindv V1935 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1935 V2105) Result))) false))) (do (shen.unbindv V1931 V2105) Result)))) false))) (do (shen.unbindv V1925 V2105) Result))) false))) (if (shen.pvar? V1924) (let A (shen.newpv V2105) (do (shen.bindv V1924 (cons vector (cons A ())) V2105) (let Result (let V1936 (shen.lazyderef (tl V1923) V2105) (if (= () V1936) (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1936) (do (shen.bindv V1936 () V2105) (let Result (let Hyp (tl V1914) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons (shen.lazyderef A V2105) ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons (cons vector (cons (shen.lazyderef A V2105) ())) ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1936 V2105) Result))) false))) (do (shen.unbindv V1924 V2105) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1937 (shen.lazyderef V2103 V2105) (if (cons? V1937) (let V1938 (shen.lazyderef (hd V1937) V2105) (if (cons? V1938) (let V1939 (shen.lazyderef (hd V1938) V2105) (if (cons? V1939) (let V1940 (shen.lazyderef (hd V1939) V2105) (if (= @s V1940) (let V1941 (shen.lazyderef (tl V1939) V2105) (if (cons? V1941) (let X (hd V1941) (let V1942 (shen.lazyderef (tl V1941) V2105) (if (cons? V1942) (let Y (hd V1942) (let V1943 (shen.lazyderef (tl V1942) V2105) (if (= () V1943) (let V1944 (shen.lazyderef (tl V1938) V2105) (if (cons? V1944) (let V1945 (shen.lazyderef (hd V1944) V2105) (if (= : V1945) (let V1946 (shen.lazyderef (tl V1944) V2105) (if (cons? V1946) (let V1947 (shen.lazyderef (hd V1946) V2105) (if (= string V1947) (let V1948 (shen.lazyderef (tl V1946) V2105) (if (= () V1948) (let Hyp (tl V1937) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons string ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1948) (do (shen.bindv V1948 () V2105) (let Result (let Hyp (tl V1937) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons string ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1948 V2105) Result))) false))) (if (shen.pvar? V1947) (do (shen.bindv V1947 string V2105) (let Result (let V1949 (shen.lazyderef (tl V1946) V2105) (if (= () V1949) (let Hyp (tl V1937) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons string ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (if (shen.pvar? V1949) (do (shen.bindv V1949 () V2105) (let Result (let Hyp (tl V1937) (do (shen.incinfs) (bind V2104 (cons (cons (shen.lazyderef X V2105) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2105) (cons : (cons string ()))) (shen.lazyderef Hyp V2105))) V2105 V2106))) (do (shen.unbindv V1949 V2105) Result))) false))) (do (shen.unbindv V1947 V2105) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V1950 (shen.lazyderef V2103 V2105) (if (cons? V1950) (let X (hd V1950) (let Hyp (tl V1950) (let NewHyps (shen.newpv V2105) (do (shen.incinfs) (bind V2104 (cons (shen.lazyderef X V2105) (shen.lazyderef NewHyps V2105)) V2105 (freeze (shen.t*-hyps Hyp NewHyps V2105 V2106))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2119 V2120 V2121 V2122) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2119 V2121)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2120 V2121) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2122))))))))) (true (thaw V2122))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2123) (cond ((and (cons? V2123) (and (cons? (tl V2123)) (and (= : (hd (tl V2123))) (and (cons? (tl (tl V2123))) (= () (tl (tl (tl V2123)))))))) (shen.prhush (shen.app (hd V2123) (cn " : " (shen.app (hd (tl (tl V2123))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2123 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2126 V2127) (cond ((= () V2126) shen.skip) ((cons? V2126) (do (shen.prhush (shen.app V2127 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2126)) (do (nl 1) (shen.show-assumptions (tl V2126) (+ V2127 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2128) (cons? (assoc V2128 (value shen.*signedfuncs*))))

(defun shen.sigf (V2129) (concat shen.type-signature-of- V2129))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2130 V2131 V2132 V2133) (let Case (let V1853 (shen.lazyderef V2131 V2132) (if (= number V1853) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2130 V2132)) V2132 V2133)) (if (shen.pvar? V1853) (do (shen.bindv V1853 number V2132) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2130 V2132)) V2132 V2133)) (do (shen.unbindv V1853 V2132) Result))) false))) (if (= Case false) (let Case (let V1854 (shen.lazyderef V2131 V2132) (if (= boolean V1854) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2130 V2132)) V2132 V2133)) (if (shen.pvar? V1854) (do (shen.bindv V1854 boolean V2132) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2130 V2132)) V2132 V2133)) (do (shen.unbindv V1854 V2132) Result))) false))) (if (= Case false) (let Case (let V1855 (shen.lazyderef V2131 V2132) (if (= string V1855) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2130 V2132)) V2132 V2133)) (if (shen.pvar? V1855) (do (shen.bindv V1855 string V2132) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2130 V2132)) V2132 V2133)) (do (shen.unbindv V1855 V2132) Result))) false))) (if (= Case false) (let Case (let V1856 (shen.lazyderef V2131 V2132) (if (= symbol V1856) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2130 V2132)) V2132 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2130 V2132))) V2132 V2133)))) (if (shen.pvar? V1856) (do (shen.bindv V1856 symbol V2132) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2130 V2132)) V2132 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2130 V2132))) V2132 V2133)))) (do (shen.unbindv V1856 V2132) Result))) false))) (if (= Case false) (let V1857 (shen.lazyderef V2130 V2132) (if (= () V1857) (let V1858 (shen.lazyderef V2131 V2132) (if (cons? V1858) (let V1859 (shen.lazyderef (hd V1858) V2132) (if (= list V1859) (let V1860 (shen.lazyderef (tl V1858) V2132) (if (cons? V1860) (let A (hd V1860) (let V1861 (shen.lazyderef (tl V1860) V2132) (if (= () V1861) (do (shen.incinfs) (thaw V2133)) (if (shen.pvar? V1861) (do (shen.bindv V1861 () V2132) (let Result (do (shen.incinfs) (thaw V2133)) (do (shen.unbindv V1861 V2132) Result))) false)))) (if (shen.pvar? V1860) (let A (shen.newpv V2132) (do (shen.bindv V1860 (cons A ()) V2132) (let Result (do (shen.incinfs) (thaw V2133)) (do (shen.unbindv V1860 V2132) Result)))) false))) (if (shen.pvar? V1859) (do (shen.bindv V1859 list V2132) (let Result (let V1862 (shen.lazyderef (tl V1858) V2132) (if (cons? V1862) (let A (hd V1862) (let V1863 (shen.lazyderef (tl V1862) V2132) (if (= () V1863) (do (shen.incinfs) (thaw V2133)) (if (shen.pvar? V1863) (do (shen.bindv V1863 () V2132) (let Result (do (shen.incinfs) (thaw V2133)) (do (shen.unbindv V1863 V2132) Result))) false)))) (if (shen.pvar? V1862) (let A (shen.newpv V2132) (do (shen.bindv V1862 (cons A ()) V2132) (let Result (do (shen.incinfs) (thaw V2133)) (do (shen.unbindv V1862 V2132) Result)))) false))) (do (shen.unbindv V1859 V2132) Result))) false))) (if (shen.pvar? V1858) (let A (shen.newpv V2132) (do (shen.bindv V1858 (cons list (cons A ())) V2132) (let Result (do (shen.incinfs) (thaw V2133)) (do (shen.unbindv V1858 V2132) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2134 V2135 V2136 V2137 V2138) (let Case (let V1844 (shen.lazyderef V2136 V2137) (if (cons? V1844) (let V1845 (shen.lazyderef (hd V1844) V2137) (if (cons? V1845) (let Y (hd V1845) (let V1846 (shen.lazyderef (tl V1845) V2137) (if (cons? V1846) (let V1847 (shen.lazyderef (hd V1846) V2137) (if (= : V1847) (let V1848 (shen.lazyderef (tl V1846) V2137) (if (cons? V1848) (let B (hd V1848) (let V1849 (shen.lazyderef (tl V1848) V2137) (if (= () V1849) (do (shen.incinfs) (identical V2134 Y V2137 (freeze (unify! V2135 B V2137 V2138)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V1850 (shen.lazyderef V2136 V2137) (if (cons? V1850) (let Hyp (tl V1850) (do (shen.incinfs) (shen.by_hypothesis V2134 V2135 Hyp V2137 V2138))) false)) Case)))

(defun shen.t*-def (V2139 V2140 V2141 V2142 V2143) (let V1838 (shen.lazyderef V2139 V2142) (if (cons? V1838) (let V1839 (shen.lazyderef (hd V1838) V2142) (if (= define V1839) (let V1840 (shen.lazyderef (tl V1838) V2142) (if (cons? V1840) (let F (hd V1840) (let X (tl V1840) (let V1747 (shen.newpv V2142) (let E (shen.newpv V2142) (do (shen.incinfs) (shen.t*-defh (compile (lambda V1747 (shen.<sig+rules> V1747)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2140 V2141 V2142 V2143)))))) false)) false)) false)))

(defun shen.t*-defh (V2144 V2145 V2146 V2147 V2148 V2149) (let V1834 (shen.lazyderef V2144 V2148) (if (cons? V1834) (let Sig (hd V1834) (let Rules (tl V1834) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2145 V2146 V2147 Rules V2148 V2149)))) false)))

(defun shen.t*-defhh (V2150 V2151 V2152 V2153 V2154 V2155 V2156 V2157) (do (shen.incinfs) (shen.t*-rules V2155 V2151 1 V2152 (cons (cons V2152 (cons : (cons V2151 ()))) V2154) V2156 (freeze (shen.memo V2152 V2150 V2153 V2156 V2157)))))

(defun shen.memo (V2158 V2159 V2160 V2161 V2162) (let Jnk (shen.newpv V2161) (do (shen.incinfs) (unify! V2160 V2159 V2161 (freeze (bind Jnk (declare (shen.lazyderef V2158 V2161) (shen.lazyderef V2160 V2161)) V2161 V2162))))))

(defun shen.<sig+rules> (V2163) (let Parse_shen.<signature> (shen.<signature> V2163) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2164) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2164) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2164) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2165) (cond ((and (cons? V2165) (and (cons? (tl V2165)) (and (= () (tl (tl V2165))) (= (hd V2165) protect)))) V2165) ((cons? V2165) (map (lambda V1748 (shen.ue V1748)) V2165)) ((variable? V2165) (concat && V2165)) (true V2165)))

(defun shen.ue-sig (V2166) (cond ((cons? V2166) (map (lambda V1749 (shen.ue-sig V1749)) V2166)) ((variable? V2166) (concat &&& V2166)) (true V2166)))

(defun shen.ues (V2171) (cond ((shen.ue? V2171) (cons V2171 ())) ((cons? V2171) (union (shen.ues (hd V2171)) (shen.ues (tl V2171)))) (true ())))

(defun shen.ue? (V2172) (and (symbol? V2172) (shen.ue-h? (str V2172))))

(defun shen.ue-h? (V2179) (cond ((and (shen.+string? V2179) (and (= "&" (pos V2179 0)) (and (shen.+string? (tlstr V2179)) (= "&" (pos (tlstr V2179) 0))))) true) (true false)))

(defun shen.t*-rules (V2180 V2181 V2182 V2183 V2184 V2185 V2186) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1818 (shen.lazyderef V2180 V2185) (if (= () V1818) (do (shen.incinfs) (thaw V2186)) false)) (if (= Case false) (let Case (let V1819 (shen.lazyderef V2180 V2185) (if (cons? V1819) (let Rule (hd V1819) (let Rules (tl V1819) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2181 V2184 V2185 (freeze (cut Throwcontrol V2185 (freeze (shen.t*-rules Rules V2181 (+ V2182 1) V2183 V2184 V2185 V2186)))))))) false)) (if (= Case false) (let Err (shen.newpv V2185) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2182 V2185) (cn " of " (shen.app (shen.lazyderef V2183 V2185) "" shen.a)) shen.a))) V2185 V2186))) Case)) Case)))))

(defun shen.t*-rule (V2187 V2188 V2189 V2190 V2191) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V1810 (shen.lazyderef V2187 V2190) (if (cons? V1810) (let Patterns (hd V1810) (let V1811 (shen.lazyderef (tl V1810) V2190) (if (cons? V1811) (let Action (hd V1811) (let V1812 (shen.lazyderef (tl V1811) V2190) (if (= () V1812) (let NewHyps (shen.newpv V2190) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2189 NewHyps V2190 (freeze (shen.t*-patterns Patterns V2188 NewHyps V2190 (freeze (cut Throwcontrol V2190 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2188) (shen.patthyps Patterns V2188 V2189) V2190 V2191))))))))) false))) false))) false)))))

(defun shen.placeholders (V2196) (cond ((shen.ue? V2196) (cons V2196 ())) ((cons? V2196) (union (shen.placeholders (hd V2196)) (shen.placeholders (tl V2196)))) (true ())))

(defun shen.newhyps (V2197 V2198 V2199 V2200 V2201) (let Case (let V1797 (shen.lazyderef V2197 V2200) (if (= () V1797) (do (shen.incinfs) (unify! V2199 V2198 V2200 V2201)) false)) (if (= Case false) (let V1798 (shen.lazyderef V2197 V2200) (if (cons? V1798) (let V1793 (hd V1798) (let Vs (tl V1798) (let V1799 (shen.lazyderef V2199 V2200) (if (cons? V1799) (let V1800 (shen.lazyderef (hd V1799) V2200) (if (cons? V1800) (let V (hd V1800) (let V1801 (shen.lazyderef (tl V1800) V2200) (if (cons? V1801) (let V1802 (shen.lazyderef (hd V1801) V2200) (if (= : V1802) (let V1803 (shen.lazyderef (tl V1801) V2200) (if (cons? V1803) (let A (hd V1803) (let V1804 (shen.lazyderef (tl V1803) V2200) (if (= () V1804) (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (if (shen.pvar? V1804) (do (shen.bindv V1804 () V2200) (let Result (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (do (shen.unbindv V1804 V2200) Result))) false)))) (if (shen.pvar? V1803) (let A (shen.newpv V2200) (do (shen.bindv V1803 (cons A ()) V2200) (let Result (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (do (shen.unbindv V1803 V2200) Result)))) false))) (if (shen.pvar? V1802) (do (shen.bindv V1802 : V2200) (let Result (let V1805 (shen.lazyderef (tl V1801) V2200) (if (cons? V1805) (let A (hd V1805) (let V1806 (shen.lazyderef (tl V1805) V2200) (if (= () V1806) (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (if (shen.pvar? V1806) (do (shen.bindv V1806 () V2200) (let Result (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (do (shen.unbindv V1806 V2200) Result))) false)))) (if (shen.pvar? V1805) (let A (shen.newpv V2200) (do (shen.bindv V1805 (cons A ()) V2200) (let Result (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (do (shen.unbindv V1805 V2200) Result)))) false))) (do (shen.unbindv V1802 V2200) Result))) false))) (if (shen.pvar? V1801) (let A (shen.newpv V2200) (do (shen.bindv V1801 (cons : (cons A ())) V2200) (let Result (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (do (shen.unbindv V1801 V2200) Result)))) false)))) (if (shen.pvar? V1800) (let V (shen.newpv V2200) (let A (shen.newpv V2200) (do (shen.bindv V1800 (cons V (cons : (cons A ()))) V2200) (let Result (let NewHyp (tl V1799) (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201))))) (do (shen.unbindv V1800 V2200) Result))))) false))) (if (shen.pvar? V1799) (let V (shen.newpv V2200) (let A (shen.newpv V2200) (let NewHyp (shen.newpv V2200) (do (shen.bindv V1799 (cons (cons V (cons : (cons A ()))) NewHyp) V2200) (let Result (do (shen.incinfs) (unify! V V1793 V2200 (freeze (shen.newhyps Vs V2198 NewHyp V2200 V2201)))) (do (shen.unbindv V1799 V2200) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2204 V2205 V2206) (cond ((= () V2204) V2206) ((and (cons? V2204) (and (cons? V2205) (and (cons? (tl V2205)) (and (= --> (hd (tl V2205))) (and (cons? (tl (tl V2205))) (= () (tl (tl (tl V2205))))))))) (adjoin (cons (hd V2204) (cons : (cons (hd V2205) ()))) (shen.patthyps (tl V2204) (hd (tl (tl V2205))) V2206))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2211 V2212) (cond ((= () V2211) V2212) ((and (cons? V2211) (and (cons? V2212) (and (cons? (tl V2212)) (and (= --> (hd (tl V2212))) (and (cons? (tl (tl V2212))) (= () (tl (tl (tl V2212))))))))) (shen.result-type (tl V2211) (hd (tl (tl V2212))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2213 V2214 V2215 V2216 V2217) (let Case (let V1785 (shen.lazyderef V2213 V2216) (if (= () V1785) (do (shen.incinfs) (thaw V2217)) false)) (if (= Case false) (let V1786 (shen.lazyderef V2213 V2216) (if (cons? V1786) (let Pattern (hd V1786) (let Patterns (tl V1786) (let V1787 (shen.lazyderef V2214 V2216) (if (cons? V1787) (let A (hd V1787) (let V1788 (shen.lazyderef (tl V1787) V2216) (if (cons? V1788) (let V1789 (shen.lazyderef (hd V1788) V2216) (if (= --> V1789) (let V1790 (shen.lazyderef (tl V1788) V2216) (if (cons? V1790) (let B (hd V1790) (let V1791 (shen.lazyderef (tl V1790) V2216) (if (= () V1791) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V2215 V2216 (freeze (shen.t*-patterns Patterns B V2215 V2216 V2217)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2218 V2219 V2220 V2221 V2222) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1762 (shen.lazyderef V2218 V2221) (if (cons? V1762) (let V1763 (shen.lazyderef (hd V1762) V2221) (if (= where V1763) (let V1764 (shen.lazyderef (tl V1762) V2221) (if (cons? V1764) (let P (hd V1764) (let V1765 (shen.lazyderef (tl V1764) V2221) (if (cons? V1765) (let Action (hd V1765) (let V1766 (shen.lazyderef (tl V1765) V2221) (if (= () V1766) (do (shen.incinfs) (cut Throwcontrol V2221 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2220 V2221 (freeze (cut Throwcontrol V2221 (freeze (shen.t*-action Action V2219 (cons (cons P (cons : (cons verified ()))) V2220) V2221 V2222)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1767 (shen.lazyderef V2218 V2221) (if (cons? V1767) (let V1768 (shen.lazyderef (hd V1767) V2221) (if (= shen.choicepoint! V1768) (let V1769 (shen.lazyderef (tl V1767) V2221) (if (cons? V1769) (let V1770 (shen.lazyderef (hd V1769) V2221) (if (cons? V1770) (let V1771 (shen.lazyderef (hd V1770) V2221) (if (cons? V1771) (let V1772 (shen.lazyderef (hd V1771) V2221) (if (= fail-if V1772) (let V1773 (shen.lazyderef (tl V1771) V2221) (if (cons? V1773) (let F (hd V1773) (let V1774 (shen.lazyderef (tl V1773) V2221) (if (= () V1774) (let V1775 (shen.lazyderef (tl V1770) V2221) (if (cons? V1775) (let Action (hd V1775) (let V1776 (shen.lazyderef (tl V1775) V2221) (if (= () V1776) (let V1777 (shen.lazyderef (tl V1769) V2221) (if (= () V1777) (do (shen.incinfs) (cut Throwcontrol V2221 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2219 V2220 V2221 V2222)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1778 (shen.lazyderef V2218 V2221) (if (cons? V1778) (let V1779 (shen.lazyderef (hd V1778) V2221) (if (= shen.choicepoint! V1779) (let V1780 (shen.lazyderef (tl V1778) V2221) (if (cons? V1780) (let Action (hd V1780) (let V1781 (shen.lazyderef (tl V1780) V2221) (if (= () V1781) (do (shen.incinfs) (cut Throwcontrol V2221 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2219 V2220 V2221 V2222)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2218 (cons : (cons V2219 ()))) V2220 V2221 V2222)) Case)) Case)) Case)))))

(defun findall (V2223 V2224 V2225 V2226 V2227) (let B (shen.newpv V2226) (let A (shen.newpv V2226) (do (shen.incinfs) (bind A (gensym shen.a) V2226 (freeze (bind B (set (shen.lazyderef A V2226) ()) V2226 (freeze (shen.findallhelp V2223 V2224 V2225 A V2226 V2227)))))))))

(defun shen.findallhelp (V2228 V2229 V2230 V2231 V2232 V2233) (let Case (do (shen.incinfs) (call V2229 V2232 (freeze (shen.remember V2231 V2228 V2232 (freeze (fwhen false V2232 V2233)))))) (if (= Case false) (do (shen.incinfs) (bind V2230 (value (shen.lazyderef V2231 V2232)) V2232 V2233)) Case)))

(defun shen.remember (V2234 V2235 V2236 V2237) (let B (shen.newpv V2236) (do (shen.incinfs) (bind B (set (shen.deref V2234 V2236) (cons (shen.deref V2235 V2236) (value (shen.deref V2234 V2236)))) V2236 V2237))))



