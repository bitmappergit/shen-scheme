"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V18120 V18121) (let Curry (shen.curry V18120) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V18121)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V18123) (cond ((and (cons? V18123) (shen.special? (hd V18123))) (cons (hd V18123) (map (lambda Y (shen.curry Y)) (tl V18123)))) ((and (cons? V18123) (and (cons? (tl V18123)) (shen.extraspecial? (hd V18123)))) V18123) ((and (cons? V18123) (and (= type (hd V18123)) (and (cons? (tl V18123)) (and (cons? (tl (tl V18123))) (= () (tl (tl (tl V18123)))))))) (cons type (cons (shen.curry (hd (tl V18123))) (tl (tl V18123))))) ((and (cons? V18123) (and (cons? (tl V18123)) (cons? (tl (tl V18123))))) (shen.curry (cons (cons (hd V18123) (cons (hd (tl V18123)) ())) (tl (tl V18123))))) ((and (cons? V18123) (and (cons? (tl V18123)) (= () (tl (tl V18123))))) (cons (shen.curry (hd V18123)) (cons (shen.curry (hd (tl V18123))) ()))) (true V18123)))

(defun shen.special? (V18125) (element? V18125 (value shen.*special*)))

(defun shen.extraspecial? (V18127) (element? V18127 (value shen.*extraspecial*)))

(defun shen.t* (V18132 V18133 V18134 V18135) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V18134) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V18134 (freeze (bind Error (shen.errormaxinfs) V18134 V18135))))) (if (= Case false) (let Case (let V18112 (shen.lazyderef V18132 V18134) (if (= fail V18112) (do (shen.incinfs) (cut Throwcontrol V18134 (freeze (shen.prolog-failure V18134 V18135)))) false)) (if (= Case false) (let Case (let V18113 (shen.lazyderef V18132 V18134) (if (cons? V18113) (let X (hd V18113) (let V18114 (shen.lazyderef (tl V18113) V18134) (if (cons? V18114) (let V18115 (shen.lazyderef (hd V18114) V18134) (if (= : V18115) (let V18116 (shen.lazyderef (tl V18114) V18134) (if (cons? V18116) (let A (hd V18116) (let V18117 (shen.lazyderef (tl V18116) V18134) (if (= () V18117) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V18134 (freeze (cut Throwcontrol V18134 (freeze (shen.th* X A V18133 V18134 V18135)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V18134) (do (shen.incinfs) (shen.show V18132 V18133 V18134 (freeze (bind Datatypes (value shen.*datatypes*) V18134 (freeze (shen.udefs* V18132 V18133 Datatypes V18134 V18135))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V18141) (cond ((= + V18141) (set shen.*shen-type-theory-enabled?* true)) ((= - V18141) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V18152 V18153) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V18159 V18160 V18161 V18162 V18163) (let Case (let V18108 (shen.lazyderef V18161 V18162) (if (cons? V18108) (let D (hd V18108) (do (shen.incinfs) (call (cons D (cons V18159 (cons V18160 ()))) V18162 V18163))) false)) (if (= Case false) (let V18109 (shen.lazyderef V18161 V18162) (if (cons? V18109) (let Ds (tl V18109) (do (shen.incinfs) (shen.udefs* V18159 V18160 Ds V18162 V18163))) false)) Case)))

(defun shen.th* (V18169 V18170 V18171 V18172 V18173) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V18169 (cons : (cons V18170 ()))) V18171 V18172 (freeze (fwhen false V18172 V18173)))) (if (= Case false) (let Case (let F (shen.newpv V18172) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V18169 V18172)) V18172 (freeze (bind F (shen.sigf (shen.lazyderef V18169 V18172)) V18172 (freeze (call (cons F (cons V18170 ())) V18172 V18173))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V18169 V18170 V18172 V18173)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V18169 V18170 V18171 V18172 V18173)) (if (= Case false) (let Case (let V18004 (shen.lazyderef V18169 V18172) (if (cons? V18004) (let F (hd V18004) (let V18005 (shen.lazyderef (tl V18004) V18172) (if (= () V18005) (do (shen.incinfs) (shen.th* F (cons --> (cons V18170 ())) V18171 V18172 V18173)) false))) false)) (if (= Case false) (let Case (let V18006 (shen.lazyderef V18169 V18172) (if (cons? V18006) (let F (hd V18006) (let V18007 (shen.lazyderef (tl V18006) V18172) (if (cons? V18007) (let X (hd V18007) (let V18008 (shen.lazyderef (tl V18007) V18172) (if (= () V18008) (let B (shen.newpv V18172) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V18170 ()))) V18171 V18172 (freeze (shen.th* X B V18171 V18172 V18173))))) false))) false))) false)) (if (= Case false) (let Case (let V18009 (shen.lazyderef V18169 V18172) (if (cons? V18009) (let V18010 (shen.lazyderef (hd V18009) V18172) (if (= cons V18010) (let V18011 (shen.lazyderef (tl V18009) V18172) (if (cons? V18011) (let X (hd V18011) (let V18012 (shen.lazyderef (tl V18011) V18172) (if (cons? V18012) (let Y (hd V18012) (let V18013 (shen.lazyderef (tl V18012) V18172) (if (= () V18013) (let V18014 (shen.lazyderef V18170 V18172) (if (cons? V18014) (let V18015 (shen.lazyderef (hd V18014) V18172) (if (= list V18015) (let V18016 (shen.lazyderef (tl V18014) V18172) (if (cons? V18016) (let A (hd V18016) (let V18017 (shen.lazyderef (tl V18016) V18172) (if (= () V18017) (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (if (shen.pvar? V18017) (do (shen.bindv V18017 () V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18017 V18172) Result))) false)))) (if (shen.pvar? V18016) (let A (shen.newpv V18172) (do (shen.bindv V18016 (cons A ()) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18016 V18172) Result)))) false))) (if (shen.pvar? V18015) (do (shen.bindv V18015 list V18172) (let Result (let V18018 (shen.lazyderef (tl V18014) V18172) (if (cons? V18018) (let A (hd V18018) (let V18019 (shen.lazyderef (tl V18018) V18172) (if (= () V18019) (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (if (shen.pvar? V18019) (do (shen.bindv V18019 () V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18019 V18172) Result))) false)))) (if (shen.pvar? V18018) (let A (shen.newpv V18172) (do (shen.bindv V18018 (cons A ()) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18018 V18172) Result)))) false))) (do (shen.unbindv V18015 V18172) Result))) false))) (if (shen.pvar? V18014) (let A (shen.newpv V18172) (do (shen.bindv V18014 (cons list (cons A ())) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons list (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18014 V18172) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18020 (shen.lazyderef V18169 V18172) (if (cons? V18020) (let V18021 (shen.lazyderef (hd V18020) V18172) (if (= @p V18021) (let V18022 (shen.lazyderef (tl V18020) V18172) (if (cons? V18022) (let X (hd V18022) (let V18023 (shen.lazyderef (tl V18022) V18172) (if (cons? V18023) (let Y (hd V18023) (let V18024 (shen.lazyderef (tl V18023) V18172) (if (= () V18024) (let V18025 (shen.lazyderef V18170 V18172) (if (cons? V18025) (let A (hd V18025) (let V18026 (shen.lazyderef (tl V18025) V18172) (if (cons? V18026) (let V18027 (shen.lazyderef (hd V18026) V18172) (if (= * V18027) (let V18028 (shen.lazyderef (tl V18026) V18172) (if (cons? V18028) (let B (hd V18028) (let V18029 (shen.lazyderef (tl V18028) V18172) (if (= () V18029) (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (if (shen.pvar? V18029) (do (shen.bindv V18029 () V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (do (shen.unbindv V18029 V18172) Result))) false)))) (if (shen.pvar? V18028) (let B (shen.newpv V18172) (do (shen.bindv V18028 (cons B ()) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (do (shen.unbindv V18028 V18172) Result)))) false))) (if (shen.pvar? V18027) (do (shen.bindv V18027 * V18172) (let Result (let V18030 (shen.lazyderef (tl V18026) V18172) (if (cons? V18030) (let B (hd V18030) (let V18031 (shen.lazyderef (tl V18030) V18172) (if (= () V18031) (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (if (shen.pvar? V18031) (do (shen.bindv V18031 () V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (do (shen.unbindv V18031 V18172) Result))) false)))) (if (shen.pvar? V18030) (let B (shen.newpv V18172) (do (shen.bindv V18030 (cons B ()) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (do (shen.unbindv V18030 V18172) Result)))) false))) (do (shen.unbindv V18027 V18172) Result))) false))) (if (shen.pvar? V18026) (let B (shen.newpv V18172) (do (shen.bindv V18026 (cons * (cons B ())) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (do (shen.unbindv V18026 V18172) Result)))) false)))) (if (shen.pvar? V18025) (let A (shen.newpv V18172) (let B (shen.newpv V18172) (do (shen.bindv V18025 (cons A (cons * (cons B ()))) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y B V18171 V18172 V18173)))) (do (shen.unbindv V18025 V18172) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18032 (shen.lazyderef V18169 V18172) (if (cons? V18032) (let V18033 (shen.lazyderef (hd V18032) V18172) (if (= @v V18033) (let V18034 (shen.lazyderef (tl V18032) V18172) (if (cons? V18034) (let X (hd V18034) (let V18035 (shen.lazyderef (tl V18034) V18172) (if (cons? V18035) (let Y (hd V18035) (let V18036 (shen.lazyderef (tl V18035) V18172) (if (= () V18036) (let V18037 (shen.lazyderef V18170 V18172) (if (cons? V18037) (let V18038 (shen.lazyderef (hd V18037) V18172) (if (= vector V18038) (let V18039 (shen.lazyderef (tl V18037) V18172) (if (cons? V18039) (let A (hd V18039) (let V18040 (shen.lazyderef (tl V18039) V18172) (if (= () V18040) (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (if (shen.pvar? V18040) (do (shen.bindv V18040 () V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18040 V18172) Result))) false)))) (if (shen.pvar? V18039) (let A (shen.newpv V18172) (do (shen.bindv V18039 (cons A ()) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18039 V18172) Result)))) false))) (if (shen.pvar? V18038) (do (shen.bindv V18038 vector V18172) (let Result (let V18041 (shen.lazyderef (tl V18037) V18172) (if (cons? V18041) (let A (hd V18041) (let V18042 (shen.lazyderef (tl V18041) V18172) (if (= () V18042) (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (if (shen.pvar? V18042) (do (shen.bindv V18042 () V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18042 V18172) Result))) false)))) (if (shen.pvar? V18041) (let A (shen.newpv V18172) (do (shen.bindv V18041 (cons A ()) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18041 V18172) Result)))) false))) (do (shen.unbindv V18038 V18172) Result))) false))) (if (shen.pvar? V18037) (let A (shen.newpv V18172) (do (shen.bindv V18037 (cons vector (cons A ())) V18172) (let Result (do (shen.incinfs) (shen.th* X A V18171 V18172 (freeze (shen.th* Y (cons vector (cons A ())) V18171 V18172 V18173)))) (do (shen.unbindv V18037 V18172) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18043 (shen.lazyderef V18169 V18172) (if (cons? V18043) (let V18044 (shen.lazyderef (hd V18043) V18172) (if (= @s V18044) (let V18045 (shen.lazyderef (tl V18043) V18172) (if (cons? V18045) (let X (hd V18045) (let V18046 (shen.lazyderef (tl V18045) V18172) (if (cons? V18046) (let Y (hd V18046) (let V18047 (shen.lazyderef (tl V18046) V18172) (if (= () V18047) (let V18048 (shen.lazyderef V18170 V18172) (if (= string V18048) (do (shen.incinfs) (shen.th* X string V18171 V18172 (freeze (shen.th* Y string V18171 V18172 V18173)))) (if (shen.pvar? V18048) (do (shen.bindv V18048 string V18172) (let Result (do (shen.incinfs) (shen.th* X string V18171 V18172 (freeze (shen.th* Y string V18171 V18172 V18173)))) (do (shen.unbindv V18048 V18172) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18049 (shen.lazyderef V18169 V18172) (if (cons? V18049) (let V18050 (shen.lazyderef (hd V18049) V18172) (if (= lambda V18050) (let V18051 (shen.lazyderef (tl V18049) V18172) (if (cons? V18051) (let X (hd V18051) (let V18052 (shen.lazyderef (tl V18051) V18172) (if (cons? V18052) (let Y (hd V18052) (let V18053 (shen.lazyderef (tl V18052) V18172) (if (= () V18053) (let V18054 (shen.lazyderef V18170 V18172) (if (cons? V18054) (let A (hd V18054) (let V18055 (shen.lazyderef (tl V18054) V18172) (if (cons? V18055) (let V18056 (shen.lazyderef (hd V18055) V18172) (if (= --> V18056) (let V18057 (shen.lazyderef (tl V18055) V18172) (if (cons? V18057) (let B (hd V18057) (let V18058 (shen.lazyderef (tl V18057) V18172) (if (= () V18058) (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (if (shen.pvar? V18058) (do (shen.bindv V18058 () V18172) (let Result (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (do (shen.unbindv V18058 V18172) Result))) false)))) (if (shen.pvar? V18057) (let B (shen.newpv V18172) (do (shen.bindv V18057 (cons B ()) V18172) (let Result (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (do (shen.unbindv V18057 V18172) Result)))) false))) (if (shen.pvar? V18056) (do (shen.bindv V18056 --> V18172) (let Result (let V18059 (shen.lazyderef (tl V18055) V18172) (if (cons? V18059) (let B (hd V18059) (let V18060 (shen.lazyderef (tl V18059) V18172) (if (= () V18060) (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (if (shen.pvar? V18060) (do (shen.bindv V18060 () V18172) (let Result (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (do (shen.unbindv V18060 V18172) Result))) false)))) (if (shen.pvar? V18059) (let B (shen.newpv V18172) (do (shen.bindv V18059 (cons B ()) V18172) (let Result (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (do (shen.unbindv V18059 V18172) Result)))) false))) (do (shen.unbindv V18056 V18172) Result))) false))) (if (shen.pvar? V18055) (let B (shen.newpv V18172) (do (shen.bindv V18055 (cons --> (cons B ())) V18172) (let Result (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (do (shen.unbindv V18055 V18172) Result)))) false)))) (if (shen.pvar? V18054) (let A (shen.newpv V18172) (let B (shen.newpv V18172) (do (shen.bindv V18054 (cons A (cons --> (cons B ()))) V18172) (let Result (let Z (shen.newpv V18172) (let X&& (shen.newpv V18172) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Y V18172)) V18172 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V18171) V18172 V18173)))))))))) (do (shen.unbindv V18054 V18172) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18061 (shen.lazyderef V18169 V18172) (if (cons? V18061) (let V18062 (shen.lazyderef (hd V18061) V18172) (if (= let V18062) (let V18063 (shen.lazyderef (tl V18061) V18172) (if (cons? V18063) (let X (hd V18063) (let V18064 (shen.lazyderef (tl V18063) V18172) (if (cons? V18064) (let Y (hd V18064) (let V18065 (shen.lazyderef (tl V18064) V18172) (if (cons? V18065) (let Z (hd V18065) (let V18066 (shen.lazyderef (tl V18065) V18172) (if (= () V18066) (let W (shen.newpv V18172) (let X&& (shen.newpv V18172) (let B (shen.newpv V18172) (do (shen.incinfs) (shen.th* Y B V18171 V18172 (freeze (bind X&& (shen.placeholder) V18172 (freeze (bind W (shen.ebr (shen.lazyderef X&& V18172) (shen.lazyderef X V18172) (shen.lazyderef Z V18172)) V18172 (freeze (shen.th* W V18170 (cons (cons X&& (cons : (cons B ()))) V18171) V18172 V18173))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18067 (shen.lazyderef V18169 V18172) (if (cons? V18067) (let V18068 (shen.lazyderef (hd V18067) V18172) (if (= open V18068) (let V18069 (shen.lazyderef (tl V18067) V18172) (if (cons? V18069) (let FileName (hd V18069) (let V18070 (shen.lazyderef (tl V18069) V18172) (if (cons? V18070) (let Direction18000 (hd V18070) (let V18071 (shen.lazyderef (tl V18070) V18172) (if (= () V18071) (let V18072 (shen.lazyderef V18170 V18172) (if (cons? V18072) (let V18073 (shen.lazyderef (hd V18072) V18172) (if (= stream V18073) (let V18074 (shen.lazyderef (tl V18072) V18172) (if (cons? V18074) (let Direction (hd V18074) (let V18075 (shen.lazyderef (tl V18074) V18172) (if (= () V18075) (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (if (shen.pvar? V18075) (do (shen.bindv V18075 () V18172) (let Result (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (do (shen.unbindv V18075 V18172) Result))) false)))) (if (shen.pvar? V18074) (let Direction (shen.newpv V18172) (do (shen.bindv V18074 (cons Direction ()) V18172) (let Result (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (do (shen.unbindv V18074 V18172) Result)))) false))) (if (shen.pvar? V18073) (do (shen.bindv V18073 stream V18172) (let Result (let V18076 (shen.lazyderef (tl V18072) V18172) (if (cons? V18076) (let Direction (hd V18076) (let V18077 (shen.lazyderef (tl V18076) V18172) (if (= () V18077) (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (if (shen.pvar? V18077) (do (shen.bindv V18077 () V18172) (let Result (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (do (shen.unbindv V18077 V18172) Result))) false)))) (if (shen.pvar? V18076) (let Direction (shen.newpv V18172) (do (shen.bindv V18076 (cons Direction ()) V18172) (let Result (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (do (shen.unbindv V18076 V18172) Result)))) false))) (do (shen.unbindv V18073 V18172) Result))) false))) (if (shen.pvar? V18072) (let Direction (shen.newpv V18172) (do (shen.bindv V18072 (cons stream (cons Direction ())) V18172) (let Result (do (shen.incinfs) (unify! Direction Direction18000 V18172 (freeze (cut Throwcontrol V18172 (freeze (fwhen (element? (shen.lazyderef Direction V18172) (cons in (cons out ()))) V18172 (freeze (shen.th* FileName string V18171 V18172 V18173)))))))) (do (shen.unbindv V18072 V18172) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18078 (shen.lazyderef V18169 V18172) (if (cons? V18078) (let V18079 (shen.lazyderef (hd V18078) V18172) (if (= type V18079) (let V18080 (shen.lazyderef (tl V18078) V18172) (if (cons? V18080) (let X (hd V18080) (let V18081 (shen.lazyderef (tl V18080) V18172) (if (cons? V18081) (let A (hd V18081) (let V18082 (shen.lazyderef (tl V18081) V18172) (if (= () V18082) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (unify A V18170 V18172 (freeze (shen.th* X A V18171 V18172 V18173)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18083 (shen.lazyderef V18169 V18172) (if (cons? V18083) (let V18084 (shen.lazyderef (hd V18083) V18172) (if (= input+ V18084) (let V18085 (shen.lazyderef (tl V18083) V18172) (if (cons? V18085) (let A (hd V18085) (let V18086 (shen.lazyderef (tl V18085) V18172) (if (cons? V18086) (let Stream (hd V18086) (let V18087 (shen.lazyderef (tl V18086) V18172) (if (= () V18087) (let C (shen.newpv V18172) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V18172)) V18172 (freeze (unify V18170 C V18172 (freeze (shen.th* Stream (cons stream (cons in ())) V18171 V18172 V18173))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V18088 (shen.lazyderef V18169 V18172) (if (cons? V18088) (let V18089 (shen.lazyderef (hd V18088) V18172) (if (= set V18089) (let V18090 (shen.lazyderef (tl V18088) V18172) (if (cons? V18090) (let Var (hd V18090) (let V18091 (shen.lazyderef (tl V18090) V18172) (if (cons? V18091) (let Val (hd V18091) (let V18092 (shen.lazyderef (tl V18091) V18172) (if (= () V18092) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (shen.th* Var symbol V18171 V18172 (freeze (cut Throwcontrol V18172 (freeze (shen.th* (cons value (cons Var ())) V18170 V18171 V18172 (freeze (shen.th* Val V18170 V18171 V18172 V18173)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V18172) (do (shen.incinfs) (shen.t*-hyps V18171 NewHyp V18172 (freeze (shen.th* V18169 V18170 NewHyp V18172 V18173))))) (if (= Case false) (let Case (let V18093 (shen.lazyderef V18169 V18172) (if (cons? V18093) (let V18094 (shen.lazyderef (hd V18093) V18172) (if (= define V18094) (let V18095 (shen.lazyderef (tl V18093) V18172) (if (cons? V18095) (let F (hd V18095) (let X (tl V18095) (do (shen.incinfs) (cut Throwcontrol V18172 (freeze (shen.t*-def (cons define (cons F X)) V18170 V18171 V18172 V18173)))))) false)) false)) false)) (if (= Case false) (let Case (let V18096 (shen.lazyderef V18169 V18172) (if (cons? V18096) (let V18097 (shen.lazyderef (hd V18096) V18172) (if (= defmacro V18097) (let V18098 (shen.lazyderef V18170 V18172) (if (= unit V18098) (do (shen.incinfs) (cut Throwcontrol V18172 V18173)) (if (shen.pvar? V18098) (do (shen.bindv V18098 unit V18172) (let Result (do (shen.incinfs) (cut Throwcontrol V18172 V18173)) (do (shen.unbindv V18098 V18172) Result))) false))) false)) false)) (if (= Case false) (let Case (let V18099 (shen.lazyderef V18169 V18172) (if (cons? V18099) (let V18100 (shen.lazyderef (hd V18099) V18172) (if (= shen.process-datatype V18100) (let V18101 (shen.lazyderef V18170 V18172) (if (= symbol V18101) (do (shen.incinfs) (thaw V18173)) (if (shen.pvar? V18101) (do (shen.bindv V18101 symbol V18172) (let Result (do (shen.incinfs) (thaw V18173)) (do (shen.unbindv V18101 V18172) Result))) false))) false)) false)) (if (= Case false) (let Case (let V18102 (shen.lazyderef V18169 V18172) (if (cons? V18102) (let V18103 (shen.lazyderef (hd V18102) V18172) (if (= shen.synonyms-help V18103) (let V18104 (shen.lazyderef V18170 V18172) (if (= symbol V18104) (do (shen.incinfs) (thaw V18173)) (if (shen.pvar? V18104) (do (shen.bindv V18104 symbol V18172) (let Result (do (shen.incinfs) (thaw V18173)) (do (shen.unbindv V18104 V18172) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V18172) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V18172 (freeze (shen.udefs* (cons V18169 (cons : (cons V18170 ()))) V18171 Datatypes V18172 V18173))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V18178 V18179 V18180 V18181) (let Case (let V17915 (shen.lazyderef V18178 V18180) (if (cons? V17915) (let V17916 (shen.lazyderef (hd V17915) V18180) (if (cons? V17916) (let V17917 (shen.lazyderef (hd V17916) V18180) (if (cons? V17917) (let V17918 (shen.lazyderef (hd V17917) V18180) (if (= cons V17918) (let V17919 (shen.lazyderef (tl V17917) V18180) (if (cons? V17919) (let X (hd V17919) (let V17920 (shen.lazyderef (tl V17919) V18180) (if (cons? V17920) (let Y (hd V17920) (let V17921 (shen.lazyderef (tl V17920) V18180) (if (= () V17921) (let V17922 (shen.lazyderef (tl V17916) V18180) (if (cons? V17922) (let V17923 (shen.lazyderef (hd V17922) V18180) (if (= : V17923) (let V17924 (shen.lazyderef (tl V17922) V18180) (if (cons? V17924) (let V17925 (shen.lazyderef (hd V17924) V18180) (if (cons? V17925) (let V17926 (shen.lazyderef (hd V17925) V18180) (if (= list V17926) (let V17927 (shen.lazyderef (tl V17925) V18180) (if (cons? V17927) (let A (hd V17927) (let V17928 (shen.lazyderef (tl V17927) V18180) (if (= () V17928) (let V17929 (shen.lazyderef (tl V17924) V18180) (if (= () V17929) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17929) (do (shen.bindv V17929 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17929 V18180) Result))) false))) (if (shen.pvar? V17928) (do (shen.bindv V17928 () V18180) (let Result (let V17930 (shen.lazyderef (tl V17924) V18180) (if (= () V17930) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17930) (do (shen.bindv V17930 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17930 V18180) Result))) false))) (do (shen.unbindv V17928 V18180) Result))) false)))) (if (shen.pvar? V17927) (let A (shen.newpv V18180) (do (shen.bindv V17927 (cons A ()) V18180) (let Result (let V17931 (shen.lazyderef (tl V17924) V18180) (if (= () V17931) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17931) (do (shen.bindv V17931 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17931 V18180) Result))) false))) (do (shen.unbindv V17927 V18180) Result)))) false))) (if (shen.pvar? V17926) (do (shen.bindv V17926 list V18180) (let Result (let V17932 (shen.lazyderef (tl V17925) V18180) (if (cons? V17932) (let A (hd V17932) (let V17933 (shen.lazyderef (tl V17932) V18180) (if (= () V17933) (let V17934 (shen.lazyderef (tl V17924) V18180) (if (= () V17934) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17934) (do (shen.bindv V17934 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17934 V18180) Result))) false))) (if (shen.pvar? V17933) (do (shen.bindv V17933 () V18180) (let Result (let V17935 (shen.lazyderef (tl V17924) V18180) (if (= () V17935) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17935) (do (shen.bindv V17935 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17935 V18180) Result))) false))) (do (shen.unbindv V17933 V18180) Result))) false)))) (if (shen.pvar? V17932) (let A (shen.newpv V18180) (do (shen.bindv V17932 (cons A ()) V18180) (let Result (let V17936 (shen.lazyderef (tl V17924) V18180) (if (= () V17936) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17936) (do (shen.bindv V17936 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17936 V18180) Result))) false))) (do (shen.unbindv V17932 V18180) Result)))) false))) (do (shen.unbindv V17926 V18180) Result))) false))) (if (shen.pvar? V17925) (let A (shen.newpv V18180) (do (shen.bindv V17925 (cons list (cons A ())) V18180) (let Result (let V17937 (shen.lazyderef (tl V17924) V18180) (if (= () V17937) (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17937) (do (shen.bindv V17937 () V18180) (let Result (let Hyp (tl V17915) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons list (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17937 V18180) Result))) false))) (do (shen.unbindv V17925 V18180) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V17938 (shen.lazyderef V18178 V18180) (if (cons? V17938) (let V17939 (shen.lazyderef (hd V17938) V18180) (if (cons? V17939) (let V17940 (shen.lazyderef (hd V17939) V18180) (if (cons? V17940) (let V17941 (shen.lazyderef (hd V17940) V18180) (if (= @p V17941) (let V17942 (shen.lazyderef (tl V17940) V18180) (if (cons? V17942) (let X (hd V17942) (let V17943 (shen.lazyderef (tl V17942) V18180) (if (cons? V17943) (let Y (hd V17943) (let V17944 (shen.lazyderef (tl V17943) V18180) (if (= () V17944) (let V17945 (shen.lazyderef (tl V17939) V18180) (if (cons? V17945) (let V17946 (shen.lazyderef (hd V17945) V18180) (if (= : V17946) (let V17947 (shen.lazyderef (tl V17945) V18180) (if (cons? V17947) (let V17948 (shen.lazyderef (hd V17947) V18180) (if (cons? V17948) (let A (hd V17948) (let V17949 (shen.lazyderef (tl V17948) V18180) (if (cons? V17949) (let V17950 (shen.lazyderef (hd V17949) V18180) (if (= * V17950) (let V17951 (shen.lazyderef (tl V17949) V18180) (if (cons? V17951) (let B (hd V17951) (let V17952 (shen.lazyderef (tl V17951) V18180) (if (= () V17952) (let V17953 (shen.lazyderef (tl V17947) V18180) (if (= () V17953) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17953) (do (shen.bindv V17953 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17953 V18180) Result))) false))) (if (shen.pvar? V17952) (do (shen.bindv V17952 () V18180) (let Result (let V17954 (shen.lazyderef (tl V17947) V18180) (if (= () V17954) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17954) (do (shen.bindv V17954 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17954 V18180) Result))) false))) (do (shen.unbindv V17952 V18180) Result))) false)))) (if (shen.pvar? V17951) (let B (shen.newpv V18180) (do (shen.bindv V17951 (cons B ()) V18180) (let Result (let V17955 (shen.lazyderef (tl V17947) V18180) (if (= () V17955) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17955) (do (shen.bindv V17955 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17955 V18180) Result))) false))) (do (shen.unbindv V17951 V18180) Result)))) false))) (if (shen.pvar? V17950) (do (shen.bindv V17950 * V18180) (let Result (let V17956 (shen.lazyderef (tl V17949) V18180) (if (cons? V17956) (let B (hd V17956) (let V17957 (shen.lazyderef (tl V17956) V18180) (if (= () V17957) (let V17958 (shen.lazyderef (tl V17947) V18180) (if (= () V17958) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17958) (do (shen.bindv V17958 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17958 V18180) Result))) false))) (if (shen.pvar? V17957) (do (shen.bindv V17957 () V18180) (let Result (let V17959 (shen.lazyderef (tl V17947) V18180) (if (= () V17959) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17959) (do (shen.bindv V17959 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17959 V18180) Result))) false))) (do (shen.unbindv V17957 V18180) Result))) false)))) (if (shen.pvar? V17956) (let B (shen.newpv V18180) (do (shen.bindv V17956 (cons B ()) V18180) (let Result (let V17960 (shen.lazyderef (tl V17947) V18180) (if (= () V17960) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17960) (do (shen.bindv V17960 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17960 V18180) Result))) false))) (do (shen.unbindv V17956 V18180) Result)))) false))) (do (shen.unbindv V17950 V18180) Result))) false))) (if (shen.pvar? V17949) (let B (shen.newpv V18180) (do (shen.bindv V17949 (cons * (cons B ())) V18180) (let Result (let V17961 (shen.lazyderef (tl V17947) V18180) (if (= () V17961) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17961) (do (shen.bindv V17961 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17961 V18180) Result))) false))) (do (shen.unbindv V17949 V18180) Result)))) false)))) (if (shen.pvar? V17948) (let A (shen.newpv V18180) (let B (shen.newpv V18180) (do (shen.bindv V17948 (cons A (cons * (cons B ()))) V18180) (let Result (let V17962 (shen.lazyderef (tl V17947) V18180) (if (= () V17962) (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17962) (do (shen.bindv V17962 () V18180) (let Result (let Hyp (tl V17938) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (shen.lazyderef B V18180) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17962 V18180) Result))) false))) (do (shen.unbindv V17948 V18180) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V17963 (shen.lazyderef V18178 V18180) (if (cons? V17963) (let V17964 (shen.lazyderef (hd V17963) V18180) (if (cons? V17964) (let V17965 (shen.lazyderef (hd V17964) V18180) (if (cons? V17965) (let V17966 (shen.lazyderef (hd V17965) V18180) (if (= @v V17966) (let V17967 (shen.lazyderef (tl V17965) V18180) (if (cons? V17967) (let X (hd V17967) (let V17968 (shen.lazyderef (tl V17967) V18180) (if (cons? V17968) (let Y (hd V17968) (let V17969 (shen.lazyderef (tl V17968) V18180) (if (= () V17969) (let V17970 (shen.lazyderef (tl V17964) V18180) (if (cons? V17970) (let V17971 (shen.lazyderef (hd V17970) V18180) (if (= : V17971) (let V17972 (shen.lazyderef (tl V17970) V18180) (if (cons? V17972) (let V17973 (shen.lazyderef (hd V17972) V18180) (if (cons? V17973) (let V17974 (shen.lazyderef (hd V17973) V18180) (if (= vector V17974) (let V17975 (shen.lazyderef (tl V17973) V18180) (if (cons? V17975) (let A (hd V17975) (let V17976 (shen.lazyderef (tl V17975) V18180) (if (= () V17976) (let V17977 (shen.lazyderef (tl V17972) V18180) (if (= () V17977) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17977) (do (shen.bindv V17977 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17977 V18180) Result))) false))) (if (shen.pvar? V17976) (do (shen.bindv V17976 () V18180) (let Result (let V17978 (shen.lazyderef (tl V17972) V18180) (if (= () V17978) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17978) (do (shen.bindv V17978 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17978 V18180) Result))) false))) (do (shen.unbindv V17976 V18180) Result))) false)))) (if (shen.pvar? V17975) (let A (shen.newpv V18180) (do (shen.bindv V17975 (cons A ()) V18180) (let Result (let V17979 (shen.lazyderef (tl V17972) V18180) (if (= () V17979) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17979) (do (shen.bindv V17979 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17979 V18180) Result))) false))) (do (shen.unbindv V17975 V18180) Result)))) false))) (if (shen.pvar? V17974) (do (shen.bindv V17974 vector V18180) (let Result (let V17980 (shen.lazyderef (tl V17973) V18180) (if (cons? V17980) (let A (hd V17980) (let V17981 (shen.lazyderef (tl V17980) V18180) (if (= () V17981) (let V17982 (shen.lazyderef (tl V17972) V18180) (if (= () V17982) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17982) (do (shen.bindv V17982 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17982 V18180) Result))) false))) (if (shen.pvar? V17981) (do (shen.bindv V17981 () V18180) (let Result (let V17983 (shen.lazyderef (tl V17972) V18180) (if (= () V17983) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17983) (do (shen.bindv V17983 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17983 V18180) Result))) false))) (do (shen.unbindv V17981 V18180) Result))) false)))) (if (shen.pvar? V17980) (let A (shen.newpv V18180) (do (shen.bindv V17980 (cons A ()) V18180) (let Result (let V17984 (shen.lazyderef (tl V17972) V18180) (if (= () V17984) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17984) (do (shen.bindv V17984 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17984 V18180) Result))) false))) (do (shen.unbindv V17980 V18180) Result)))) false))) (do (shen.unbindv V17974 V18180) Result))) false))) (if (shen.pvar? V17973) (let A (shen.newpv V18180) (do (shen.bindv V17973 (cons vector (cons A ())) V18180) (let Result (let V17985 (shen.lazyderef (tl V17972) V18180) (if (= () V17985) (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17985) (do (shen.bindv V17985 () V18180) (let Result (let Hyp (tl V17963) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons (shen.lazyderef A V18180) ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons (cons vector (cons (shen.lazyderef A V18180) ())) ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17985 V18180) Result))) false))) (do (shen.unbindv V17973 V18180) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V17986 (shen.lazyderef V18178 V18180) (if (cons? V17986) (let V17987 (shen.lazyderef (hd V17986) V18180) (if (cons? V17987) (let V17988 (shen.lazyderef (hd V17987) V18180) (if (cons? V17988) (let V17989 (shen.lazyderef (hd V17988) V18180) (if (= @s V17989) (let V17990 (shen.lazyderef (tl V17988) V18180) (if (cons? V17990) (let X (hd V17990) (let V17991 (shen.lazyderef (tl V17990) V18180) (if (cons? V17991) (let Y (hd V17991) (let V17992 (shen.lazyderef (tl V17991) V18180) (if (= () V17992) (let V17993 (shen.lazyderef (tl V17987) V18180) (if (cons? V17993) (let V17994 (shen.lazyderef (hd V17993) V18180) (if (= : V17994) (let V17995 (shen.lazyderef (tl V17993) V18180) (if (cons? V17995) (let V17996 (shen.lazyderef (hd V17995) V18180) (if (= string V17996) (let V17997 (shen.lazyderef (tl V17995) V18180) (if (= () V17997) (let Hyp (tl V17986) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons string ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17997) (do (shen.bindv V17997 () V18180) (let Result (let Hyp (tl V17986) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons string ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17997 V18180) Result))) false))) (if (shen.pvar? V17996) (do (shen.bindv V17996 string V18180) (let Result (let V17998 (shen.lazyderef (tl V17995) V18180) (if (= () V17998) (let Hyp (tl V17986) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons string ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (if (shen.pvar? V17998) (do (shen.bindv V17998 () V18180) (let Result (let Hyp (tl V17986) (do (shen.incinfs) (bind V18179 (cons (cons (shen.lazyderef X V18180) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V18180) (cons : (cons string ()))) (shen.lazyderef Hyp V18180))) V18180 V18181))) (do (shen.unbindv V17998 V18180) Result))) false))) (do (shen.unbindv V17996 V18180) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V17999 (shen.lazyderef V18178 V18180) (if (cons? V17999) (let X (hd V17999) (let Hyp (tl V17999) (let NewHyps (shen.newpv V18180) (do (shen.incinfs) (bind V18179 (cons (shen.lazyderef X V18180) (shen.lazyderef NewHyps V18180)) V18180 (freeze (shen.t*-hyps Hyp NewHyps V18180 V18181))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V18198 V18199 V18200 V18201) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V18198 V18200)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V18199 V18200) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V18201))))))))) (true (thaw V18201))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V18203) (cond ((and (cons? V18203) (and (cons? (tl V18203)) (and (= : (hd (tl V18203))) (and (cons? (tl (tl V18203))) (= () (tl (tl (tl V18203)))))))) (shen.prhush (shen.app (hd V18203) (cn " : " (shen.app (hd (tl (tl V18203))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V18203 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V18208 V18209) (cond ((= () V18208) shen.skip) ((cons? V18208) (do (shen.prhush (shen.app V18209 ". " shen.a) (stoutput)) (do (shen.show-p (hd V18208)) (do (nl 1) (shen.show-assumptions (tl V18208) (+ V18209 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V18211) (cons? (assoc V18211 (value shen.*signedfuncs*))))

(defun shen.sigf (V18213) (concat shen.type-signature-of- V18213))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V18218 V18219 V18220 V18221) (let Case (let V17902 (shen.lazyderef V18219 V18220) (if (= number V17902) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V18218 V18220)) V18220 V18221)) (if (shen.pvar? V17902) (do (shen.bindv V17902 number V18220) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V18218 V18220)) V18220 V18221)) (do (shen.unbindv V17902 V18220) Result))) false))) (if (= Case false) (let Case (let V17903 (shen.lazyderef V18219 V18220) (if (= boolean V17903) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V18218 V18220)) V18220 V18221)) (if (shen.pvar? V17903) (do (shen.bindv V17903 boolean V18220) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V18218 V18220)) V18220 V18221)) (do (shen.unbindv V17903 V18220) Result))) false))) (if (= Case false) (let Case (let V17904 (shen.lazyderef V18219 V18220) (if (= string V17904) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V18218 V18220)) V18220 V18221)) (if (shen.pvar? V17904) (do (shen.bindv V17904 string V18220) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V18218 V18220)) V18220 V18221)) (do (shen.unbindv V17904 V18220) Result))) false))) (if (= Case false) (let Case (let V17905 (shen.lazyderef V18219 V18220) (if (= symbol V17905) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V18218 V18220)) V18220 (freeze (fwhen (not (shen.ue? (shen.lazyderef V18218 V18220))) V18220 V18221)))) (if (shen.pvar? V17905) (do (shen.bindv V17905 symbol V18220) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V18218 V18220)) V18220 (freeze (fwhen (not (shen.ue? (shen.lazyderef V18218 V18220))) V18220 V18221)))) (do (shen.unbindv V17905 V18220) Result))) false))) (if (= Case false) (let V17906 (shen.lazyderef V18218 V18220) (if (= () V17906) (let V17907 (shen.lazyderef V18219 V18220) (if (cons? V17907) (let V17908 (shen.lazyderef (hd V17907) V18220) (if (= list V17908) (let V17909 (shen.lazyderef (tl V17907) V18220) (if (cons? V17909) (let A (hd V17909) (let V17910 (shen.lazyderef (tl V17909) V18220) (if (= () V17910) (do (shen.incinfs) (thaw V18221)) (if (shen.pvar? V17910) (do (shen.bindv V17910 () V18220) (let Result (do (shen.incinfs) (thaw V18221)) (do (shen.unbindv V17910 V18220) Result))) false)))) (if (shen.pvar? V17909) (let A (shen.newpv V18220) (do (shen.bindv V17909 (cons A ()) V18220) (let Result (do (shen.incinfs) (thaw V18221)) (do (shen.unbindv V17909 V18220) Result)))) false))) (if (shen.pvar? V17908) (do (shen.bindv V17908 list V18220) (let Result (let V17911 (shen.lazyderef (tl V17907) V18220) (if (cons? V17911) (let A (hd V17911) (let V17912 (shen.lazyderef (tl V17911) V18220) (if (= () V17912) (do (shen.incinfs) (thaw V18221)) (if (shen.pvar? V17912) (do (shen.bindv V17912 () V18220) (let Result (do (shen.incinfs) (thaw V18221)) (do (shen.unbindv V17912 V18220) Result))) false)))) (if (shen.pvar? V17911) (let A (shen.newpv V18220) (do (shen.bindv V17911 (cons A ()) V18220) (let Result (do (shen.incinfs) (thaw V18221)) (do (shen.unbindv V17911 V18220) Result)))) false))) (do (shen.unbindv V17908 V18220) Result))) false))) (if (shen.pvar? V17907) (let A (shen.newpv V18220) (do (shen.bindv V17907 (cons list (cons A ())) V18220) (let Result (do (shen.incinfs) (thaw V18221)) (do (shen.unbindv V17907 V18220) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V18227 V18228 V18229 V18230 V18231) (let Case (let V17893 (shen.lazyderef V18229 V18230) (if (cons? V17893) (let V17894 (shen.lazyderef (hd V17893) V18230) (if (cons? V17894) (let Y (hd V17894) (let V17895 (shen.lazyderef (tl V17894) V18230) (if (cons? V17895) (let V17896 (shen.lazyderef (hd V17895) V18230) (if (= : V17896) (let V17897 (shen.lazyderef (tl V17895) V18230) (if (cons? V17897) (let B (hd V17897) (let V17898 (shen.lazyderef (tl V17897) V18230) (if (= () V17898) (do (shen.incinfs) (identical V18227 Y V18230 (freeze (unify! V18228 B V18230 V18231)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V17899 (shen.lazyderef V18229 V18230) (if (cons? V17899) (let Hyp (tl V17899) (do (shen.incinfs) (shen.by_hypothesis V18227 V18228 Hyp V18230 V18231))) false)) Case)))

(defun shen.t*-def (V18237 V18238 V18239 V18240 V18241) (let V17887 (shen.lazyderef V18237 V18240) (if (cons? V17887) (let V17888 (shen.lazyderef (hd V17887) V18240) (if (= define V17888) (let V17889 (shen.lazyderef (tl V17887) V18240) (if (cons? V17889) (let F (hd V17889) (let X (tl V17889) (let Y (shen.newpv V18240) (let E (shen.newpv V18240) (do (shen.incinfs) (shen.t*-defh (compile (lambda Y (shen.<sig+rules> Y)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V18238 V18239 V18240 V18241)))))) false)) false)) false)))

(defun shen.t*-defh (V18248 V18249 V18250 V18251 V18252 V18253) (let V17883 (shen.lazyderef V18248 V18252) (if (cons? V17883) (let Sig (hd V17883) (let Rules (tl V17883) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V18249 V18250 V18251 Rules V18252 V18253)))) false)))

(defun shen.t*-defhh (V18262 V18263 V18264 V18265 V18266 V18267 V18268 V18269) (do (shen.incinfs) (shen.t*-rules V18267 V18263 1 V18264 (cons (cons V18264 (cons : (cons V18263 ()))) V18266) V18268 (freeze (shen.memo V18264 V18262 V18265 V18268 V18269)))))

(defun shen.memo (V18275 V18276 V18277 V18278 V18279) (let Jnk (shen.newpv V18278) (do (shen.incinfs) (unify! V18277 V18276 V18278 (freeze (bind Jnk (declare (shen.lazyderef V18275 V18278) (shen.lazyderef V18277 V18278)) V18278 V18279))))))

(defun shen.<sig+rules> (V18281) (let Parse_shen.<signature> (shen.<signature> V18281) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V18283) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V18283) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V18283) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V18285) (cond ((and (cons? V18285) (and (cons? (tl V18285)) (and (= () (tl (tl V18285))) (= (hd V18285) protect)))) V18285) ((cons? V18285) (map (lambda Z (shen.ue Z)) V18285)) ((variable? V18285) (concat && V18285)) (true V18285)))

(defun shen.ue-sig (V18287) (cond ((cons? V18287) (map (lambda Z (shen.ue-sig Z)) V18287)) ((variable? V18287) (concat &&& V18287)) (true V18287)))

(defun shen.ues (V18293) (cond ((shen.ue? V18293) (cons V18293 ())) ((cons? V18293) (union (shen.ues (hd V18293)) (shen.ues (tl V18293)))) (true ())))

(defun shen.ue? (V18295) (and (symbol? V18295) (shen.ue-h? (str V18295))))

(defun shen.ue-h? (V18303) (cond ((and (shen.+string? V18303) (and (= "&" (pos V18303 0)) (and (shen.+string? (tlstr V18303)) (= "&" (pos (tlstr V18303) 0))))) true) (true false)))

(defun shen.t*-rules (V18311 V18312 V18313 V18314 V18315 V18316 V18317) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V17867 (shen.lazyderef V18311 V18316) (if (= () V17867) (do (shen.incinfs) (thaw V18317)) false)) (if (= Case false) (let Case (let V17868 (shen.lazyderef V18311 V18316) (if (cons? V17868) (let Rule (hd V17868) (let Rules (tl V17868) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V18312 V18315 V18316 (freeze (cut Throwcontrol V18316 (freeze (shen.t*-rules Rules V18312 (+ V18313 1) V18314 V18315 V18316 V18317)))))))) false)) (if (= Case false) (let Err (shen.newpv V18316) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V18313 V18316) (cn " of " (shen.app (shen.lazyderef V18314 V18316) "" shen.a)) shen.a))) V18316 V18317))) Case)) Case)))))

(defun shen.t*-rule (V18323 V18324 V18325 V18326 V18327) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V17859 (shen.lazyderef V18323 V18326) (if (cons? V17859) (let Patterns (hd V17859) (let V17860 (shen.lazyderef (tl V17859) V18326) (if (cons? V17860) (let Action (hd V17860) (let V17861 (shen.lazyderef (tl V17860) V18326) (if (= () V17861) (let NewHyps (shen.newpv V18326) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V18325 NewHyps V18326 (freeze (shen.t*-patterns Patterns V18324 NewHyps V18326 (freeze (cut Throwcontrol V18326 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V18324) (shen.patthyps Patterns V18324 V18325) V18326 V18327))))))))) false))) false))) false)))))

(defun shen.placeholders (V18333) (cond ((shen.ue? V18333) (cons V18333 ())) ((cons? V18333) (union (shen.placeholders (hd V18333)) (shen.placeholders (tl V18333)))) (true ())))

(defun shen.newhyps (V18339 V18340 V18341 V18342 V18343) (let Case (let V17846 (shen.lazyderef V18339 V18342) (if (= () V17846) (do (shen.incinfs) (unify! V18341 V18340 V18342 V18343)) false)) (if (= Case false) (let V17847 (shen.lazyderef V18339 V18342) (if (cons? V17847) (let V17842 (hd V17847) (let Vs (tl V17847) (let V17848 (shen.lazyderef V18341 V18342) (if (cons? V17848) (let V17849 (shen.lazyderef (hd V17848) V18342) (if (cons? V17849) (let V (hd V17849) (let V17850 (shen.lazyderef (tl V17849) V18342) (if (cons? V17850) (let V17851 (shen.lazyderef (hd V17850) V18342) (if (= : V17851) (let V17852 (shen.lazyderef (tl V17850) V18342) (if (cons? V17852) (let A (hd V17852) (let V17853 (shen.lazyderef (tl V17852) V18342) (if (= () V17853) (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (if (shen.pvar? V17853) (do (shen.bindv V17853 () V18342) (let Result (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (do (shen.unbindv V17853 V18342) Result))) false)))) (if (shen.pvar? V17852) (let A (shen.newpv V18342) (do (shen.bindv V17852 (cons A ()) V18342) (let Result (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (do (shen.unbindv V17852 V18342) Result)))) false))) (if (shen.pvar? V17851) (do (shen.bindv V17851 : V18342) (let Result (let V17854 (shen.lazyderef (tl V17850) V18342) (if (cons? V17854) (let A (hd V17854) (let V17855 (shen.lazyderef (tl V17854) V18342) (if (= () V17855) (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (if (shen.pvar? V17855) (do (shen.bindv V17855 () V18342) (let Result (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (do (shen.unbindv V17855 V18342) Result))) false)))) (if (shen.pvar? V17854) (let A (shen.newpv V18342) (do (shen.bindv V17854 (cons A ()) V18342) (let Result (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (do (shen.unbindv V17854 V18342) Result)))) false))) (do (shen.unbindv V17851 V18342) Result))) false))) (if (shen.pvar? V17850) (let A (shen.newpv V18342) (do (shen.bindv V17850 (cons : (cons A ())) V18342) (let Result (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (do (shen.unbindv V17850 V18342) Result)))) false)))) (if (shen.pvar? V17849) (let V (shen.newpv V18342) (let A (shen.newpv V18342) (do (shen.bindv V17849 (cons V (cons : (cons A ()))) V18342) (let Result (let NewHyp (tl V17848) (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343))))) (do (shen.unbindv V17849 V18342) Result))))) false))) (if (shen.pvar? V17848) (let V (shen.newpv V18342) (let A (shen.newpv V18342) (let NewHyp (shen.newpv V18342) (do (shen.bindv V17848 (cons (cons V (cons : (cons A ()))) NewHyp) V18342) (let Result (do (shen.incinfs) (unify! V V17842 V18342 (freeze (shen.newhyps Vs V18340 NewHyp V18342 V18343)))) (do (shen.unbindv V17848 V18342) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V18349 V18350 V18351) (cond ((= () V18349) V18351) ((and (cons? V18349) (and (cons? V18350) (and (cons? (tl V18350)) (and (= --> (hd (tl V18350))) (and (cons? (tl (tl V18350))) (= () (tl (tl (tl V18350))))))))) (adjoin (cons (hd V18349) (cons : (cons (hd V18350) ()))) (shen.patthyps (tl V18349) (hd (tl (tl V18350))) V18351))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V18358 V18359) (cond ((and (= () V18358) (and (cons? V18359) (and (= --> (hd V18359)) (and (cons? (tl V18359)) (= () (tl (tl V18359))))))) (hd (tl V18359))) ((= () V18358) V18359) ((and (cons? V18358) (and (cons? V18359) (and (cons? (tl V18359)) (and (= --> (hd (tl V18359))) (and (cons? (tl (tl V18359))) (= () (tl (tl (tl V18359))))))))) (shen.result-type (tl V18358) (hd (tl (tl V18359))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V18365 V18366 V18367 V18368 V18369) (let Case (let V17834 (shen.lazyderef V18365 V18368) (if (= () V17834) (do (shen.incinfs) (thaw V18369)) false)) (if (= Case false) (let V17835 (shen.lazyderef V18365 V18368) (if (cons? V17835) (let Pattern (hd V17835) (let Patterns (tl V17835) (let V17836 (shen.lazyderef V18366 V18368) (if (cons? V17836) (let A (hd V17836) (let V17837 (shen.lazyderef (tl V17836) V18368) (if (cons? V17837) (let V17838 (shen.lazyderef (hd V17837) V18368) (if (= --> V17838) (let V17839 (shen.lazyderef (tl V17837) V18368) (if (cons? V17839) (let B (hd V17839) (let V17840 (shen.lazyderef (tl V17839) V18368) (if (= () V17840) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V18367 V18368 (freeze (shen.t*-patterns Patterns B V18367 V18368 V18369)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V18375 V18376 V18377 V18378 V18379) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V17811 (shen.lazyderef V18375 V18378) (if (cons? V17811) (let V17812 (shen.lazyderef (hd V17811) V18378) (if (= where V17812) (let V17813 (shen.lazyderef (tl V17811) V18378) (if (cons? V17813) (let P (hd V17813) (let V17814 (shen.lazyderef (tl V17813) V18378) (if (cons? V17814) (let Action (hd V17814) (let V17815 (shen.lazyderef (tl V17814) V18378) (if (= () V17815) (do (shen.incinfs) (cut Throwcontrol V18378 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V18377 V18378 (freeze (cut Throwcontrol V18378 (freeze (shen.t*-action Action V18376 (cons (cons P (cons : (cons verified ()))) V18377) V18378 V18379)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V17816 (shen.lazyderef V18375 V18378) (if (cons? V17816) (let V17817 (shen.lazyderef (hd V17816) V18378) (if (= shen.choicepoint! V17817) (let V17818 (shen.lazyderef (tl V17816) V18378) (if (cons? V17818) (let V17819 (shen.lazyderef (hd V17818) V18378) (if (cons? V17819) (let V17820 (shen.lazyderef (hd V17819) V18378) (if (cons? V17820) (let V17821 (shen.lazyderef (hd V17820) V18378) (if (= fail-if V17821) (let V17822 (shen.lazyderef (tl V17820) V18378) (if (cons? V17822) (let F (hd V17822) (let V17823 (shen.lazyderef (tl V17822) V18378) (if (= () V17823) (let V17824 (shen.lazyderef (tl V17819) V18378) (if (cons? V17824) (let Action (hd V17824) (let V17825 (shen.lazyderef (tl V17824) V18378) (if (= () V17825) (let V17826 (shen.lazyderef (tl V17818) V18378) (if (= () V17826) (do (shen.incinfs) (cut Throwcontrol V18378 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V18376 V18377 V18378 V18379)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V17827 (shen.lazyderef V18375 V18378) (if (cons? V17827) (let V17828 (shen.lazyderef (hd V17827) V18378) (if (= shen.choicepoint! V17828) (let V17829 (shen.lazyderef (tl V17827) V18378) (if (cons? V17829) (let Action (hd V17829) (let V17830 (shen.lazyderef (tl V17829) V18378) (if (= () V17830) (do (shen.incinfs) (cut Throwcontrol V18378 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V18376 V18377 V18378 V18379)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V18375 (cons : (cons V18376 ()))) V18377 V18378 V18379)) Case)) Case)) Case)))))

(defun findall (V18385 V18386 V18387 V18388 V18389) (let B (shen.newpv V18388) (let A (shen.newpv V18388) (do (shen.incinfs) (bind A (gensym shen.a) V18388 (freeze (bind B (set (shen.lazyderef A V18388) ()) V18388 (freeze (shen.findallhelp V18385 V18386 V18387 A V18388 V18389)))))))))

(defun shen.findallhelp (V18396 V18397 V18398 V18399 V18400 V18401) (let Case (do (shen.incinfs) (call V18397 V18400 (freeze (shen.remember V18399 V18396 V18400 (freeze (fwhen false V18400 V18401)))))) (if (= Case false) (do (shen.incinfs) (bind V18398 (value (shen.lazyderef V18399 V18400)) V18400 V18401)) Case)))

(defun shen.remember (V18406 V18407 V18408 V18409) (let B (shen.newpv V18408) (do (shen.incinfs) (bind B (set (shen.deref V18406 V18408) (cons (shen.deref V18407 V18408) (value (shen.deref V18406 V18408)))) V18408 V18409))))



