"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V2028 V2029) (let Curry (shen.curry V2028) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2029)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2030) (cond ((and (cons? V2030) (shen.special? (hd V2030))) (cons (hd V2030) (map shen.curry (tl V2030)))) ((and (cons? V2030) (and (cons? (tl V2030)) (shen.extraspecial? (hd V2030)))) V2030) ((and (cons? V2030) (and (= type (hd V2030)) (and (cons? (tl V2030)) (and (cons? (tl (tl V2030))) (= () (tl (tl (tl V2030)))))))) (cons type (cons (shen.curry (hd (tl V2030))) (tl (tl V2030))))) ((and (cons? V2030) (and (cons? (tl V2030)) (cons? (tl (tl V2030))))) (shen.curry (cons (cons (hd V2030) (cons (hd (tl V2030)) ())) (tl (tl V2030))))) ((and (cons? V2030) (and (cons? (tl V2030)) (= () (tl (tl V2030))))) (cons (shen.curry (hd V2030)) (cons (shen.curry (hd (tl V2030))) ()))) (true V2030)))

(defun shen.special? (V2031) (element? V2031 (value shen.*special*)))

(defun shen.extraspecial? (V2032) (element? V2032 (value shen.*extraspecial*)))

(defun shen.t* (V2033 V2034 V2035 V2036) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2035) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2035 (freeze (bind Error (shen.errormaxinfs) V2035 V2036))))) (if (= Case false) (let Case (let V2022 (shen.lazyderef V2033 V2035) (if (= fail V2022) (do (shen.incinfs) (cut Throwcontrol V2035 (freeze (shen.prolog-failure V2035 V2036)))) false)) (if (= Case false) (let Case (let V2023 (shen.lazyderef V2033 V2035) (if (cons? V2023) (let X (hd V2023) (let V2024 (shen.lazyderef (tl V2023) V2035) (if (cons? V2024) (let V2025 (shen.lazyderef (hd V2024) V2035) (if (= : V2025) (let V2026 (shen.lazyderef (tl V2024) V2035) (if (cons? V2026) (let A (hd V2026) (let V2027 (shen.lazyderef (tl V2026) V2035) (if (= () V2027) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2035 (freeze (cut Throwcontrol V2035 (freeze (shen.th* X A V2034 V2035 V2036)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2035) (do (shen.incinfs) (shen.show V2033 V2034 V2035 (freeze (bind Datatypes (value shen.*datatypes*) V2035 (freeze (shen.udefs* V2033 V2034 Datatypes V2035 V2036))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2041) (cond ((= + V2041) (set shen.*shen-type-theory-enabled?* true)) ((= - V2041) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2050 V2051) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2052 V2053 V2054 V2055 V2056) (let Case (let V2018 (shen.lazyderef V2054 V2055) (if (cons? V2018) (let D (hd V2018) (do (shen.incinfs) (call (cons D (cons V2052 (cons V2053 ()))) V2055 V2056))) false)) (if (= Case false) (let V2019 (shen.lazyderef V2054 V2055) (if (cons? V2019) (let Ds (tl V2019) (do (shen.incinfs) (shen.udefs* V2052 V2053 Ds V2055 V2056))) false)) Case)))

(defun shen.th* (V2057 V2058 V2059 V2060 V2061) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2057 (cons : (cons V2058 ()))) V2059 V2060 (freeze (fwhen false V2060 V2061)))) (if (= Case false) (let Case (let F (shen.newpv V2060) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2057 V2060)) V2060 (freeze (bind F (shen.sigf (shen.lazyderef V2057 V2060)) V2060 (freeze (call (cons F (cons V2058 ())) V2060 V2061))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2057 V2058 V2060 V2061)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2057 V2058 V2059 V2060 V2061)) (if (= Case false) (let Case (let V1914 (shen.lazyderef V2057 V2060) (if (cons? V1914) (let F (hd V1914) (let V1915 (shen.lazyderef (tl V1914) V2060) (if (= () V1915) (do (shen.incinfs) (shen.th* F (cons --> (cons V2058 ())) V2059 V2060 V2061)) false))) false)) (if (= Case false) (let Case (let V1916 (shen.lazyderef V2057 V2060) (if (cons? V1916) (let F (hd V1916) (let V1917 (shen.lazyderef (tl V1916) V2060) (if (cons? V1917) (let X (hd V1917) (let V1918 (shen.lazyderef (tl V1917) V2060) (if (= () V1918) (let B (shen.newpv V2060) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2058 ()))) V2059 V2060 (freeze (shen.th* X B V2059 V2060 V2061))))) false))) false))) false)) (if (= Case false) (let Case (let V1919 (shen.lazyderef V2057 V2060) (if (cons? V1919) (let V1920 (shen.lazyderef (hd V1919) V2060) (if (= cons V1920) (let V1921 (shen.lazyderef (tl V1919) V2060) (if (cons? V1921) (let X (hd V1921) (let V1922 (shen.lazyderef (tl V1921) V2060) (if (cons? V1922) (let Y (hd V1922) (let V1923 (shen.lazyderef (tl V1922) V2060) (if (= () V1923) (let V1924 (shen.lazyderef V2058 V2060) (if (cons? V1924) (let V1925 (shen.lazyderef (hd V1924) V2060) (if (= list V1925) (let V1926 (shen.lazyderef (tl V1924) V2060) (if (cons? V1926) (let A (hd V1926) (let V1927 (shen.lazyderef (tl V1926) V2060) (if (= () V1927) (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (if (shen.pvar? V1927) (do (shen.bindv V1927 () V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1927 V2060) Result))) false)))) (if (shen.pvar? V1926) (let A (shen.newpv V2060) (do (shen.bindv V1926 (cons A ()) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1926 V2060) Result)))) false))) (if (shen.pvar? V1925) (do (shen.bindv V1925 list V2060) (let Result (let V1928 (shen.lazyderef (tl V1924) V2060) (if (cons? V1928) (let A (hd V1928) (let V1929 (shen.lazyderef (tl V1928) V2060) (if (= () V1929) (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (if (shen.pvar? V1929) (do (shen.bindv V1929 () V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1929 V2060) Result))) false)))) (if (shen.pvar? V1928) (let A (shen.newpv V2060) (do (shen.bindv V1928 (cons A ()) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1928 V2060) Result)))) false))) (do (shen.unbindv V1925 V2060) Result))) false))) (if (shen.pvar? V1924) (let A (shen.newpv V2060) (do (shen.bindv V1924 (cons list (cons A ())) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons list (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1924 V2060) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1930 (shen.lazyderef V2057 V2060) (if (cons? V1930) (let V1931 (shen.lazyderef (hd V1930) V2060) (if (= @p V1931) (let V1932 (shen.lazyderef (tl V1930) V2060) (if (cons? V1932) (let X (hd V1932) (let V1933 (shen.lazyderef (tl V1932) V2060) (if (cons? V1933) (let Y (hd V1933) (let V1934 (shen.lazyderef (tl V1933) V2060) (if (= () V1934) (let V1935 (shen.lazyderef V2058 V2060) (if (cons? V1935) (let A (hd V1935) (let V1936 (shen.lazyderef (tl V1935) V2060) (if (cons? V1936) (let V1937 (shen.lazyderef (hd V1936) V2060) (if (= * V1937) (let V1938 (shen.lazyderef (tl V1936) V2060) (if (cons? V1938) (let B (hd V1938) (let V1939 (shen.lazyderef (tl V1938) V2060) (if (= () V1939) (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (if (shen.pvar? V1939) (do (shen.bindv V1939 () V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (do (shen.unbindv V1939 V2060) Result))) false)))) (if (shen.pvar? V1938) (let B (shen.newpv V2060) (do (shen.bindv V1938 (cons B ()) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (do (shen.unbindv V1938 V2060) Result)))) false))) (if (shen.pvar? V1937) (do (shen.bindv V1937 * V2060) (let Result (let V1940 (shen.lazyderef (tl V1936) V2060) (if (cons? V1940) (let B (hd V1940) (let V1941 (shen.lazyderef (tl V1940) V2060) (if (= () V1941) (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (if (shen.pvar? V1941) (do (shen.bindv V1941 () V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (do (shen.unbindv V1941 V2060) Result))) false)))) (if (shen.pvar? V1940) (let B (shen.newpv V2060) (do (shen.bindv V1940 (cons B ()) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (do (shen.unbindv V1940 V2060) Result)))) false))) (do (shen.unbindv V1937 V2060) Result))) false))) (if (shen.pvar? V1936) (let B (shen.newpv V2060) (do (shen.bindv V1936 (cons * (cons B ())) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (do (shen.unbindv V1936 V2060) Result)))) false)))) (if (shen.pvar? V1935) (let A (shen.newpv V2060) (let B (shen.newpv V2060) (do (shen.bindv V1935 (cons A (cons * (cons B ()))) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y B V2059 V2060 V2061)))) (do (shen.unbindv V1935 V2060) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1942 (shen.lazyderef V2057 V2060) (if (cons? V1942) (let V1943 (shen.lazyderef (hd V1942) V2060) (if (= @v V1943) (let V1944 (shen.lazyderef (tl V1942) V2060) (if (cons? V1944) (let X (hd V1944) (let V1945 (shen.lazyderef (tl V1944) V2060) (if (cons? V1945) (let Y (hd V1945) (let V1946 (shen.lazyderef (tl V1945) V2060) (if (= () V1946) (let V1947 (shen.lazyderef V2058 V2060) (if (cons? V1947) (let V1948 (shen.lazyderef (hd V1947) V2060) (if (= vector V1948) (let V1949 (shen.lazyderef (tl V1947) V2060) (if (cons? V1949) (let A (hd V1949) (let V1950 (shen.lazyderef (tl V1949) V2060) (if (= () V1950) (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (if (shen.pvar? V1950) (do (shen.bindv V1950 () V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1950 V2060) Result))) false)))) (if (shen.pvar? V1949) (let A (shen.newpv V2060) (do (shen.bindv V1949 (cons A ()) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1949 V2060) Result)))) false))) (if (shen.pvar? V1948) (do (shen.bindv V1948 vector V2060) (let Result (let V1951 (shen.lazyderef (tl V1947) V2060) (if (cons? V1951) (let A (hd V1951) (let V1952 (shen.lazyderef (tl V1951) V2060) (if (= () V1952) (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (if (shen.pvar? V1952) (do (shen.bindv V1952 () V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1952 V2060) Result))) false)))) (if (shen.pvar? V1951) (let A (shen.newpv V2060) (do (shen.bindv V1951 (cons A ()) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1951 V2060) Result)))) false))) (do (shen.unbindv V1948 V2060) Result))) false))) (if (shen.pvar? V1947) (let A (shen.newpv V2060) (do (shen.bindv V1947 (cons vector (cons A ())) V2060) (let Result (do (shen.incinfs) (shen.th* X A V2059 V2060 (freeze (shen.th* Y (cons vector (cons A ())) V2059 V2060 V2061)))) (do (shen.unbindv V1947 V2060) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1953 (shen.lazyderef V2057 V2060) (if (cons? V1953) (let V1954 (shen.lazyderef (hd V1953) V2060) (if (= @s V1954) (let V1955 (shen.lazyderef (tl V1953) V2060) (if (cons? V1955) (let X (hd V1955) (let V1956 (shen.lazyderef (tl V1955) V2060) (if (cons? V1956) (let Y (hd V1956) (let V1957 (shen.lazyderef (tl V1956) V2060) (if (= () V1957) (let V1958 (shen.lazyderef V2058 V2060) (if (= string V1958) (do (shen.incinfs) (shen.th* X string V2059 V2060 (freeze (shen.th* Y string V2059 V2060 V2061)))) (if (shen.pvar? V1958) (do (shen.bindv V1958 string V2060) (let Result (do (shen.incinfs) (shen.th* X string V2059 V2060 (freeze (shen.th* Y string V2059 V2060 V2061)))) (do (shen.unbindv V1958 V2060) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1959 (shen.lazyderef V2057 V2060) (if (cons? V1959) (let V1960 (shen.lazyderef (hd V1959) V2060) (if (= lambda V1960) (let V1961 (shen.lazyderef (tl V1959) V2060) (if (cons? V1961) (let X (hd V1961) (let V1962 (shen.lazyderef (tl V1961) V2060) (if (cons? V1962) (let Y (hd V1962) (let V1963 (shen.lazyderef (tl V1962) V2060) (if (= () V1963) (let V1964 (shen.lazyderef V2058 V2060) (if (cons? V1964) (let A (hd V1964) (let V1965 (shen.lazyderef (tl V1964) V2060) (if (cons? V1965) (let V1966 (shen.lazyderef (hd V1965) V2060) (if (= --> V1966) (let V1967 (shen.lazyderef (tl V1965) V2060) (if (cons? V1967) (let B (hd V1967) (let V1968 (shen.lazyderef (tl V1967) V2060) (if (= () V1968) (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (if (shen.pvar? V1968) (do (shen.bindv V1968 () V2060) (let Result (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (do (shen.unbindv V1968 V2060) Result))) false)))) (if (shen.pvar? V1967) (let B (shen.newpv V2060) (do (shen.bindv V1967 (cons B ()) V2060) (let Result (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (do (shen.unbindv V1967 V2060) Result)))) false))) (if (shen.pvar? V1966) (do (shen.bindv V1966 --> V2060) (let Result (let V1969 (shen.lazyderef (tl V1965) V2060) (if (cons? V1969) (let B (hd V1969) (let V1970 (shen.lazyderef (tl V1969) V2060) (if (= () V1970) (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (if (shen.pvar? V1970) (do (shen.bindv V1970 () V2060) (let Result (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (do (shen.unbindv V1970 V2060) Result))) false)))) (if (shen.pvar? V1969) (let B (shen.newpv V2060) (do (shen.bindv V1969 (cons B ()) V2060) (let Result (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (do (shen.unbindv V1969 V2060) Result)))) false))) (do (shen.unbindv V1966 V2060) Result))) false))) (if (shen.pvar? V1965) (let B (shen.newpv V2060) (do (shen.bindv V1965 (cons --> (cons B ())) V2060) (let Result (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (do (shen.unbindv V1965 V2060) Result)))) false)))) (if (shen.pvar? V1964) (let A (shen.newpv V2060) (let B (shen.newpv V2060) (do (shen.bindv V1964 (cons A (cons --> (cons B ()))) V2060) (let Result (let Z (shen.newpv V2060) (let X&& (shen.newpv V2060) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Y V2060)) V2060 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2059) V2060 V2061)))))))))) (do (shen.unbindv V1964 V2060) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1971 (shen.lazyderef V2057 V2060) (if (cons? V1971) (let V1972 (shen.lazyderef (hd V1971) V2060) (if (= let V1972) (let V1973 (shen.lazyderef (tl V1971) V2060) (if (cons? V1973) (let X (hd V1973) (let V1974 (shen.lazyderef (tl V1973) V2060) (if (cons? V1974) (let Y (hd V1974) (let V1975 (shen.lazyderef (tl V1974) V2060) (if (cons? V1975) (let Z (hd V1975) (let V1976 (shen.lazyderef (tl V1975) V2060) (if (= () V1976) (let W (shen.newpv V2060) (let X&& (shen.newpv V2060) (let B (shen.newpv V2060) (do (shen.incinfs) (shen.th* Y B V2059 V2060 (freeze (bind X&& (shen.placeholder) V2060 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2060) (shen.lazyderef X V2060) (shen.lazyderef Z V2060)) V2060 (freeze (shen.th* W V2058 (cons (cons X&& (cons : (cons B ()))) V2059) V2060 V2061))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1977 (shen.lazyderef V2057 V2060) (if (cons? V1977) (let V1978 (shen.lazyderef (hd V1977) V2060) (if (= open V1978) (let V1979 (shen.lazyderef (tl V1977) V2060) (if (cons? V1979) (let FileName (hd V1979) (let V1980 (shen.lazyderef (tl V1979) V2060) (if (cons? V1980) (let Direction1910 (hd V1980) (let V1981 (shen.lazyderef (tl V1980) V2060) (if (= () V1981) (let V1982 (shen.lazyderef V2058 V2060) (if (cons? V1982) (let V1983 (shen.lazyderef (hd V1982) V2060) (if (= stream V1983) (let V1984 (shen.lazyderef (tl V1982) V2060) (if (cons? V1984) (let Direction (hd V1984) (let V1985 (shen.lazyderef (tl V1984) V2060) (if (= () V1985) (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (if (shen.pvar? V1985) (do (shen.bindv V1985 () V2060) (let Result (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (do (shen.unbindv V1985 V2060) Result))) false)))) (if (shen.pvar? V1984) (let Direction (shen.newpv V2060) (do (shen.bindv V1984 (cons Direction ()) V2060) (let Result (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (do (shen.unbindv V1984 V2060) Result)))) false))) (if (shen.pvar? V1983) (do (shen.bindv V1983 stream V2060) (let Result (let V1986 (shen.lazyderef (tl V1982) V2060) (if (cons? V1986) (let Direction (hd V1986) (let V1987 (shen.lazyderef (tl V1986) V2060) (if (= () V1987) (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (if (shen.pvar? V1987) (do (shen.bindv V1987 () V2060) (let Result (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (do (shen.unbindv V1987 V2060) Result))) false)))) (if (shen.pvar? V1986) (let Direction (shen.newpv V2060) (do (shen.bindv V1986 (cons Direction ()) V2060) (let Result (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (do (shen.unbindv V1986 V2060) Result)))) false))) (do (shen.unbindv V1983 V2060) Result))) false))) (if (shen.pvar? V1982) (let Direction (shen.newpv V2060) (do (shen.bindv V1982 (cons stream (cons Direction ())) V2060) (let Result (do (shen.incinfs) (unify! Direction Direction1910 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* FileName string V2059 V2060 V2061)))))) (do (shen.unbindv V1982 V2060) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1988 (shen.lazyderef V2057 V2060) (if (cons? V1988) (let V1989 (shen.lazyderef (hd V1988) V2060) (if (= type V1989) (let V1990 (shen.lazyderef (tl V1988) V2060) (if (cons? V1990) (let X (hd V1990) (let V1991 (shen.lazyderef (tl V1990) V2060) (if (cons? V1991) (let A (hd V1991) (let V1992 (shen.lazyderef (tl V1991) V2060) (if (= () V1992) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (unify A V2058 V2060 (freeze (shen.th* X A V2059 V2060 V2061)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1993 (shen.lazyderef V2057 V2060) (if (cons? V1993) (let V1994 (shen.lazyderef (hd V1993) V2060) (if (= input+ V1994) (let V1995 (shen.lazyderef (tl V1993) V2060) (if (cons? V1995) (let A (hd V1995) (let V1996 (shen.lazyderef (tl V1995) V2060) (if (cons? V1996) (let Stream (hd V1996) (let V1997 (shen.lazyderef (tl V1996) V2060) (if (= () V1997) (let C (shen.newpv V2060) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2060)) V2060 (freeze (unify V2058 C V2060 (freeze (shen.th* Stream (cons stream (cons in ())) V2059 V2060 V2061))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1998 (shen.lazyderef V2057 V2060) (if (cons? V1998) (let V1999 (shen.lazyderef (hd V1998) V2060) (if (= set V1999) (let V2000 (shen.lazyderef (tl V1998) V2060) (if (cons? V2000) (let Var (hd V2000) (let V2001 (shen.lazyderef (tl V2000) V2060) (if (cons? V2001) (let Val (hd V2001) (let V2002 (shen.lazyderef (tl V2001) V2060) (if (= () V2002) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (shen.th* Var symbol V2059 V2060 (freeze (cut Throwcontrol V2060 (freeze (shen.th* (cons value (cons Var ())) V2058 V2059 V2060 (freeze (shen.th* Val V2058 V2059 V2060 V2061)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2060) (do (shen.incinfs) (shen.t*-hyps V2059 NewHyp V2060 (freeze (shen.th* V2057 V2058 NewHyp V2060 V2061))))) (if (= Case false) (let Case (let V2003 (shen.lazyderef V2057 V2060) (if (cons? V2003) (let V2004 (shen.lazyderef (hd V2003) V2060) (if (= define V2004) (let V2005 (shen.lazyderef (tl V2003) V2060) (if (cons? V2005) (let F (hd V2005) (let X (tl V2005) (do (shen.incinfs) (cut Throwcontrol V2060 (freeze (shen.t*-def (cons define (cons F X)) V2058 V2059 V2060 V2061)))))) false)) false)) false)) (if (= Case false) (let Case (let V2006 (shen.lazyderef V2057 V2060) (if (cons? V2006) (let V2007 (shen.lazyderef (hd V2006) V2060) (if (= defmacro V2007) (let V2008 (shen.lazyderef V2058 V2060) (if (= unit V2008) (do (shen.incinfs) (cut Throwcontrol V2060 V2061)) (if (shen.pvar? V2008) (do (shen.bindv V2008 unit V2060) (let Result (do (shen.incinfs) (cut Throwcontrol V2060 V2061)) (do (shen.unbindv V2008 V2060) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2009 (shen.lazyderef V2057 V2060) (if (cons? V2009) (let V2010 (shen.lazyderef (hd V2009) V2060) (if (= shen.process-datatype V2010) (let V2011 (shen.lazyderef V2058 V2060) (if (= symbol V2011) (do (shen.incinfs) (thaw V2061)) (if (shen.pvar? V2011) (do (shen.bindv V2011 symbol V2060) (let Result (do (shen.incinfs) (thaw V2061)) (do (shen.unbindv V2011 V2060) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2012 (shen.lazyderef V2057 V2060) (if (cons? V2012) (let V2013 (shen.lazyderef (hd V2012) V2060) (if (= shen.synonyms-help V2013) (let V2014 (shen.lazyderef V2058 V2060) (if (= symbol V2014) (do (shen.incinfs) (thaw V2061)) (if (shen.pvar? V2014) (do (shen.bindv V2014 symbol V2060) (let Result (do (shen.incinfs) (thaw V2061)) (do (shen.unbindv V2014 V2060) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2060) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2060 (freeze (shen.udefs* (cons V2057 (cons : (cons V2058 ()))) V2059 Datatypes V2060 V2061))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2062 V2063 V2064 V2065) (let Case (let V1825 (shen.lazyderef V2062 V2064) (if (cons? V1825) (let V1826 (shen.lazyderef (hd V1825) V2064) (if (cons? V1826) (let V1827 (shen.lazyderef (hd V1826) V2064) (if (cons? V1827) (let V1828 (shen.lazyderef (hd V1827) V2064) (if (= cons V1828) (let V1829 (shen.lazyderef (tl V1827) V2064) (if (cons? V1829) (let X (hd V1829) (let V1830 (shen.lazyderef (tl V1829) V2064) (if (cons? V1830) (let Y (hd V1830) (let V1831 (shen.lazyderef (tl V1830) V2064) (if (= () V1831) (let V1832 (shen.lazyderef (tl V1826) V2064) (if (cons? V1832) (let V1833 (shen.lazyderef (hd V1832) V2064) (if (= : V1833) (let V1834 (shen.lazyderef (tl V1832) V2064) (if (cons? V1834) (let V1835 (shen.lazyderef (hd V1834) V2064) (if (cons? V1835) (let V1836 (shen.lazyderef (hd V1835) V2064) (if (= list V1836) (let V1837 (shen.lazyderef (tl V1835) V2064) (if (cons? V1837) (let A (hd V1837) (let V1838 (shen.lazyderef (tl V1837) V2064) (if (= () V1838) (let V1839 (shen.lazyderef (tl V1834) V2064) (if (= () V1839) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1839) (do (shen.bindv V1839 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1839 V2064) Result))) false))) (if (shen.pvar? V1838) (do (shen.bindv V1838 () V2064) (let Result (let V1840 (shen.lazyderef (tl V1834) V2064) (if (= () V1840) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1840) (do (shen.bindv V1840 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1840 V2064) Result))) false))) (do (shen.unbindv V1838 V2064) Result))) false)))) (if (shen.pvar? V1837) (let A (shen.newpv V2064) (do (shen.bindv V1837 (cons A ()) V2064) (let Result (let V1841 (shen.lazyderef (tl V1834) V2064) (if (= () V1841) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1841) (do (shen.bindv V1841 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1841 V2064) Result))) false))) (do (shen.unbindv V1837 V2064) Result)))) false))) (if (shen.pvar? V1836) (do (shen.bindv V1836 list V2064) (let Result (let V1842 (shen.lazyderef (tl V1835) V2064) (if (cons? V1842) (let A (hd V1842) (let V1843 (shen.lazyderef (tl V1842) V2064) (if (= () V1843) (let V1844 (shen.lazyderef (tl V1834) V2064) (if (= () V1844) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1844) (do (shen.bindv V1844 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1844 V2064) Result))) false))) (if (shen.pvar? V1843) (do (shen.bindv V1843 () V2064) (let Result (let V1845 (shen.lazyderef (tl V1834) V2064) (if (= () V1845) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1845) (do (shen.bindv V1845 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1845 V2064) Result))) false))) (do (shen.unbindv V1843 V2064) Result))) false)))) (if (shen.pvar? V1842) (let A (shen.newpv V2064) (do (shen.bindv V1842 (cons A ()) V2064) (let Result (let V1846 (shen.lazyderef (tl V1834) V2064) (if (= () V1846) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1846) (do (shen.bindv V1846 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1846 V2064) Result))) false))) (do (shen.unbindv V1842 V2064) Result)))) false))) (do (shen.unbindv V1836 V2064) Result))) false))) (if (shen.pvar? V1835) (let A (shen.newpv V2064) (do (shen.bindv V1835 (cons list (cons A ())) V2064) (let Result (let V1847 (shen.lazyderef (tl V1834) V2064) (if (= () V1847) (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1847) (do (shen.bindv V1847 () V2064) (let Result (let Hyp (tl V1825) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons list (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1847 V2064) Result))) false))) (do (shen.unbindv V1835 V2064) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1848 (shen.lazyderef V2062 V2064) (if (cons? V1848) (let V1849 (shen.lazyderef (hd V1848) V2064) (if (cons? V1849) (let V1850 (shen.lazyderef (hd V1849) V2064) (if (cons? V1850) (let V1851 (shen.lazyderef (hd V1850) V2064) (if (= @p V1851) (let V1852 (shen.lazyderef (tl V1850) V2064) (if (cons? V1852) (let X (hd V1852) (let V1853 (shen.lazyderef (tl V1852) V2064) (if (cons? V1853) (let Y (hd V1853) (let V1854 (shen.lazyderef (tl V1853) V2064) (if (= () V1854) (let V1855 (shen.lazyderef (tl V1849) V2064) (if (cons? V1855) (let V1856 (shen.lazyderef (hd V1855) V2064) (if (= : V1856) (let V1857 (shen.lazyderef (tl V1855) V2064) (if (cons? V1857) (let V1858 (shen.lazyderef (hd V1857) V2064) (if (cons? V1858) (let A (hd V1858) (let V1859 (shen.lazyderef (tl V1858) V2064) (if (cons? V1859) (let V1860 (shen.lazyderef (hd V1859) V2064) (if (= * V1860) (let V1861 (shen.lazyderef (tl V1859) V2064) (if (cons? V1861) (let B (hd V1861) (let V1862 (shen.lazyderef (tl V1861) V2064) (if (= () V1862) (let V1863 (shen.lazyderef (tl V1857) V2064) (if (= () V1863) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1863) (do (shen.bindv V1863 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1863 V2064) Result))) false))) (if (shen.pvar? V1862) (do (shen.bindv V1862 () V2064) (let Result (let V1864 (shen.lazyderef (tl V1857) V2064) (if (= () V1864) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1864) (do (shen.bindv V1864 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1864 V2064) Result))) false))) (do (shen.unbindv V1862 V2064) Result))) false)))) (if (shen.pvar? V1861) (let B (shen.newpv V2064) (do (shen.bindv V1861 (cons B ()) V2064) (let Result (let V1865 (shen.lazyderef (tl V1857) V2064) (if (= () V1865) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1865) (do (shen.bindv V1865 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1865 V2064) Result))) false))) (do (shen.unbindv V1861 V2064) Result)))) false))) (if (shen.pvar? V1860) (do (shen.bindv V1860 * V2064) (let Result (let V1866 (shen.lazyderef (tl V1859) V2064) (if (cons? V1866) (let B (hd V1866) (let V1867 (shen.lazyderef (tl V1866) V2064) (if (= () V1867) (let V1868 (shen.lazyderef (tl V1857) V2064) (if (= () V1868) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1868) (do (shen.bindv V1868 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1868 V2064) Result))) false))) (if (shen.pvar? V1867) (do (shen.bindv V1867 () V2064) (let Result (let V1869 (shen.lazyderef (tl V1857) V2064) (if (= () V1869) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1869) (do (shen.bindv V1869 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1869 V2064) Result))) false))) (do (shen.unbindv V1867 V2064) Result))) false)))) (if (shen.pvar? V1866) (let B (shen.newpv V2064) (do (shen.bindv V1866 (cons B ()) V2064) (let Result (let V1870 (shen.lazyderef (tl V1857) V2064) (if (= () V1870) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1870) (do (shen.bindv V1870 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1870 V2064) Result))) false))) (do (shen.unbindv V1866 V2064) Result)))) false))) (do (shen.unbindv V1860 V2064) Result))) false))) (if (shen.pvar? V1859) (let B (shen.newpv V2064) (do (shen.bindv V1859 (cons * (cons B ())) V2064) (let Result (let V1871 (shen.lazyderef (tl V1857) V2064) (if (= () V1871) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1871) (do (shen.bindv V1871 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1871 V2064) Result))) false))) (do (shen.unbindv V1859 V2064) Result)))) false)))) (if (shen.pvar? V1858) (let A (shen.newpv V2064) (let B (shen.newpv V2064) (do (shen.bindv V1858 (cons A (cons * (cons B ()))) V2064) (let Result (let V1872 (shen.lazyderef (tl V1857) V2064) (if (= () V1872) (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1872) (do (shen.bindv V1872 () V2064) (let Result (let Hyp (tl V1848) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (shen.lazyderef B V2064) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1872 V2064) Result))) false))) (do (shen.unbindv V1858 V2064) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1873 (shen.lazyderef V2062 V2064) (if (cons? V1873) (let V1874 (shen.lazyderef (hd V1873) V2064) (if (cons? V1874) (let V1875 (shen.lazyderef (hd V1874) V2064) (if (cons? V1875) (let V1876 (shen.lazyderef (hd V1875) V2064) (if (= @v V1876) (let V1877 (shen.lazyderef (tl V1875) V2064) (if (cons? V1877) (let X (hd V1877) (let V1878 (shen.lazyderef (tl V1877) V2064) (if (cons? V1878) (let Y (hd V1878) (let V1879 (shen.lazyderef (tl V1878) V2064) (if (= () V1879) (let V1880 (shen.lazyderef (tl V1874) V2064) (if (cons? V1880) (let V1881 (shen.lazyderef (hd V1880) V2064) (if (= : V1881) (let V1882 (shen.lazyderef (tl V1880) V2064) (if (cons? V1882) (let V1883 (shen.lazyderef (hd V1882) V2064) (if (cons? V1883) (let V1884 (shen.lazyderef (hd V1883) V2064) (if (= vector V1884) (let V1885 (shen.lazyderef (tl V1883) V2064) (if (cons? V1885) (let A (hd V1885) (let V1886 (shen.lazyderef (tl V1885) V2064) (if (= () V1886) (let V1887 (shen.lazyderef (tl V1882) V2064) (if (= () V1887) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1887) (do (shen.bindv V1887 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1887 V2064) Result))) false))) (if (shen.pvar? V1886) (do (shen.bindv V1886 () V2064) (let Result (let V1888 (shen.lazyderef (tl V1882) V2064) (if (= () V1888) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1888) (do (shen.bindv V1888 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1888 V2064) Result))) false))) (do (shen.unbindv V1886 V2064) Result))) false)))) (if (shen.pvar? V1885) (let A (shen.newpv V2064) (do (shen.bindv V1885 (cons A ()) V2064) (let Result (let V1889 (shen.lazyderef (tl V1882) V2064) (if (= () V1889) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1889) (do (shen.bindv V1889 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1889 V2064) Result))) false))) (do (shen.unbindv V1885 V2064) Result)))) false))) (if (shen.pvar? V1884) (do (shen.bindv V1884 vector V2064) (let Result (let V1890 (shen.lazyderef (tl V1883) V2064) (if (cons? V1890) (let A (hd V1890) (let V1891 (shen.lazyderef (tl V1890) V2064) (if (= () V1891) (let V1892 (shen.lazyderef (tl V1882) V2064) (if (= () V1892) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1892) (do (shen.bindv V1892 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1892 V2064) Result))) false))) (if (shen.pvar? V1891) (do (shen.bindv V1891 () V2064) (let Result (let V1893 (shen.lazyderef (tl V1882) V2064) (if (= () V1893) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1893) (do (shen.bindv V1893 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1893 V2064) Result))) false))) (do (shen.unbindv V1891 V2064) Result))) false)))) (if (shen.pvar? V1890) (let A (shen.newpv V2064) (do (shen.bindv V1890 (cons A ()) V2064) (let Result (let V1894 (shen.lazyderef (tl V1882) V2064) (if (= () V1894) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1894) (do (shen.bindv V1894 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1894 V2064) Result))) false))) (do (shen.unbindv V1890 V2064) Result)))) false))) (do (shen.unbindv V1884 V2064) Result))) false))) (if (shen.pvar? V1883) (let A (shen.newpv V2064) (do (shen.bindv V1883 (cons vector (cons A ())) V2064) (let Result (let V1895 (shen.lazyderef (tl V1882) V2064) (if (= () V1895) (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1895) (do (shen.bindv V1895 () V2064) (let Result (let Hyp (tl V1873) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons (shen.lazyderef A V2064) ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons (cons vector (cons (shen.lazyderef A V2064) ())) ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1895 V2064) Result))) false))) (do (shen.unbindv V1883 V2064) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1896 (shen.lazyderef V2062 V2064) (if (cons? V1896) (let V1897 (shen.lazyderef (hd V1896) V2064) (if (cons? V1897) (let V1898 (shen.lazyderef (hd V1897) V2064) (if (cons? V1898) (let V1899 (shen.lazyderef (hd V1898) V2064) (if (= @s V1899) (let V1900 (shen.lazyderef (tl V1898) V2064) (if (cons? V1900) (let X (hd V1900) (let V1901 (shen.lazyderef (tl V1900) V2064) (if (cons? V1901) (let Y (hd V1901) (let V1902 (shen.lazyderef (tl V1901) V2064) (if (= () V1902) (let V1903 (shen.lazyderef (tl V1897) V2064) (if (cons? V1903) (let V1904 (shen.lazyderef (hd V1903) V2064) (if (= : V1904) (let V1905 (shen.lazyderef (tl V1903) V2064) (if (cons? V1905) (let V1906 (shen.lazyderef (hd V1905) V2064) (if (= string V1906) (let V1907 (shen.lazyderef (tl V1905) V2064) (if (= () V1907) (let Hyp (tl V1896) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons string ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1907) (do (shen.bindv V1907 () V2064) (let Result (let Hyp (tl V1896) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons string ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1907 V2064) Result))) false))) (if (shen.pvar? V1906) (do (shen.bindv V1906 string V2064) (let Result (let V1908 (shen.lazyderef (tl V1905) V2064) (if (= () V1908) (let Hyp (tl V1896) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons string ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (if (shen.pvar? V1908) (do (shen.bindv V1908 () V2064) (let Result (let Hyp (tl V1896) (do (shen.incinfs) (bind V2063 (cons (cons (shen.lazyderef X V2064) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2064) (cons : (cons string ()))) (shen.lazyderef Hyp V2064))) V2064 V2065))) (do (shen.unbindv V1908 V2064) Result))) false))) (do (shen.unbindv V1906 V2064) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V1909 (shen.lazyderef V2062 V2064) (if (cons? V1909) (let X (hd V1909) (let Hyp (tl V1909) (let NewHyps (shen.newpv V2064) (do (shen.incinfs) (bind V2063 (cons (shen.lazyderef X V2064) (shen.lazyderef NewHyps V2064)) V2064 (freeze (shen.t*-hyps Hyp NewHyps V2064 V2065))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2078 V2079 V2080 V2081) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2078 V2080)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2079 V2080) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2081))))))))) (true (thaw V2081))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2082) (cond ((and (cons? V2082) (and (cons? (tl V2082)) (and (= : (hd (tl V2082))) (and (cons? (tl (tl V2082))) (= () (tl (tl (tl V2082)))))))) (shen.prhush (shen.app (hd V2082) (cn " : " (shen.app (hd (tl (tl V2082))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2082 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2085 V2086) (cond ((= () V2085) shen.skip) ((cons? V2085) (do (shen.prhush (shen.app V2086 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2085)) (do (nl 1) (shen.show-assumptions (tl V2085) (+ V2086 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2087) (cons? (assoc V2087 (value shen.*signedfuncs*))))

(defun shen.sigf (V2088) (concat shen.type-signature-of- V2088))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2089 V2090 V2091 V2092) (let Case (let V1812 (shen.lazyderef V2090 V2091) (if (= number V1812) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2089 V2091)) V2091 V2092)) (if (shen.pvar? V1812) (do (shen.bindv V1812 number V2091) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2089 V2091)) V2091 V2092)) (do (shen.unbindv V1812 V2091) Result))) false))) (if (= Case false) (let Case (let V1813 (shen.lazyderef V2090 V2091) (if (= boolean V1813) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2089 V2091)) V2091 V2092)) (if (shen.pvar? V1813) (do (shen.bindv V1813 boolean V2091) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2089 V2091)) V2091 V2092)) (do (shen.unbindv V1813 V2091) Result))) false))) (if (= Case false) (let Case (let V1814 (shen.lazyderef V2090 V2091) (if (= string V1814) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2089 V2091)) V2091 V2092)) (if (shen.pvar? V1814) (do (shen.bindv V1814 string V2091) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2089 V2091)) V2091 V2092)) (do (shen.unbindv V1814 V2091) Result))) false))) (if (= Case false) (let Case (let V1815 (shen.lazyderef V2090 V2091) (if (= symbol V1815) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2089 V2091)) V2091 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2089 V2091))) V2091 V2092)))) (if (shen.pvar? V1815) (do (shen.bindv V1815 symbol V2091) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2089 V2091)) V2091 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2089 V2091))) V2091 V2092)))) (do (shen.unbindv V1815 V2091) Result))) false))) (if (= Case false) (let V1816 (shen.lazyderef V2089 V2091) (if (= () V1816) (let V1817 (shen.lazyderef V2090 V2091) (if (cons? V1817) (let V1818 (shen.lazyderef (hd V1817) V2091) (if (= list V1818) (let V1819 (shen.lazyderef (tl V1817) V2091) (if (cons? V1819) (let A (hd V1819) (let V1820 (shen.lazyderef (tl V1819) V2091) (if (= () V1820) (do (shen.incinfs) (thaw V2092)) (if (shen.pvar? V1820) (do (shen.bindv V1820 () V2091) (let Result (do (shen.incinfs) (thaw V2092)) (do (shen.unbindv V1820 V2091) Result))) false)))) (if (shen.pvar? V1819) (let A (shen.newpv V2091) (do (shen.bindv V1819 (cons A ()) V2091) (let Result (do (shen.incinfs) (thaw V2092)) (do (shen.unbindv V1819 V2091) Result)))) false))) (if (shen.pvar? V1818) (do (shen.bindv V1818 list V2091) (let Result (let V1821 (shen.lazyderef (tl V1817) V2091) (if (cons? V1821) (let A (hd V1821) (let V1822 (shen.lazyderef (tl V1821) V2091) (if (= () V1822) (do (shen.incinfs) (thaw V2092)) (if (shen.pvar? V1822) (do (shen.bindv V1822 () V2091) (let Result (do (shen.incinfs) (thaw V2092)) (do (shen.unbindv V1822 V2091) Result))) false)))) (if (shen.pvar? V1821) (let A (shen.newpv V2091) (do (shen.bindv V1821 (cons A ()) V2091) (let Result (do (shen.incinfs) (thaw V2092)) (do (shen.unbindv V1821 V2091) Result)))) false))) (do (shen.unbindv V1818 V2091) Result))) false))) (if (shen.pvar? V1817) (let A (shen.newpv V2091) (do (shen.bindv V1817 (cons list (cons A ())) V2091) (let Result (do (shen.incinfs) (thaw V2092)) (do (shen.unbindv V1817 V2091) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2093 V2094 V2095 V2096 V2097) (let Case (let V1803 (shen.lazyderef V2095 V2096) (if (cons? V1803) (let V1804 (shen.lazyderef (hd V1803) V2096) (if (cons? V1804) (let Y (hd V1804) (let V1805 (shen.lazyderef (tl V1804) V2096) (if (cons? V1805) (let V1806 (shen.lazyderef (hd V1805) V2096) (if (= : V1806) (let V1807 (shen.lazyderef (tl V1805) V2096) (if (cons? V1807) (let B (hd V1807) (let V1808 (shen.lazyderef (tl V1807) V2096) (if (= () V1808) (do (shen.incinfs) (identical V2093 Y V2096 (freeze (unify! V2094 B V2096 V2097)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V1809 (shen.lazyderef V2095 V2096) (if (cons? V1809) (let Hyp (tl V1809) (do (shen.incinfs) (shen.by_hypothesis V2093 V2094 Hyp V2096 V2097))) false)) Case)))

(defun shen.t*-def (V2098 V2099 V2100 V2101 V2102) (let V1797 (shen.lazyderef V2098 V2101) (if (cons? V1797) (let V1798 (shen.lazyderef (hd V1797) V2101) (if (= define V1798) (let V1799 (shen.lazyderef (tl V1797) V2101) (if (cons? V1799) (let F (hd V1799) (let X (tl V1799) (let E (shen.newpv V2101) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2099 V2100 V2101 V2102))))) false)) false)) false)))

(defun shen.t*-defh (V2103 V2104 V2105 V2106 V2107 V2108) (let V1793 (shen.lazyderef V2103 V2107) (if (cons? V1793) (let Sig (hd V1793) (let Rules (tl V1793) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2104 V2105 V2106 Rules V2107 V2108)))) false)))

(defun shen.t*-defhh (V2109 V2110 V2111 V2112 V2113 V2114 V2115 V2116) (do (shen.incinfs) (shen.t*-rules V2114 V2110 1 V2111 (cons (cons V2111 (cons : (cons V2110 ()))) V2113) V2115 (freeze (shen.memo V2111 V2109 V2112 V2115 V2116)))))

(defun shen.memo (V2117 V2118 V2119 V2120 V2121) (let Jnk (shen.newpv V2120) (do (shen.incinfs) (unify! V2119 V2118 V2120 (freeze (bind Jnk (declare (shen.lazyderef V2117 V2120) (shen.lazyderef V2119 V2120)) V2120 V2121))))))

(defun shen.<sig+rules> (V2122) (let Parse_shen.<signature> (shen.<signature> V2122) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2123) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2123) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2123) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2124) (cond ((and (cons? V2124) (and (cons? (tl V2124)) (and (= () (tl (tl V2124))) (= (hd V2124) protect)))) V2124) ((cons? V2124) (map shen.ue V2124)) ((variable? V2124) (concat && V2124)) (true V2124)))

(defun shen.ue-sig (V2125) (cond ((cons? V2125) (map shen.ue-sig V2125)) ((variable? V2125) (concat &&& V2125)) (true V2125)))

(defun shen.ues (V2130) (cond ((shen.ue? V2130) (cons V2130 ())) ((cons? V2130) (union (shen.ues (hd V2130)) (shen.ues (tl V2130)))) (true ())))

(defun shen.ue? (V2131) (and (symbol? V2131) (shen.ue-h? (str V2131))))

(defun shen.ue-h? (V2138) (cond ((and (shen.+string? V2138) (and (= "&" (pos V2138 0)) (and (shen.+string? (tlstr V2138)) (= "&" (pos (tlstr V2138) 0))))) true) (true false)))

(defun shen.t*-rules (V2139 V2140 V2141 V2142 V2143 V2144 V2145) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1777 (shen.lazyderef V2139 V2144) (if (= () V1777) (do (shen.incinfs) (thaw V2145)) false)) (if (= Case false) (let Case (let V1778 (shen.lazyderef V2139 V2144) (if (cons? V1778) (let Rule (hd V1778) (let Rules (tl V1778) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2140 V2143 V2144 (freeze (cut Throwcontrol V2144 (freeze (shen.t*-rules Rules V2140 (+ V2141 1) V2142 V2143 V2144 V2145)))))))) false)) (if (= Case false) (let Err (shen.newpv V2144) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2141 V2144) (cn " of " (shen.app (shen.lazyderef V2142 V2144) "" shen.a)) shen.a))) V2144 V2145))) Case)) Case)))))

(defun shen.t*-rule (V2146 V2147 V2148 V2149 V2150) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V1769 (shen.lazyderef V2146 V2149) (if (cons? V1769) (let Patterns (hd V1769) (let V1770 (shen.lazyderef (tl V1769) V2149) (if (cons? V1770) (let Action (hd V1770) (let V1771 (shen.lazyderef (tl V1770) V2149) (if (= () V1771) (let NewHyps (shen.newpv V2149) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2148 NewHyps V2149 (freeze (shen.t*-patterns Patterns V2147 NewHyps V2149 (freeze (cut Throwcontrol V2149 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2147) (shen.patthyps Patterns V2147 V2148) V2149 V2150))))))))) false))) false))) false)))))

(defun shen.placeholders (V2155) (cond ((shen.ue? V2155) (cons V2155 ())) ((cons? V2155) (union (shen.placeholders (hd V2155)) (shen.placeholders (tl V2155)))) (true ())))

(defun shen.newhyps (V2156 V2157 V2158 V2159 V2160) (let Case (let V1756 (shen.lazyderef V2156 V2159) (if (= () V1756) (do (shen.incinfs) (unify! V2158 V2157 V2159 V2160)) false)) (if (= Case false) (let V1757 (shen.lazyderef V2156 V2159) (if (cons? V1757) (let V1752 (hd V1757) (let Vs (tl V1757) (let V1758 (shen.lazyderef V2158 V2159) (if (cons? V1758) (let V1759 (shen.lazyderef (hd V1758) V2159) (if (cons? V1759) (let V (hd V1759) (let V1760 (shen.lazyderef (tl V1759) V2159) (if (cons? V1760) (let V1761 (shen.lazyderef (hd V1760) V2159) (if (= : V1761) (let V1762 (shen.lazyderef (tl V1760) V2159) (if (cons? V1762) (let A (hd V1762) (let V1763 (shen.lazyderef (tl V1762) V2159) (if (= () V1763) (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (if (shen.pvar? V1763) (do (shen.bindv V1763 () V2159) (let Result (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (do (shen.unbindv V1763 V2159) Result))) false)))) (if (shen.pvar? V1762) (let A (shen.newpv V2159) (do (shen.bindv V1762 (cons A ()) V2159) (let Result (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (do (shen.unbindv V1762 V2159) Result)))) false))) (if (shen.pvar? V1761) (do (shen.bindv V1761 : V2159) (let Result (let V1764 (shen.lazyderef (tl V1760) V2159) (if (cons? V1764) (let A (hd V1764) (let V1765 (shen.lazyderef (tl V1764) V2159) (if (= () V1765) (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (if (shen.pvar? V1765) (do (shen.bindv V1765 () V2159) (let Result (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (do (shen.unbindv V1765 V2159) Result))) false)))) (if (shen.pvar? V1764) (let A (shen.newpv V2159) (do (shen.bindv V1764 (cons A ()) V2159) (let Result (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (do (shen.unbindv V1764 V2159) Result)))) false))) (do (shen.unbindv V1761 V2159) Result))) false))) (if (shen.pvar? V1760) (let A (shen.newpv V2159) (do (shen.bindv V1760 (cons : (cons A ())) V2159) (let Result (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (do (shen.unbindv V1760 V2159) Result)))) false)))) (if (shen.pvar? V1759) (let V (shen.newpv V2159) (let A (shen.newpv V2159) (do (shen.bindv V1759 (cons V (cons : (cons A ()))) V2159) (let Result (let NewHyp (tl V1758) (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160))))) (do (shen.unbindv V1759 V2159) Result))))) false))) (if (shen.pvar? V1758) (let V (shen.newpv V2159) (let A (shen.newpv V2159) (let NewHyp (shen.newpv V2159) (do (shen.bindv V1758 (cons (cons V (cons : (cons A ()))) NewHyp) V2159) (let Result (do (shen.incinfs) (unify! V V1752 V2159 (freeze (shen.newhyps Vs V2157 NewHyp V2159 V2160)))) (do (shen.unbindv V1758 V2159) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2163 V2164 V2165) (cond ((= () V2163) V2165) ((and (cons? V2163) (and (cons? V2164) (and (cons? (tl V2164)) (and (= --> (hd (tl V2164))) (and (cons? (tl (tl V2164))) (= () (tl (tl (tl V2164))))))))) (adjoin (cons (hd V2163) (cons : (cons (hd V2164) ()))) (shen.patthyps (tl V2163) (hd (tl (tl V2164))) V2165))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2170 V2171) (cond ((= () V2170) V2171) ((and (cons? V2170) (and (cons? V2171) (and (cons? (tl V2171)) (and (= --> (hd (tl V2171))) (and (cons? (tl (tl V2171))) (= () (tl (tl (tl V2171))))))))) (shen.result-type (tl V2170) (hd (tl (tl V2171))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2172 V2173 V2174 V2175 V2176) (let Case (let V1744 (shen.lazyderef V2172 V2175) (if (= () V1744) (do (shen.incinfs) (thaw V2176)) false)) (if (= Case false) (let V1745 (shen.lazyderef V2172 V2175) (if (cons? V1745) (let Pattern (hd V1745) (let Patterns (tl V1745) (let V1746 (shen.lazyderef V2173 V2175) (if (cons? V1746) (let A (hd V1746) (let V1747 (shen.lazyderef (tl V1746) V2175) (if (cons? V1747) (let V1748 (shen.lazyderef (hd V1747) V2175) (if (= --> V1748) (let V1749 (shen.lazyderef (tl V1747) V2175) (if (cons? V1749) (let B (hd V1749) (let V1750 (shen.lazyderef (tl V1749) V2175) (if (= () V1750) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V2174 V2175 (freeze (shen.t*-patterns Patterns B V2174 V2175 V2176)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2177 V2178 V2179 V2180 V2181) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1721 (shen.lazyderef V2177 V2180) (if (cons? V1721) (let V1722 (shen.lazyderef (hd V1721) V2180) (if (= where V1722) (let V1723 (shen.lazyderef (tl V1721) V2180) (if (cons? V1723) (let P (hd V1723) (let V1724 (shen.lazyderef (tl V1723) V2180) (if (cons? V1724) (let Action (hd V1724) (let V1725 (shen.lazyderef (tl V1724) V2180) (if (= () V1725) (do (shen.incinfs) (cut Throwcontrol V2180 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2179 V2180 (freeze (cut Throwcontrol V2180 (freeze (shen.t*-action Action V2178 (cons (cons P (cons : (cons verified ()))) V2179) V2180 V2181)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1726 (shen.lazyderef V2177 V2180) (if (cons? V1726) (let V1727 (shen.lazyderef (hd V1726) V2180) (if (= shen.choicepoint! V1727) (let V1728 (shen.lazyderef (tl V1726) V2180) (if (cons? V1728) (let V1729 (shen.lazyderef (hd V1728) V2180) (if (cons? V1729) (let V1730 (shen.lazyderef (hd V1729) V2180) (if (cons? V1730) (let V1731 (shen.lazyderef (hd V1730) V2180) (if (= fail-if V1731) (let V1732 (shen.lazyderef (tl V1730) V2180) (if (cons? V1732) (let F (hd V1732) (let V1733 (shen.lazyderef (tl V1732) V2180) (if (= () V1733) (let V1734 (shen.lazyderef (tl V1729) V2180) (if (cons? V1734) (let Action (hd V1734) (let V1735 (shen.lazyderef (tl V1734) V2180) (if (= () V1735) (let V1736 (shen.lazyderef (tl V1728) V2180) (if (= () V1736) (do (shen.incinfs) (cut Throwcontrol V2180 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2178 V2179 V2180 V2181)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1737 (shen.lazyderef V2177 V2180) (if (cons? V1737) (let V1738 (shen.lazyderef (hd V1737) V2180) (if (= shen.choicepoint! V1738) (let V1739 (shen.lazyderef (tl V1737) V2180) (if (cons? V1739) (let Action (hd V1739) (let V1740 (shen.lazyderef (tl V1739) V2180) (if (= () V1740) (do (shen.incinfs) (cut Throwcontrol V2180 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2178 V2179 V2180 V2181)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2177 (cons : (cons V2178 ()))) V2179 V2180 V2181)) Case)) Case)) Case)))))

(defun findall (V2182 V2183 V2184 V2185 V2186) (let B (shen.newpv V2185) (let A (shen.newpv V2185) (do (shen.incinfs) (bind A (gensym shen.a) V2185 (freeze (bind B (set (shen.lazyderef A V2185) ()) V2185 (freeze (shen.findallhelp V2182 V2183 V2184 A V2185 V2186)))))))))

(defun shen.findallhelp (V2187 V2188 V2189 V2190 V2191 V2192) (let Case (do (shen.incinfs) (call V2188 V2191 (freeze (shen.remember V2190 V2187 V2191 (freeze (fwhen false V2191 V2192)))))) (if (= Case false) (do (shen.incinfs) (bind V2189 (value (shen.lazyderef V2190 V2191)) V2191 V2192)) Case)))

(defun shen.remember (V2193 V2194 V2195 V2196) (let B (shen.newpv V2195) (do (shen.incinfs) (bind B (set (shen.deref V2193 V2195) (cons (shen.deref V2194 V2195) (value (shen.deref V2193 V2195)))) V2195 V2196))))



