"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V2068 V2069) (let Curry (shen.curry V2068) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2069)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2070) (cond ((and (cons? V2070) (shen.special? (hd V2070))) (cons (hd V2070) (map (lambda V1745 (shen.curry V1745)) (tl V2070)))) ((and (cons? V2070) (and (cons? (tl V2070)) (shen.extraspecial? (hd V2070)))) V2070) ((and (cons? V2070) (and (= type (hd V2070)) (and (cons? (tl V2070)) (and (cons? (tl (tl V2070))) (= () (tl (tl (tl V2070)))))))) (cons type (cons (shen.curry (hd (tl V2070))) (tl (tl V2070))))) ((and (cons? V2070) (and (cons? (tl V2070)) (cons? (tl (tl V2070))))) (shen.curry (cons (cons (hd V2070) (cons (hd (tl V2070)) ())) (tl (tl V2070))))) ((and (cons? V2070) (and (cons? (tl V2070)) (= () (tl (tl V2070))))) (cons (shen.curry (hd V2070)) (cons (shen.curry (hd (tl V2070))) ()))) (true V2070)))

(defun shen.special? (V2071) (element? V2071 (value shen.*special*)))

(defun shen.extraspecial? (V2072) (element? V2072 (value shen.*extraspecial*)))

(defun shen.t* (V2073 V2074 V2075 V2076) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2075) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2075 (freeze (bind Error (shen.errormaxinfs) V2075 V2076))))) (if (= Case false) (let Case (let V2062 (shen.lazyderef V2073 V2075) (if (= fail V2062) (do (shen.incinfs) (cut Throwcontrol V2075 (freeze (shen.prolog-failure V2075 V2076)))) false)) (if (= Case false) (let Case (let V2063 (shen.lazyderef V2073 V2075) (if (cons? V2063) (let X (hd V2063) (let V2064 (shen.lazyderef (tl V2063) V2075) (if (cons? V2064) (let V2065 (shen.lazyderef (hd V2064) V2075) (if (= : V2065) (let V2066 (shen.lazyderef (tl V2064) V2075) (if (cons? V2066) (let A (hd V2066) (let V2067 (shen.lazyderef (tl V2066) V2075) (if (= () V2067) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2075 (freeze (cut Throwcontrol V2075 (freeze (shen.th* X A V2074 V2075 V2076)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2075) (do (shen.incinfs) (shen.show V2073 V2074 V2075 (freeze (bind Datatypes (value shen.*datatypes*) V2075 (freeze (shen.udefs* V2073 V2074 Datatypes V2075 V2076))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2081) (cond ((= + V2081) (set shen.*shen-type-theory-enabled?* true)) ((= - V2081) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2090 V2091) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2092 V2093 V2094 V2095 V2096) (let Case (let V2058 (shen.lazyderef V2094 V2095) (if (cons? V2058) (let D (hd V2058) (do (shen.incinfs) (call (cons D (cons V2092 (cons V2093 ()))) V2095 V2096))) false)) (if (= Case false) (let V2059 (shen.lazyderef V2094 V2095) (if (cons? V2059) (let Ds (tl V2059) (do (shen.incinfs) (shen.udefs* V2092 V2093 Ds V2095 V2096))) false)) Case)))

(defun shen.th* (V2097 V2098 V2099 V2100 V2101) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2097 (cons : (cons V2098 ()))) V2099 V2100 (freeze (fwhen false V2100 V2101)))) (if (= Case false) (let Case (let F (shen.newpv V2100) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2097 V2100)) V2100 (freeze (bind F (shen.sigf (shen.lazyderef V2097 V2100)) V2100 (freeze (call (cons F (cons V2098 ())) V2100 V2101))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2097 V2098 V2100 V2101)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2097 V2098 V2099 V2100 V2101)) (if (= Case false) (let Case (let V1954 (shen.lazyderef V2097 V2100) (if (cons? V1954) (let F (hd V1954) (let V1955 (shen.lazyderef (tl V1954) V2100) (if (= () V1955) (do (shen.incinfs) (shen.th* F (cons --> (cons V2098 ())) V2099 V2100 V2101)) false))) false)) (if (= Case false) (let Case (let V1956 (shen.lazyderef V2097 V2100) (if (cons? V1956) (let F (hd V1956) (let V1957 (shen.lazyderef (tl V1956) V2100) (if (cons? V1957) (let X (hd V1957) (let V1958 (shen.lazyderef (tl V1957) V2100) (if (= () V1958) (let B (shen.newpv V2100) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2098 ()))) V2099 V2100 (freeze (shen.th* X B V2099 V2100 V2101))))) false))) false))) false)) (if (= Case false) (let Case (let V1959 (shen.lazyderef V2097 V2100) (if (cons? V1959) (let V1960 (shen.lazyderef (hd V1959) V2100) (if (= cons V1960) (let V1961 (shen.lazyderef (tl V1959) V2100) (if (cons? V1961) (let X (hd V1961) (let V1962 (shen.lazyderef (tl V1961) V2100) (if (cons? V1962) (let Y (hd V1962) (let V1963 (shen.lazyderef (tl V1962) V2100) (if (= () V1963) (let V1964 (shen.lazyderef V2098 V2100) (if (cons? V1964) (let V1965 (shen.lazyderef (hd V1964) V2100) (if (= list V1965) (let V1966 (shen.lazyderef (tl V1964) V2100) (if (cons? V1966) (let A (hd V1966) (let V1967 (shen.lazyderef (tl V1966) V2100) (if (= () V1967) (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (if (shen.pvar? V1967) (do (shen.bindv V1967 () V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1967 V2100) Result))) false)))) (if (shen.pvar? V1966) (let A (shen.newpv V2100) (do (shen.bindv V1966 (cons A ()) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1966 V2100) Result)))) false))) (if (shen.pvar? V1965) (do (shen.bindv V1965 list V2100) (let Result (let V1968 (shen.lazyderef (tl V1964) V2100) (if (cons? V1968) (let A (hd V1968) (let V1969 (shen.lazyderef (tl V1968) V2100) (if (= () V1969) (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (if (shen.pvar? V1969) (do (shen.bindv V1969 () V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1969 V2100) Result))) false)))) (if (shen.pvar? V1968) (let A (shen.newpv V2100) (do (shen.bindv V1968 (cons A ()) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1968 V2100) Result)))) false))) (do (shen.unbindv V1965 V2100) Result))) false))) (if (shen.pvar? V1964) (let A (shen.newpv V2100) (do (shen.bindv V1964 (cons list (cons A ())) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons list (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1964 V2100) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1970 (shen.lazyderef V2097 V2100) (if (cons? V1970) (let V1971 (shen.lazyderef (hd V1970) V2100) (if (= @p V1971) (let V1972 (shen.lazyderef (tl V1970) V2100) (if (cons? V1972) (let X (hd V1972) (let V1973 (shen.lazyderef (tl V1972) V2100) (if (cons? V1973) (let Y (hd V1973) (let V1974 (shen.lazyderef (tl V1973) V2100) (if (= () V1974) (let V1975 (shen.lazyderef V2098 V2100) (if (cons? V1975) (let A (hd V1975) (let V1976 (shen.lazyderef (tl V1975) V2100) (if (cons? V1976) (let V1977 (shen.lazyderef (hd V1976) V2100) (if (= * V1977) (let V1978 (shen.lazyderef (tl V1976) V2100) (if (cons? V1978) (let B (hd V1978) (let V1979 (shen.lazyderef (tl V1978) V2100) (if (= () V1979) (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (if (shen.pvar? V1979) (do (shen.bindv V1979 () V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (do (shen.unbindv V1979 V2100) Result))) false)))) (if (shen.pvar? V1978) (let B (shen.newpv V2100) (do (shen.bindv V1978 (cons B ()) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (do (shen.unbindv V1978 V2100) Result)))) false))) (if (shen.pvar? V1977) (do (shen.bindv V1977 * V2100) (let Result (let V1980 (shen.lazyderef (tl V1976) V2100) (if (cons? V1980) (let B (hd V1980) (let V1981 (shen.lazyderef (tl V1980) V2100) (if (= () V1981) (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (if (shen.pvar? V1981) (do (shen.bindv V1981 () V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (do (shen.unbindv V1981 V2100) Result))) false)))) (if (shen.pvar? V1980) (let B (shen.newpv V2100) (do (shen.bindv V1980 (cons B ()) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (do (shen.unbindv V1980 V2100) Result)))) false))) (do (shen.unbindv V1977 V2100) Result))) false))) (if (shen.pvar? V1976) (let B (shen.newpv V2100) (do (shen.bindv V1976 (cons * (cons B ())) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (do (shen.unbindv V1976 V2100) Result)))) false)))) (if (shen.pvar? V1975) (let A (shen.newpv V2100) (let B (shen.newpv V2100) (do (shen.bindv V1975 (cons A (cons * (cons B ()))) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y B V2099 V2100 V2101)))) (do (shen.unbindv V1975 V2100) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1982 (shen.lazyderef V2097 V2100) (if (cons? V1982) (let V1983 (shen.lazyderef (hd V1982) V2100) (if (= @v V1983) (let V1984 (shen.lazyderef (tl V1982) V2100) (if (cons? V1984) (let X (hd V1984) (let V1985 (shen.lazyderef (tl V1984) V2100) (if (cons? V1985) (let Y (hd V1985) (let V1986 (shen.lazyderef (tl V1985) V2100) (if (= () V1986) (let V1987 (shen.lazyderef V2098 V2100) (if (cons? V1987) (let V1988 (shen.lazyderef (hd V1987) V2100) (if (= vector V1988) (let V1989 (shen.lazyderef (tl V1987) V2100) (if (cons? V1989) (let A (hd V1989) (let V1990 (shen.lazyderef (tl V1989) V2100) (if (= () V1990) (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (if (shen.pvar? V1990) (do (shen.bindv V1990 () V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1990 V2100) Result))) false)))) (if (shen.pvar? V1989) (let A (shen.newpv V2100) (do (shen.bindv V1989 (cons A ()) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1989 V2100) Result)))) false))) (if (shen.pvar? V1988) (do (shen.bindv V1988 vector V2100) (let Result (let V1991 (shen.lazyderef (tl V1987) V2100) (if (cons? V1991) (let A (hd V1991) (let V1992 (shen.lazyderef (tl V1991) V2100) (if (= () V1992) (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (if (shen.pvar? V1992) (do (shen.bindv V1992 () V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1992 V2100) Result))) false)))) (if (shen.pvar? V1991) (let A (shen.newpv V2100) (do (shen.bindv V1991 (cons A ()) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1991 V2100) Result)))) false))) (do (shen.unbindv V1988 V2100) Result))) false))) (if (shen.pvar? V1987) (let A (shen.newpv V2100) (do (shen.bindv V1987 (cons vector (cons A ())) V2100) (let Result (do (shen.incinfs) (shen.th* X A V2099 V2100 (freeze (shen.th* Y (cons vector (cons A ())) V2099 V2100 V2101)))) (do (shen.unbindv V1987 V2100) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1993 (shen.lazyderef V2097 V2100) (if (cons? V1993) (let V1994 (shen.lazyderef (hd V1993) V2100) (if (= @s V1994) (let V1995 (shen.lazyderef (tl V1993) V2100) (if (cons? V1995) (let X (hd V1995) (let V1996 (shen.lazyderef (tl V1995) V2100) (if (cons? V1996) (let Y (hd V1996) (let V1997 (shen.lazyderef (tl V1996) V2100) (if (= () V1997) (let V1998 (shen.lazyderef V2098 V2100) (if (= string V1998) (do (shen.incinfs) (shen.th* X string V2099 V2100 (freeze (shen.th* Y string V2099 V2100 V2101)))) (if (shen.pvar? V1998) (do (shen.bindv V1998 string V2100) (let Result (do (shen.incinfs) (shen.th* X string V2099 V2100 (freeze (shen.th* Y string V2099 V2100 V2101)))) (do (shen.unbindv V1998 V2100) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1999 (shen.lazyderef V2097 V2100) (if (cons? V1999) (let V2000 (shen.lazyderef (hd V1999) V2100) (if (= lambda V2000) (let V2001 (shen.lazyderef (tl V1999) V2100) (if (cons? V2001) (let X (hd V2001) (let V2002 (shen.lazyderef (tl V2001) V2100) (if (cons? V2002) (let Y (hd V2002) (let V2003 (shen.lazyderef (tl V2002) V2100) (if (= () V2003) (let V2004 (shen.lazyderef V2098 V2100) (if (cons? V2004) (let A (hd V2004) (let V2005 (shen.lazyderef (tl V2004) V2100) (if (cons? V2005) (let V2006 (shen.lazyderef (hd V2005) V2100) (if (= --> V2006) (let V2007 (shen.lazyderef (tl V2005) V2100) (if (cons? V2007) (let B (hd V2007) (let V2008 (shen.lazyderef (tl V2007) V2100) (if (= () V2008) (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (if (shen.pvar? V2008) (do (shen.bindv V2008 () V2100) (let Result (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (do (shen.unbindv V2008 V2100) Result))) false)))) (if (shen.pvar? V2007) (let B (shen.newpv V2100) (do (shen.bindv V2007 (cons B ()) V2100) (let Result (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (do (shen.unbindv V2007 V2100) Result)))) false))) (if (shen.pvar? V2006) (do (shen.bindv V2006 --> V2100) (let Result (let V2009 (shen.lazyderef (tl V2005) V2100) (if (cons? V2009) (let B (hd V2009) (let V2010 (shen.lazyderef (tl V2009) V2100) (if (= () V2010) (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (if (shen.pvar? V2010) (do (shen.bindv V2010 () V2100) (let Result (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (do (shen.unbindv V2010 V2100) Result))) false)))) (if (shen.pvar? V2009) (let B (shen.newpv V2100) (do (shen.bindv V2009 (cons B ()) V2100) (let Result (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (do (shen.unbindv V2009 V2100) Result)))) false))) (do (shen.unbindv V2006 V2100) Result))) false))) (if (shen.pvar? V2005) (let B (shen.newpv V2100) (do (shen.bindv V2005 (cons --> (cons B ())) V2100) (let Result (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (do (shen.unbindv V2005 V2100) Result)))) false)))) (if (shen.pvar? V2004) (let A (shen.newpv V2100) (let B (shen.newpv V2100) (do (shen.bindv V2004 (cons A (cons --> (cons B ()))) V2100) (let Result (let Z (shen.newpv V2100) (let X&& (shen.newpv V2100) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Y V2100)) V2100 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2099) V2100 V2101)))))))))) (do (shen.unbindv V2004 V2100) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2011 (shen.lazyderef V2097 V2100) (if (cons? V2011) (let V2012 (shen.lazyderef (hd V2011) V2100) (if (= let V2012) (let V2013 (shen.lazyderef (tl V2011) V2100) (if (cons? V2013) (let X (hd V2013) (let V2014 (shen.lazyderef (tl V2013) V2100) (if (cons? V2014) (let Y (hd V2014) (let V2015 (shen.lazyderef (tl V2014) V2100) (if (cons? V2015) (let Z (hd V2015) (let V2016 (shen.lazyderef (tl V2015) V2100) (if (= () V2016) (let W (shen.newpv V2100) (let X&& (shen.newpv V2100) (let B (shen.newpv V2100) (do (shen.incinfs) (shen.th* Y B V2099 V2100 (freeze (bind X&& (shen.placeholder) V2100 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2100) (shen.lazyderef X V2100) (shen.lazyderef Z V2100)) V2100 (freeze (shen.th* W V2098 (cons (cons X&& (cons : (cons B ()))) V2099) V2100 V2101))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2017 (shen.lazyderef V2097 V2100) (if (cons? V2017) (let V2018 (shen.lazyderef (hd V2017) V2100) (if (= open V2018) (let V2019 (shen.lazyderef (tl V2017) V2100) (if (cons? V2019) (let FileName (hd V2019) (let V2020 (shen.lazyderef (tl V2019) V2100) (if (cons? V2020) (let Direction1950 (hd V2020) (let V2021 (shen.lazyderef (tl V2020) V2100) (if (= () V2021) (let V2022 (shen.lazyderef V2098 V2100) (if (cons? V2022) (let V2023 (shen.lazyderef (hd V2022) V2100) (if (= stream V2023) (let V2024 (shen.lazyderef (tl V2022) V2100) (if (cons? V2024) (let Direction (hd V2024) (let V2025 (shen.lazyderef (tl V2024) V2100) (if (= () V2025) (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (if (shen.pvar? V2025) (do (shen.bindv V2025 () V2100) (let Result (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (do (shen.unbindv V2025 V2100) Result))) false)))) (if (shen.pvar? V2024) (let Direction (shen.newpv V2100) (do (shen.bindv V2024 (cons Direction ()) V2100) (let Result (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (do (shen.unbindv V2024 V2100) Result)))) false))) (if (shen.pvar? V2023) (do (shen.bindv V2023 stream V2100) (let Result (let V2026 (shen.lazyderef (tl V2022) V2100) (if (cons? V2026) (let Direction (hd V2026) (let V2027 (shen.lazyderef (tl V2026) V2100) (if (= () V2027) (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (if (shen.pvar? V2027) (do (shen.bindv V2027 () V2100) (let Result (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (do (shen.unbindv V2027 V2100) Result))) false)))) (if (shen.pvar? V2026) (let Direction (shen.newpv V2100) (do (shen.bindv V2026 (cons Direction ()) V2100) (let Result (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (do (shen.unbindv V2026 V2100) Result)))) false))) (do (shen.unbindv V2023 V2100) Result))) false))) (if (shen.pvar? V2022) (let Direction (shen.newpv V2100) (do (shen.bindv V2022 (cons stream (cons Direction ())) V2100) (let Result (do (shen.incinfs) (unify! Direction Direction1950 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* FileName string V2099 V2100 V2101)))))) (do (shen.unbindv V2022 V2100) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2028 (shen.lazyderef V2097 V2100) (if (cons? V2028) (let V2029 (shen.lazyderef (hd V2028) V2100) (if (= type V2029) (let V2030 (shen.lazyderef (tl V2028) V2100) (if (cons? V2030) (let X (hd V2030) (let V2031 (shen.lazyderef (tl V2030) V2100) (if (cons? V2031) (let A (hd V2031) (let V2032 (shen.lazyderef (tl V2031) V2100) (if (= () V2032) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (unify A V2098 V2100 (freeze (shen.th* X A V2099 V2100 V2101)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2033 (shen.lazyderef V2097 V2100) (if (cons? V2033) (let V2034 (shen.lazyderef (hd V2033) V2100) (if (= input+ V2034) (let V2035 (shen.lazyderef (tl V2033) V2100) (if (cons? V2035) (let A (hd V2035) (let V2036 (shen.lazyderef (tl V2035) V2100) (if (cons? V2036) (let Stream (hd V2036) (let V2037 (shen.lazyderef (tl V2036) V2100) (if (= () V2037) (let C (shen.newpv V2100) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2100)) V2100 (freeze (unify V2098 C V2100 (freeze (shen.th* Stream (cons stream (cons in ())) V2099 V2100 V2101))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2038 (shen.lazyderef V2097 V2100) (if (cons? V2038) (let V2039 (shen.lazyderef (hd V2038) V2100) (if (= set V2039) (let V2040 (shen.lazyderef (tl V2038) V2100) (if (cons? V2040) (let Var (hd V2040) (let V2041 (shen.lazyderef (tl V2040) V2100) (if (cons? V2041) (let Val (hd V2041) (let V2042 (shen.lazyderef (tl V2041) V2100) (if (= () V2042) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (shen.th* Var symbol V2099 V2100 (freeze (cut Throwcontrol V2100 (freeze (shen.th* (cons value (cons Var ())) V2098 V2099 V2100 (freeze (shen.th* Val V2098 V2099 V2100 V2101)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2100) (do (shen.incinfs) (shen.t*-hyps V2099 NewHyp V2100 (freeze (shen.th* V2097 V2098 NewHyp V2100 V2101))))) (if (= Case false) (let Case (let V2043 (shen.lazyderef V2097 V2100) (if (cons? V2043) (let V2044 (shen.lazyderef (hd V2043) V2100) (if (= define V2044) (let V2045 (shen.lazyderef (tl V2043) V2100) (if (cons? V2045) (let F (hd V2045) (let X (tl V2045) (do (shen.incinfs) (cut Throwcontrol V2100 (freeze (shen.t*-def (cons define (cons F X)) V2098 V2099 V2100 V2101)))))) false)) false)) false)) (if (= Case false) (let Case (let V2046 (shen.lazyderef V2097 V2100) (if (cons? V2046) (let V2047 (shen.lazyderef (hd V2046) V2100) (if (= defmacro V2047) (let V2048 (shen.lazyderef V2098 V2100) (if (= unit V2048) (do (shen.incinfs) (cut Throwcontrol V2100 V2101)) (if (shen.pvar? V2048) (do (shen.bindv V2048 unit V2100) (let Result (do (shen.incinfs) (cut Throwcontrol V2100 V2101)) (do (shen.unbindv V2048 V2100) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2049 (shen.lazyderef V2097 V2100) (if (cons? V2049) (let V2050 (shen.lazyderef (hd V2049) V2100) (if (= shen.process-datatype V2050) (let V2051 (shen.lazyderef V2098 V2100) (if (= symbol V2051) (do (shen.incinfs) (thaw V2101)) (if (shen.pvar? V2051) (do (shen.bindv V2051 symbol V2100) (let Result (do (shen.incinfs) (thaw V2101)) (do (shen.unbindv V2051 V2100) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2052 (shen.lazyderef V2097 V2100) (if (cons? V2052) (let V2053 (shen.lazyderef (hd V2052) V2100) (if (= shen.synonyms-help V2053) (let V2054 (shen.lazyderef V2098 V2100) (if (= symbol V2054) (do (shen.incinfs) (thaw V2101)) (if (shen.pvar? V2054) (do (shen.bindv V2054 symbol V2100) (let Result (do (shen.incinfs) (thaw V2101)) (do (shen.unbindv V2054 V2100) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2100) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2100 (freeze (shen.udefs* (cons V2097 (cons : (cons V2098 ()))) V2099 Datatypes V2100 V2101))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2102 V2103 V2104 V2105) (let Case (let V1865 (shen.lazyderef V2102 V2104) (if (cons? V1865) (let V1866 (shen.lazyderef (hd V1865) V2104) (if (cons? V1866) (let V1867 (shen.lazyderef (hd V1866) V2104) (if (cons? V1867) (let V1868 (shen.lazyderef (hd V1867) V2104) (if (= cons V1868) (let V1869 (shen.lazyderef (tl V1867) V2104) (if (cons? V1869) (let X (hd V1869) (let V1870 (shen.lazyderef (tl V1869) V2104) (if (cons? V1870) (let Y (hd V1870) (let V1871 (shen.lazyderef (tl V1870) V2104) (if (= () V1871) (let V1872 (shen.lazyderef (tl V1866) V2104) (if (cons? V1872) (let V1873 (shen.lazyderef (hd V1872) V2104) (if (= : V1873) (let V1874 (shen.lazyderef (tl V1872) V2104) (if (cons? V1874) (let V1875 (shen.lazyderef (hd V1874) V2104) (if (cons? V1875) (let V1876 (shen.lazyderef (hd V1875) V2104) (if (= list V1876) (let V1877 (shen.lazyderef (tl V1875) V2104) (if (cons? V1877) (let A (hd V1877) (let V1878 (shen.lazyderef (tl V1877) V2104) (if (= () V1878) (let V1879 (shen.lazyderef (tl V1874) V2104) (if (= () V1879) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1879) (do (shen.bindv V1879 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1879 V2104) Result))) false))) (if (shen.pvar? V1878) (do (shen.bindv V1878 () V2104) (let Result (let V1880 (shen.lazyderef (tl V1874) V2104) (if (= () V1880) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1880) (do (shen.bindv V1880 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1880 V2104) Result))) false))) (do (shen.unbindv V1878 V2104) Result))) false)))) (if (shen.pvar? V1877) (let A (shen.newpv V2104) (do (shen.bindv V1877 (cons A ()) V2104) (let Result (let V1881 (shen.lazyderef (tl V1874) V2104) (if (= () V1881) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1881) (do (shen.bindv V1881 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1881 V2104) Result))) false))) (do (shen.unbindv V1877 V2104) Result)))) false))) (if (shen.pvar? V1876) (do (shen.bindv V1876 list V2104) (let Result (let V1882 (shen.lazyderef (tl V1875) V2104) (if (cons? V1882) (let A (hd V1882) (let V1883 (shen.lazyderef (tl V1882) V2104) (if (= () V1883) (let V1884 (shen.lazyderef (tl V1874) V2104) (if (= () V1884) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1884) (do (shen.bindv V1884 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1884 V2104) Result))) false))) (if (shen.pvar? V1883) (do (shen.bindv V1883 () V2104) (let Result (let V1885 (shen.lazyderef (tl V1874) V2104) (if (= () V1885) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1885) (do (shen.bindv V1885 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1885 V2104) Result))) false))) (do (shen.unbindv V1883 V2104) Result))) false)))) (if (shen.pvar? V1882) (let A (shen.newpv V2104) (do (shen.bindv V1882 (cons A ()) V2104) (let Result (let V1886 (shen.lazyderef (tl V1874) V2104) (if (= () V1886) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1886) (do (shen.bindv V1886 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1886 V2104) Result))) false))) (do (shen.unbindv V1882 V2104) Result)))) false))) (do (shen.unbindv V1876 V2104) Result))) false))) (if (shen.pvar? V1875) (let A (shen.newpv V2104) (do (shen.bindv V1875 (cons list (cons A ())) V2104) (let Result (let V1887 (shen.lazyderef (tl V1874) V2104) (if (= () V1887) (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1887) (do (shen.bindv V1887 () V2104) (let Result (let Hyp (tl V1865) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons list (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1887 V2104) Result))) false))) (do (shen.unbindv V1875 V2104) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1888 (shen.lazyderef V2102 V2104) (if (cons? V1888) (let V1889 (shen.lazyderef (hd V1888) V2104) (if (cons? V1889) (let V1890 (shen.lazyderef (hd V1889) V2104) (if (cons? V1890) (let V1891 (shen.lazyderef (hd V1890) V2104) (if (= @p V1891) (let V1892 (shen.lazyderef (tl V1890) V2104) (if (cons? V1892) (let X (hd V1892) (let V1893 (shen.lazyderef (tl V1892) V2104) (if (cons? V1893) (let Y (hd V1893) (let V1894 (shen.lazyderef (tl V1893) V2104) (if (= () V1894) (let V1895 (shen.lazyderef (tl V1889) V2104) (if (cons? V1895) (let V1896 (shen.lazyderef (hd V1895) V2104) (if (= : V1896) (let V1897 (shen.lazyderef (tl V1895) V2104) (if (cons? V1897) (let V1898 (shen.lazyderef (hd V1897) V2104) (if (cons? V1898) (let A (hd V1898) (let V1899 (shen.lazyderef (tl V1898) V2104) (if (cons? V1899) (let V1900 (shen.lazyderef (hd V1899) V2104) (if (= * V1900) (let V1901 (shen.lazyderef (tl V1899) V2104) (if (cons? V1901) (let B (hd V1901) (let V1902 (shen.lazyderef (tl V1901) V2104) (if (= () V1902) (let V1903 (shen.lazyderef (tl V1897) V2104) (if (= () V1903) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1903) (do (shen.bindv V1903 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1903 V2104) Result))) false))) (if (shen.pvar? V1902) (do (shen.bindv V1902 () V2104) (let Result (let V1904 (shen.lazyderef (tl V1897) V2104) (if (= () V1904) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1904) (do (shen.bindv V1904 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1904 V2104) Result))) false))) (do (shen.unbindv V1902 V2104) Result))) false)))) (if (shen.pvar? V1901) (let B (shen.newpv V2104) (do (shen.bindv V1901 (cons B ()) V2104) (let Result (let V1905 (shen.lazyderef (tl V1897) V2104) (if (= () V1905) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1905) (do (shen.bindv V1905 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1905 V2104) Result))) false))) (do (shen.unbindv V1901 V2104) Result)))) false))) (if (shen.pvar? V1900) (do (shen.bindv V1900 * V2104) (let Result (let V1906 (shen.lazyderef (tl V1899) V2104) (if (cons? V1906) (let B (hd V1906) (let V1907 (shen.lazyderef (tl V1906) V2104) (if (= () V1907) (let V1908 (shen.lazyderef (tl V1897) V2104) (if (= () V1908) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1908) (do (shen.bindv V1908 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1908 V2104) Result))) false))) (if (shen.pvar? V1907) (do (shen.bindv V1907 () V2104) (let Result (let V1909 (shen.lazyderef (tl V1897) V2104) (if (= () V1909) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1909) (do (shen.bindv V1909 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1909 V2104) Result))) false))) (do (shen.unbindv V1907 V2104) Result))) false)))) (if (shen.pvar? V1906) (let B (shen.newpv V2104) (do (shen.bindv V1906 (cons B ()) V2104) (let Result (let V1910 (shen.lazyderef (tl V1897) V2104) (if (= () V1910) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1910) (do (shen.bindv V1910 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1910 V2104) Result))) false))) (do (shen.unbindv V1906 V2104) Result)))) false))) (do (shen.unbindv V1900 V2104) Result))) false))) (if (shen.pvar? V1899) (let B (shen.newpv V2104) (do (shen.bindv V1899 (cons * (cons B ())) V2104) (let Result (let V1911 (shen.lazyderef (tl V1897) V2104) (if (= () V1911) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1911) (do (shen.bindv V1911 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1911 V2104) Result))) false))) (do (shen.unbindv V1899 V2104) Result)))) false)))) (if (shen.pvar? V1898) (let A (shen.newpv V2104) (let B (shen.newpv V2104) (do (shen.bindv V1898 (cons A (cons * (cons B ()))) V2104) (let Result (let V1912 (shen.lazyderef (tl V1897) V2104) (if (= () V1912) (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1912) (do (shen.bindv V1912 () V2104) (let Result (let Hyp (tl V1888) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (shen.lazyderef B V2104) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1912 V2104) Result))) false))) (do (shen.unbindv V1898 V2104) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1913 (shen.lazyderef V2102 V2104) (if (cons? V1913) (let V1914 (shen.lazyderef (hd V1913) V2104) (if (cons? V1914) (let V1915 (shen.lazyderef (hd V1914) V2104) (if (cons? V1915) (let V1916 (shen.lazyderef (hd V1915) V2104) (if (= @v V1916) (let V1917 (shen.lazyderef (tl V1915) V2104) (if (cons? V1917) (let X (hd V1917) (let V1918 (shen.lazyderef (tl V1917) V2104) (if (cons? V1918) (let Y (hd V1918) (let V1919 (shen.lazyderef (tl V1918) V2104) (if (= () V1919) (let V1920 (shen.lazyderef (tl V1914) V2104) (if (cons? V1920) (let V1921 (shen.lazyderef (hd V1920) V2104) (if (= : V1921) (let V1922 (shen.lazyderef (tl V1920) V2104) (if (cons? V1922) (let V1923 (shen.lazyderef (hd V1922) V2104) (if (cons? V1923) (let V1924 (shen.lazyderef (hd V1923) V2104) (if (= vector V1924) (let V1925 (shen.lazyderef (tl V1923) V2104) (if (cons? V1925) (let A (hd V1925) (let V1926 (shen.lazyderef (tl V1925) V2104) (if (= () V1926) (let V1927 (shen.lazyderef (tl V1922) V2104) (if (= () V1927) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1927) (do (shen.bindv V1927 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1927 V2104) Result))) false))) (if (shen.pvar? V1926) (do (shen.bindv V1926 () V2104) (let Result (let V1928 (shen.lazyderef (tl V1922) V2104) (if (= () V1928) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1928) (do (shen.bindv V1928 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1928 V2104) Result))) false))) (do (shen.unbindv V1926 V2104) Result))) false)))) (if (shen.pvar? V1925) (let A (shen.newpv V2104) (do (shen.bindv V1925 (cons A ()) V2104) (let Result (let V1929 (shen.lazyderef (tl V1922) V2104) (if (= () V1929) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1929) (do (shen.bindv V1929 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1929 V2104) Result))) false))) (do (shen.unbindv V1925 V2104) Result)))) false))) (if (shen.pvar? V1924) (do (shen.bindv V1924 vector V2104) (let Result (let V1930 (shen.lazyderef (tl V1923) V2104) (if (cons? V1930) (let A (hd V1930) (let V1931 (shen.lazyderef (tl V1930) V2104) (if (= () V1931) (let V1932 (shen.lazyderef (tl V1922) V2104) (if (= () V1932) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1932) (do (shen.bindv V1932 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1932 V2104) Result))) false))) (if (shen.pvar? V1931) (do (shen.bindv V1931 () V2104) (let Result (let V1933 (shen.lazyderef (tl V1922) V2104) (if (= () V1933) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1933) (do (shen.bindv V1933 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1933 V2104) Result))) false))) (do (shen.unbindv V1931 V2104) Result))) false)))) (if (shen.pvar? V1930) (let A (shen.newpv V2104) (do (shen.bindv V1930 (cons A ()) V2104) (let Result (let V1934 (shen.lazyderef (tl V1922) V2104) (if (= () V1934) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1934) (do (shen.bindv V1934 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1934 V2104) Result))) false))) (do (shen.unbindv V1930 V2104) Result)))) false))) (do (shen.unbindv V1924 V2104) Result))) false))) (if (shen.pvar? V1923) (let A (shen.newpv V2104) (do (shen.bindv V1923 (cons vector (cons A ())) V2104) (let Result (let V1935 (shen.lazyderef (tl V1922) V2104) (if (= () V1935) (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1935) (do (shen.bindv V1935 () V2104) (let Result (let Hyp (tl V1913) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons (shen.lazyderef A V2104) ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons (cons vector (cons (shen.lazyderef A V2104) ())) ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1935 V2104) Result))) false))) (do (shen.unbindv V1923 V2104) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1936 (shen.lazyderef V2102 V2104) (if (cons? V1936) (let V1937 (shen.lazyderef (hd V1936) V2104) (if (cons? V1937) (let V1938 (shen.lazyderef (hd V1937) V2104) (if (cons? V1938) (let V1939 (shen.lazyderef (hd V1938) V2104) (if (= @s V1939) (let V1940 (shen.lazyderef (tl V1938) V2104) (if (cons? V1940) (let X (hd V1940) (let V1941 (shen.lazyderef (tl V1940) V2104) (if (cons? V1941) (let Y (hd V1941) (let V1942 (shen.lazyderef (tl V1941) V2104) (if (= () V1942) (let V1943 (shen.lazyderef (tl V1937) V2104) (if (cons? V1943) (let V1944 (shen.lazyderef (hd V1943) V2104) (if (= : V1944) (let V1945 (shen.lazyderef (tl V1943) V2104) (if (cons? V1945) (let V1946 (shen.lazyderef (hd V1945) V2104) (if (= string V1946) (let V1947 (shen.lazyderef (tl V1945) V2104) (if (= () V1947) (let Hyp (tl V1936) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons string ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1947) (do (shen.bindv V1947 () V2104) (let Result (let Hyp (tl V1936) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons string ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1947 V2104) Result))) false))) (if (shen.pvar? V1946) (do (shen.bindv V1946 string V2104) (let Result (let V1948 (shen.lazyderef (tl V1945) V2104) (if (= () V1948) (let Hyp (tl V1936) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons string ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (if (shen.pvar? V1948) (do (shen.bindv V1948 () V2104) (let Result (let Hyp (tl V1936) (do (shen.incinfs) (bind V2103 (cons (cons (shen.lazyderef X V2104) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2104) (cons : (cons string ()))) (shen.lazyderef Hyp V2104))) V2104 V2105))) (do (shen.unbindv V1948 V2104) Result))) false))) (do (shen.unbindv V1946 V2104) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V1949 (shen.lazyderef V2102 V2104) (if (cons? V1949) (let X (hd V1949) (let Hyp (tl V1949) (let NewHyps (shen.newpv V2104) (do (shen.incinfs) (bind V2103 (cons (shen.lazyderef X V2104) (shen.lazyderef NewHyps V2104)) V2104 (freeze (shen.t*-hyps Hyp NewHyps V2104 V2105))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2118 V2119 V2120 V2121) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2118 V2120)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2119 V2120) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2121))))))))) (true (thaw V2121))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2122) (cond ((and (cons? V2122) (and (cons? (tl V2122)) (and (= : (hd (tl V2122))) (and (cons? (tl (tl V2122))) (= () (tl (tl (tl V2122)))))))) (shen.prhush (shen.app (hd V2122) (cn " : " (shen.app (hd (tl (tl V2122))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2122 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2125 V2126) (cond ((= () V2125) shen.skip) ((cons? V2125) (do (shen.prhush (shen.app V2126 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2125)) (do (nl 1) (shen.show-assumptions (tl V2125) (+ V2126 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2127) (cons? (assoc V2127 (value shen.*signedfuncs*))))

(defun shen.sigf (V2128) (concat shen.type-signature-of- V2128))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2129 V2130 V2131 V2132) (let Case (let V1852 (shen.lazyderef V2130 V2131) (if (= number V1852) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2129 V2131)) V2131 V2132)) (if (shen.pvar? V1852) (do (shen.bindv V1852 number V2131) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2129 V2131)) V2131 V2132)) (do (shen.unbindv V1852 V2131) Result))) false))) (if (= Case false) (let Case (let V1853 (shen.lazyderef V2130 V2131) (if (= boolean V1853) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2129 V2131)) V2131 V2132)) (if (shen.pvar? V1853) (do (shen.bindv V1853 boolean V2131) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2129 V2131)) V2131 V2132)) (do (shen.unbindv V1853 V2131) Result))) false))) (if (= Case false) (let Case (let V1854 (shen.lazyderef V2130 V2131) (if (= string V1854) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2129 V2131)) V2131 V2132)) (if (shen.pvar? V1854) (do (shen.bindv V1854 string V2131) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2129 V2131)) V2131 V2132)) (do (shen.unbindv V1854 V2131) Result))) false))) (if (= Case false) (let Case (let V1855 (shen.lazyderef V2130 V2131) (if (= symbol V1855) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2129 V2131)) V2131 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2129 V2131))) V2131 V2132)))) (if (shen.pvar? V1855) (do (shen.bindv V1855 symbol V2131) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2129 V2131)) V2131 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2129 V2131))) V2131 V2132)))) (do (shen.unbindv V1855 V2131) Result))) false))) (if (= Case false) (let V1856 (shen.lazyderef V2129 V2131) (if (= () V1856) (let V1857 (shen.lazyderef V2130 V2131) (if (cons? V1857) (let V1858 (shen.lazyderef (hd V1857) V2131) (if (= list V1858) (let V1859 (shen.lazyderef (tl V1857) V2131) (if (cons? V1859) (let A (hd V1859) (let V1860 (shen.lazyderef (tl V1859) V2131) (if (= () V1860) (do (shen.incinfs) (thaw V2132)) (if (shen.pvar? V1860) (do (shen.bindv V1860 () V2131) (let Result (do (shen.incinfs) (thaw V2132)) (do (shen.unbindv V1860 V2131) Result))) false)))) (if (shen.pvar? V1859) (let A (shen.newpv V2131) (do (shen.bindv V1859 (cons A ()) V2131) (let Result (do (shen.incinfs) (thaw V2132)) (do (shen.unbindv V1859 V2131) Result)))) false))) (if (shen.pvar? V1858) (do (shen.bindv V1858 list V2131) (let Result (let V1861 (shen.lazyderef (tl V1857) V2131) (if (cons? V1861) (let A (hd V1861) (let V1862 (shen.lazyderef (tl V1861) V2131) (if (= () V1862) (do (shen.incinfs) (thaw V2132)) (if (shen.pvar? V1862) (do (shen.bindv V1862 () V2131) (let Result (do (shen.incinfs) (thaw V2132)) (do (shen.unbindv V1862 V2131) Result))) false)))) (if (shen.pvar? V1861) (let A (shen.newpv V2131) (do (shen.bindv V1861 (cons A ()) V2131) (let Result (do (shen.incinfs) (thaw V2132)) (do (shen.unbindv V1861 V2131) Result)))) false))) (do (shen.unbindv V1858 V2131) Result))) false))) (if (shen.pvar? V1857) (let A (shen.newpv V2131) (do (shen.bindv V1857 (cons list (cons A ())) V2131) (let Result (do (shen.incinfs) (thaw V2132)) (do (shen.unbindv V1857 V2131) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2133 V2134 V2135 V2136 V2137) (let Case (let V1843 (shen.lazyderef V2135 V2136) (if (cons? V1843) (let V1844 (shen.lazyderef (hd V1843) V2136) (if (cons? V1844) (let Y (hd V1844) (let V1845 (shen.lazyderef (tl V1844) V2136) (if (cons? V1845) (let V1846 (shen.lazyderef (hd V1845) V2136) (if (= : V1846) (let V1847 (shen.lazyderef (tl V1845) V2136) (if (cons? V1847) (let B (hd V1847) (let V1848 (shen.lazyderef (tl V1847) V2136) (if (= () V1848) (do (shen.incinfs) (identical V2133 Y V2136 (freeze (unify! V2134 B V2136 V2137)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V1849 (shen.lazyderef V2135 V2136) (if (cons? V1849) (let Hyp (tl V1849) (do (shen.incinfs) (shen.by_hypothesis V2133 V2134 Hyp V2136 V2137))) false)) Case)))

(defun shen.t*-def (V2138 V2139 V2140 V2141 V2142) (let V1837 (shen.lazyderef V2138 V2141) (if (cons? V1837) (let V1838 (shen.lazyderef (hd V1837) V2141) (if (= define V1838) (let V1839 (shen.lazyderef (tl V1837) V2141) (if (cons? V1839) (let F (hd V1839) (let X (tl V1839) (let V1746 (shen.newpv V2141) (let E (shen.newpv V2141) (do (shen.incinfs) (shen.t*-defh (compile (lambda V1746 (shen.<sig+rules> V1746)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2139 V2140 V2141 V2142)))))) false)) false)) false)))

(defun shen.t*-defh (V2143 V2144 V2145 V2146 V2147 V2148) (let V1833 (shen.lazyderef V2143 V2147) (if (cons? V1833) (let Sig (hd V1833) (let Rules (tl V1833) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2144 V2145 V2146 Rules V2147 V2148)))) false)))

(defun shen.t*-defhh (V2149 V2150 V2151 V2152 V2153 V2154 V2155 V2156) (do (shen.incinfs) (shen.t*-rules V2154 V2150 1 V2151 (cons (cons V2151 (cons : (cons V2150 ()))) V2153) V2155 (freeze (shen.memo V2151 V2149 V2152 V2155 V2156)))))

(defun shen.memo (V2157 V2158 V2159 V2160 V2161) (let Jnk (shen.newpv V2160) (do (shen.incinfs) (unify! V2159 V2158 V2160 (freeze (bind Jnk (declare (shen.lazyderef V2157 V2160) (shen.lazyderef V2159 V2160)) V2160 V2161))))))

(defun shen.<sig+rules> (V2162) (let Parse_shen.<signature> (shen.<signature> V2162) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2163) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2163) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2163) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2164) (cond ((and (cons? V2164) (and (cons? (tl V2164)) (and (= () (tl (tl V2164))) (= (hd V2164) protect)))) V2164) ((cons? V2164) (map (lambda V1747 (shen.ue V1747)) V2164)) ((variable? V2164) (concat && V2164)) (true V2164)))

(defun shen.ue-sig (V2165) (cond ((cons? V2165) (map (lambda V1748 (shen.ue-sig V1748)) V2165)) ((variable? V2165) (concat &&& V2165)) (true V2165)))

(defun shen.ues (V2170) (cond ((shen.ue? V2170) (cons V2170 ())) ((cons? V2170) (union (shen.ues (hd V2170)) (shen.ues (tl V2170)))) (true ())))

(defun shen.ue? (V2171) (and (symbol? V2171) (shen.ue-h? (str V2171))))

(defun shen.ue-h? (V2178) (cond ((and (shen.+string? V2178) (and (= "&" (pos V2178 0)) (and (shen.+string? (tlstr V2178)) (= "&" (pos (tlstr V2178) 0))))) true) (true false)))

(defun shen.t*-rules (V2179 V2180 V2181 V2182 V2183 V2184 V2185) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1817 (shen.lazyderef V2179 V2184) (if (= () V1817) (do (shen.incinfs) (thaw V2185)) false)) (if (= Case false) (let Case (let V1818 (shen.lazyderef V2179 V2184) (if (cons? V1818) (let Rule (hd V1818) (let Rules (tl V1818) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2180 V2183 V2184 (freeze (cut Throwcontrol V2184 (freeze (shen.t*-rules Rules V2180 (+ V2181 1) V2182 V2183 V2184 V2185)))))))) false)) (if (= Case false) (let Err (shen.newpv V2184) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2181 V2184) (cn " of " (shen.app (shen.lazyderef V2182 V2184) "" shen.a)) shen.a))) V2184 V2185))) Case)) Case)))))

(defun shen.t*-rule (V2186 V2187 V2188 V2189 V2190) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V1809 (shen.lazyderef V2186 V2189) (if (cons? V1809) (let Patterns (hd V1809) (let V1810 (shen.lazyderef (tl V1809) V2189) (if (cons? V1810) (let Action (hd V1810) (let V1811 (shen.lazyderef (tl V1810) V2189) (if (= () V1811) (let NewHyps (shen.newpv V2189) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2188 NewHyps V2189 (freeze (shen.t*-patterns Patterns V2187 NewHyps V2189 (freeze (cut Throwcontrol V2189 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2187) (shen.patthyps Patterns V2187 V2188) V2189 V2190))))))))) false))) false))) false)))))

(defun shen.placeholders (V2195) (cond ((shen.ue? V2195) (cons V2195 ())) ((cons? V2195) (union (shen.placeholders (hd V2195)) (shen.placeholders (tl V2195)))) (true ())))

(defun shen.newhyps (V2196 V2197 V2198 V2199 V2200) (let Case (let V1796 (shen.lazyderef V2196 V2199) (if (= () V1796) (do (shen.incinfs) (unify! V2198 V2197 V2199 V2200)) false)) (if (= Case false) (let V1797 (shen.lazyderef V2196 V2199) (if (cons? V1797) (let V1792 (hd V1797) (let Vs (tl V1797) (let V1798 (shen.lazyderef V2198 V2199) (if (cons? V1798) (let V1799 (shen.lazyderef (hd V1798) V2199) (if (cons? V1799) (let V (hd V1799) (let V1800 (shen.lazyderef (tl V1799) V2199) (if (cons? V1800) (let V1801 (shen.lazyderef (hd V1800) V2199) (if (= : V1801) (let V1802 (shen.lazyderef (tl V1800) V2199) (if (cons? V1802) (let A (hd V1802) (let V1803 (shen.lazyderef (tl V1802) V2199) (if (= () V1803) (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (if (shen.pvar? V1803) (do (shen.bindv V1803 () V2199) (let Result (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (do (shen.unbindv V1803 V2199) Result))) false)))) (if (shen.pvar? V1802) (let A (shen.newpv V2199) (do (shen.bindv V1802 (cons A ()) V2199) (let Result (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (do (shen.unbindv V1802 V2199) Result)))) false))) (if (shen.pvar? V1801) (do (shen.bindv V1801 : V2199) (let Result (let V1804 (shen.lazyderef (tl V1800) V2199) (if (cons? V1804) (let A (hd V1804) (let V1805 (shen.lazyderef (tl V1804) V2199) (if (= () V1805) (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (if (shen.pvar? V1805) (do (shen.bindv V1805 () V2199) (let Result (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (do (shen.unbindv V1805 V2199) Result))) false)))) (if (shen.pvar? V1804) (let A (shen.newpv V2199) (do (shen.bindv V1804 (cons A ()) V2199) (let Result (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (do (shen.unbindv V1804 V2199) Result)))) false))) (do (shen.unbindv V1801 V2199) Result))) false))) (if (shen.pvar? V1800) (let A (shen.newpv V2199) (do (shen.bindv V1800 (cons : (cons A ())) V2199) (let Result (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (do (shen.unbindv V1800 V2199) Result)))) false)))) (if (shen.pvar? V1799) (let V (shen.newpv V2199) (let A (shen.newpv V2199) (do (shen.bindv V1799 (cons V (cons : (cons A ()))) V2199) (let Result (let NewHyp (tl V1798) (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200))))) (do (shen.unbindv V1799 V2199) Result))))) false))) (if (shen.pvar? V1798) (let V (shen.newpv V2199) (let A (shen.newpv V2199) (let NewHyp (shen.newpv V2199) (do (shen.bindv V1798 (cons (cons V (cons : (cons A ()))) NewHyp) V2199) (let Result (do (shen.incinfs) (unify! V V1792 V2199 (freeze (shen.newhyps Vs V2197 NewHyp V2199 V2200)))) (do (shen.unbindv V1798 V2199) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2203 V2204 V2205) (cond ((= () V2203) V2205) ((and (cons? V2203) (and (cons? V2204) (and (cons? (tl V2204)) (and (= --> (hd (tl V2204))) (and (cons? (tl (tl V2204))) (= () (tl (tl (tl V2204))))))))) (adjoin (cons (hd V2203) (cons : (cons (hd V2204) ()))) (shen.patthyps (tl V2203) (hd (tl (tl V2204))) V2205))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2210 V2211) (cond ((= () V2210) V2211) ((and (cons? V2210) (and (cons? V2211) (and (cons? (tl V2211)) (and (= --> (hd (tl V2211))) (and (cons? (tl (tl V2211))) (= () (tl (tl (tl V2211))))))))) (shen.result-type (tl V2210) (hd (tl (tl V2211))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2212 V2213 V2214 V2215 V2216) (let Case (let V1784 (shen.lazyderef V2212 V2215) (if (= () V1784) (do (shen.incinfs) (thaw V2216)) false)) (if (= Case false) (let V1785 (shen.lazyderef V2212 V2215) (if (cons? V1785) (let Pattern (hd V1785) (let Patterns (tl V1785) (let V1786 (shen.lazyderef V2213 V2215) (if (cons? V1786) (let A (hd V1786) (let V1787 (shen.lazyderef (tl V1786) V2215) (if (cons? V1787) (let V1788 (shen.lazyderef (hd V1787) V2215) (if (= --> V1788) (let V1789 (shen.lazyderef (tl V1787) V2215) (if (cons? V1789) (let B (hd V1789) (let V1790 (shen.lazyderef (tl V1789) V2215) (if (= () V1790) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V2214 V2215 (freeze (shen.t*-patterns Patterns B V2214 V2215 V2216)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2217 V2218 V2219 V2220 V2221) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1761 (shen.lazyderef V2217 V2220) (if (cons? V1761) (let V1762 (shen.lazyderef (hd V1761) V2220) (if (= where V1762) (let V1763 (shen.lazyderef (tl V1761) V2220) (if (cons? V1763) (let P (hd V1763) (let V1764 (shen.lazyderef (tl V1763) V2220) (if (cons? V1764) (let Action (hd V1764) (let V1765 (shen.lazyderef (tl V1764) V2220) (if (= () V1765) (do (shen.incinfs) (cut Throwcontrol V2220 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2219 V2220 (freeze (cut Throwcontrol V2220 (freeze (shen.t*-action Action V2218 (cons (cons P (cons : (cons verified ()))) V2219) V2220 V2221)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1766 (shen.lazyderef V2217 V2220) (if (cons? V1766) (let V1767 (shen.lazyderef (hd V1766) V2220) (if (= shen.choicepoint! V1767) (let V1768 (shen.lazyderef (tl V1766) V2220) (if (cons? V1768) (let V1769 (shen.lazyderef (hd V1768) V2220) (if (cons? V1769) (let V1770 (shen.lazyderef (hd V1769) V2220) (if (cons? V1770) (let V1771 (shen.lazyderef (hd V1770) V2220) (if (= fail-if V1771) (let V1772 (shen.lazyderef (tl V1770) V2220) (if (cons? V1772) (let F (hd V1772) (let V1773 (shen.lazyderef (tl V1772) V2220) (if (= () V1773) (let V1774 (shen.lazyderef (tl V1769) V2220) (if (cons? V1774) (let Action (hd V1774) (let V1775 (shen.lazyderef (tl V1774) V2220) (if (= () V1775) (let V1776 (shen.lazyderef (tl V1768) V2220) (if (= () V1776) (do (shen.incinfs) (cut Throwcontrol V2220 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2218 V2219 V2220 V2221)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1777 (shen.lazyderef V2217 V2220) (if (cons? V1777) (let V1778 (shen.lazyderef (hd V1777) V2220) (if (= shen.choicepoint! V1778) (let V1779 (shen.lazyderef (tl V1777) V2220) (if (cons? V1779) (let Action (hd V1779) (let V1780 (shen.lazyderef (tl V1779) V2220) (if (= () V1780) (do (shen.incinfs) (cut Throwcontrol V2220 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2218 V2219 V2220 V2221)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2217 (cons : (cons V2218 ()))) V2219 V2220 V2221)) Case)) Case)) Case)))))

(defun findall (V2222 V2223 V2224 V2225 V2226) (let B (shen.newpv V2225) (let A (shen.newpv V2225) (do (shen.incinfs) (bind A (gensym shen.a) V2225 (freeze (bind B (set (shen.lazyderef A V2225) ()) V2225 (freeze (shen.findallhelp V2222 V2223 V2224 A V2225 V2226)))))))))

(defun shen.findallhelp (V2227 V2228 V2229 V2230 V2231 V2232) (let Case (do (shen.incinfs) (call V2228 V2231 (freeze (shen.remember V2230 V2227 V2231 (freeze (fwhen false V2231 V2232)))))) (if (= Case false) (do (shen.incinfs) (bind V2229 (value (shen.lazyderef V2230 V2231)) V2231 V2232)) Case)))

(defun shen.remember (V2233 V2234 V2235 V2236) (let B (shen.newpv V2235) (do (shen.incinfs) (bind B (set (shen.deref V2233 V2235) (cons (shen.deref V2234 V2235) (value (shen.deref V2233 V2235)))) V2235 V2236))))



