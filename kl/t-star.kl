"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2788 V2789) (let Curry (shen.curry V2788) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2789)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2790) (cond ((and (cons? V2790) (shen.special? (hd V2790))) (cons (hd V2790) (map (lambda X2784 (shen.curry X2784)) (tl V2790)))) ((and (cons? V2790) (and (cons? (tl V2790)) (shen.extraspecial? (hd V2790)))) V2790) ((and (cons? V2790) (and (= type (hd V2790)) (and (cons? (tl V2790)) (and (cons? (tl (tl V2790))) (= () (tl (tl (tl V2790)))))))) (cons type (cons (shen.curry (hd (tl V2790))) (tl (tl V2790))))) ((and (cons? V2790) (and (cons? (tl V2790)) (cons? (tl (tl V2790))))) (shen.curry (cons (cons (hd V2790) (cons (hd (tl V2790)) ())) (tl (tl V2790))))) ((and (cons? V2790) (and (cons? (tl V2790)) (= () (tl (tl V2790))))) (cons (shen.curry (hd V2790)) (cons (shen.curry (hd (tl V2790))) ()))) (true V2790)))

(defun shen.special? (V2791) (element? V2791 (value shen.*special*)))

(defun shen.extraspecial? (V2792) (element? V2792 (value shen.*extraspecial*)))

(defun shen.t* (V2793 V2794 V2795 V2796) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2795) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2795 (freeze (bind Error (shen.errormaxinfs) V2795 V2796))))) (if (= Case false) (let Case (let V2778 (shen.lazyderef V2793 V2795) (if (= fail V2778) (do (shen.incinfs) (cut Throwcontrol V2795 (freeze (shen.prolog-failure V2795 V2796)))) false)) (if (= Case false) (let Case (let V2779 (shen.lazyderef V2793 V2795) (if (cons? V2779) (let X (hd V2779) (let V2780 (shen.lazyderef (tl V2779) V2795) (if (cons? V2780) (let V2781 (shen.lazyderef (hd V2780) V2795) (if (= : V2781) (let V2782 (shen.lazyderef (tl V2780) V2795) (if (cons? V2782) (let A (hd V2782) (let V2783 (shen.lazyderef (tl V2782) V2795) (if (= () V2783) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2795 (freeze (cut Throwcontrol V2795 (freeze (shen.th* X A V2794 V2795 V2796)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2795) (do (shen.incinfs) (shen.show V2793 V2794 V2795 (freeze (bind Datatypes (value shen.*datatypes*) V2795 (freeze (shen.udefs* V2793 V2794 Datatypes V2795 V2796))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2801) (cond ((= + V2801) (set shen.*shen-type-theory-enabled?* true)) ((= - V2801) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2810 V2811) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2812 V2813 V2814 V2815 V2816) (let Case (let V2774 (shen.lazyderef V2814 V2815) (if (cons? V2774) (let D (hd V2774) (do (shen.incinfs) (call (cons D (cons V2812 (cons V2813 ()))) V2815 V2816))) false)) (if (= Case false) (let V2775 (shen.lazyderef V2814 V2815) (if (cons? V2775) (let Ds (tl V2775) (do (shen.incinfs) (shen.udefs* V2812 V2813 Ds V2815 V2816))) false)) Case)))

(defun shen.th* (V2817 V2818 V2819 V2820 V2821) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2817 (cons : (cons V2818 ()))) V2819 V2820 (freeze (fwhen false V2820 V2821)))) (if (= Case false) (let Case (let F (shen.newpv V2820) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2817 V2820)) V2820 (freeze (bind F (shen.sigf (shen.lazyderef V2817 V2820)) V2820 (freeze (call (cons F (cons V2818 ())) V2820 V2821))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2817 V2818 V2820 V2821)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2817 V2818 V2819 V2820 V2821)) (if (= Case false) (let Case (let V2666 (shen.lazyderef V2817 V2820) (if (cons? V2666) (let F (hd V2666) (let V2667 (shen.lazyderef (tl V2666) V2820) (if (= () V2667) (do (shen.incinfs) (shen.th* F (cons --> (cons V2818 ())) V2819 V2820 V2821)) false))) false)) (if (= Case false) (let Case (let V2668 (shen.lazyderef V2817 V2820) (if (cons? V2668) (let F (hd V2668) (let V2669 (shen.lazyderef (tl V2668) V2820) (if (cons? V2669) (let X (hd V2669) (let V2670 (shen.lazyderef (tl V2669) V2820) (if (= () V2670) (let B (shen.newpv V2820) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2818 ()))) V2819 V2820 (freeze (shen.th* X B V2819 V2820 V2821))))) false))) false))) false)) (if (= Case false) (let Case (let V2671 (shen.lazyderef V2817 V2820) (if (cons? V2671) (let V2672 (shen.lazyderef (hd V2671) V2820) (if (= cons V2672) (let V2673 (shen.lazyderef (tl V2671) V2820) (if (cons? V2673) (let X (hd V2673) (let V2674 (shen.lazyderef (tl V2673) V2820) (if (cons? V2674) (let Y (hd V2674) (let V2675 (shen.lazyderef (tl V2674) V2820) (if (= () V2675) (let V2676 (shen.lazyderef V2818 V2820) (if (cons? V2676) (let V2677 (shen.lazyderef (hd V2676) V2820) (if (= list V2677) (let V2678 (shen.lazyderef (tl V2676) V2820) (if (cons? V2678) (let A (hd V2678) (let V2679 (shen.lazyderef (tl V2678) V2820) (if (= () V2679) (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (if (shen.pvar? V2679) (do (shen.bindv V2679 () V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2679 V2820) Result))) false)))) (if (shen.pvar? V2678) (let A (shen.newpv V2820) (do (shen.bindv V2678 (cons A ()) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2678 V2820) Result)))) false))) (if (shen.pvar? V2677) (do (shen.bindv V2677 list V2820) (let Result (let V2680 (shen.lazyderef (tl V2676) V2820) (if (cons? V2680) (let A (hd V2680) (let V2681 (shen.lazyderef (tl V2680) V2820) (if (= () V2681) (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (if (shen.pvar? V2681) (do (shen.bindv V2681 () V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2681 V2820) Result))) false)))) (if (shen.pvar? V2680) (let A (shen.newpv V2820) (do (shen.bindv V2680 (cons A ()) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2680 V2820) Result)))) false))) (do (shen.unbindv V2677 V2820) Result))) false))) (if (shen.pvar? V2676) (let A (shen.newpv V2820) (do (shen.bindv V2676 (cons list (cons A ())) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons list (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2676 V2820) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2682 (shen.lazyderef V2817 V2820) (if (cons? V2682) (let V2683 (shen.lazyderef (hd V2682) V2820) (if (= @p V2683) (let V2684 (shen.lazyderef (tl V2682) V2820) (if (cons? V2684) (let X (hd V2684) (let V2685 (shen.lazyderef (tl V2684) V2820) (if (cons? V2685) (let Y (hd V2685) (let V2686 (shen.lazyderef (tl V2685) V2820) (if (= () V2686) (let V2687 (shen.lazyderef V2818 V2820) (if (cons? V2687) (let A (hd V2687) (let V2688 (shen.lazyderef (tl V2687) V2820) (if (cons? V2688) (let V2689 (shen.lazyderef (hd V2688) V2820) (if (= * V2689) (let V2690 (shen.lazyderef (tl V2688) V2820) (if (cons? V2690) (let B (hd V2690) (let V2691 (shen.lazyderef (tl V2690) V2820) (if (= () V2691) (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (if (shen.pvar? V2691) (do (shen.bindv V2691 () V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (do (shen.unbindv V2691 V2820) Result))) false)))) (if (shen.pvar? V2690) (let B (shen.newpv V2820) (do (shen.bindv V2690 (cons B ()) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (do (shen.unbindv V2690 V2820) Result)))) false))) (if (shen.pvar? V2689) (do (shen.bindv V2689 * V2820) (let Result (let V2692 (shen.lazyderef (tl V2688) V2820) (if (cons? V2692) (let B (hd V2692) (let V2693 (shen.lazyderef (tl V2692) V2820) (if (= () V2693) (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (if (shen.pvar? V2693) (do (shen.bindv V2693 () V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (do (shen.unbindv V2693 V2820) Result))) false)))) (if (shen.pvar? V2692) (let B (shen.newpv V2820) (do (shen.bindv V2692 (cons B ()) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (do (shen.unbindv V2692 V2820) Result)))) false))) (do (shen.unbindv V2689 V2820) Result))) false))) (if (shen.pvar? V2688) (let B (shen.newpv V2820) (do (shen.bindv V2688 (cons * (cons B ())) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (do (shen.unbindv V2688 V2820) Result)))) false)))) (if (shen.pvar? V2687) (let A (shen.newpv V2820) (let B (shen.newpv V2820) (do (shen.bindv V2687 (cons A (cons * (cons B ()))) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y B V2819 V2820 V2821)))) (do (shen.unbindv V2687 V2820) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2694 (shen.lazyderef V2817 V2820) (if (cons? V2694) (let V2695 (shen.lazyderef (hd V2694) V2820) (if (= @v V2695) (let V2696 (shen.lazyderef (tl V2694) V2820) (if (cons? V2696) (let X (hd V2696) (let V2697 (shen.lazyderef (tl V2696) V2820) (if (cons? V2697) (let Y (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2820) (if (= () V2698) (let V2699 (shen.lazyderef V2818 V2820) (if (cons? V2699) (let V2700 (shen.lazyderef (hd V2699) V2820) (if (= vector V2700) (let V2701 (shen.lazyderef (tl V2699) V2820) (if (cons? V2701) (let A (hd V2701) (let V2702 (shen.lazyderef (tl V2701) V2820) (if (= () V2702) (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (if (shen.pvar? V2702) (do (shen.bindv V2702 () V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2702 V2820) Result))) false)))) (if (shen.pvar? V2701) (let A (shen.newpv V2820) (do (shen.bindv V2701 (cons A ()) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2701 V2820) Result)))) false))) (if (shen.pvar? V2700) (do (shen.bindv V2700 vector V2820) (let Result (let V2703 (shen.lazyderef (tl V2699) V2820) (if (cons? V2703) (let A (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2820) (if (= () V2704) (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (if (shen.pvar? V2704) (do (shen.bindv V2704 () V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2704 V2820) Result))) false)))) (if (shen.pvar? V2703) (let A (shen.newpv V2820) (do (shen.bindv V2703 (cons A ()) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2703 V2820) Result)))) false))) (do (shen.unbindv V2700 V2820) Result))) false))) (if (shen.pvar? V2699) (let A (shen.newpv V2820) (do (shen.bindv V2699 (cons vector (cons A ())) V2820) (let Result (do (shen.incinfs) (shen.th* X A V2819 V2820 (freeze (shen.th* Y (cons vector (cons A ())) V2819 V2820 V2821)))) (do (shen.unbindv V2699 V2820) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2705 (shen.lazyderef V2817 V2820) (if (cons? V2705) (let V2706 (shen.lazyderef (hd V2705) V2820) (if (= @s V2706) (let V2707 (shen.lazyderef (tl V2705) V2820) (if (cons? V2707) (let X (hd V2707) (let V2708 (shen.lazyderef (tl V2707) V2820) (if (cons? V2708) (let Y (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2820) (if (= () V2709) (let V2710 (shen.lazyderef V2818 V2820) (if (= string V2710) (do (shen.incinfs) (shen.th* X string V2819 V2820 (freeze (shen.th* Y string V2819 V2820 V2821)))) (if (shen.pvar? V2710) (do (shen.bindv V2710 string V2820) (let Result (do (shen.incinfs) (shen.th* X string V2819 V2820 (freeze (shen.th* Y string V2819 V2820 V2821)))) (do (shen.unbindv V2710 V2820) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2711 (shen.lazyderef V2817 V2820) (if (cons? V2711) (let V2712 (shen.lazyderef (hd V2711) V2820) (if (= lambda V2712) (let V2713 (shen.lazyderef (tl V2711) V2820) (if (cons? V2713) (let X (hd V2713) (let V2714 (shen.lazyderef (tl V2713) V2820) (if (cons? V2714) (let Y (hd V2714) (let V2715 (shen.lazyderef (tl V2714) V2820) (if (= () V2715) (let V2716 (shen.lazyderef V2818 V2820) (if (cons? V2716) (let A (hd V2716) (let V2717 (shen.lazyderef (tl V2716) V2820) (if (cons? V2717) (let V2718 (shen.lazyderef (hd V2717) V2820) (if (= --> V2718) (let V2719 (shen.lazyderef (tl V2717) V2820) (if (cons? V2719) (let B (hd V2719) (let V2720 (shen.lazyderef (tl V2719) V2820) (if (= () V2720) (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (if (shen.pvar? V2720) (do (shen.bindv V2720 () V2820) (let Result (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (do (shen.unbindv V2720 V2820) Result))) false)))) (if (shen.pvar? V2719) (let B (shen.newpv V2820) (do (shen.bindv V2719 (cons B ()) V2820) (let Result (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (do (shen.unbindv V2719 V2820) Result)))) false))) (if (shen.pvar? V2718) (do (shen.bindv V2718 --> V2820) (let Result (let V2721 (shen.lazyderef (tl V2717) V2820) (if (cons? V2721) (let B (hd V2721) (let V2722 (shen.lazyderef (tl V2721) V2820) (if (= () V2722) (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (if (shen.pvar? V2722) (do (shen.bindv V2722 () V2820) (let Result (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (do (shen.unbindv V2722 V2820) Result))) false)))) (if (shen.pvar? V2721) (let B (shen.newpv V2820) (do (shen.bindv V2721 (cons B ()) V2820) (let Result (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (do (shen.unbindv V2721 V2820) Result)))) false))) (do (shen.unbindv V2718 V2820) Result))) false))) (if (shen.pvar? V2717) (let B (shen.newpv V2820) (do (shen.bindv V2717 (cons --> (cons B ())) V2820) (let Result (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (do (shen.unbindv V2717 V2820) Result)))) false)))) (if (shen.pvar? V2716) (let A (shen.newpv V2820) (let B (shen.newpv V2820) (do (shen.bindv V2716 (cons A (cons --> (cons B ()))) V2820) (let Result (let Z (shen.newpv V2820) (let X&& (shen.newpv V2820) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Y V2820)) V2820 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2819) V2820 V2821)))))))))) (do (shen.unbindv V2716 V2820) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2723 (shen.lazyderef V2817 V2820) (if (cons? V2723) (let V2724 (shen.lazyderef (hd V2723) V2820) (if (= let V2724) (let V2725 (shen.lazyderef (tl V2723) V2820) (if (cons? V2725) (let X (hd V2725) (let V2726 (shen.lazyderef (tl V2725) V2820) (if (cons? V2726) (let Y (hd V2726) (let V2727 (shen.lazyderef (tl V2726) V2820) (if (cons? V2727) (let Z (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2820) (if (= () V2728) (let W (shen.newpv V2820) (let X&& (shen.newpv V2820) (let B (shen.newpv V2820) (do (shen.incinfs) (shen.th* Y B V2819 V2820 (freeze (bind X&& (shen.placeholder) V2820 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2820) (shen.lazyderef X V2820) (shen.lazyderef Z V2820)) V2820 (freeze (shen.th* W V2818 (cons (cons X&& (cons : (cons B ()))) V2819) V2820 V2821))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2729 (shen.lazyderef V2817 V2820) (if (cons? V2729) (let V2730 (shen.lazyderef (hd V2729) V2820) (if (= open V2730) (let V2731 (shen.lazyderef (tl V2729) V2820) (if (cons? V2731) (let FileName (hd V2731) (let V2732 (shen.lazyderef (tl V2731) V2820) (if (cons? V2732) (let Direction2662 (hd V2732) (let V2733 (shen.lazyderef (tl V2732) V2820) (if (= () V2733) (let V2734 (shen.lazyderef V2818 V2820) (if (cons? V2734) (let V2735 (shen.lazyderef (hd V2734) V2820) (if (= stream V2735) (let V2736 (shen.lazyderef (tl V2734) V2820) (if (cons? V2736) (let Direction (hd V2736) (let V2737 (shen.lazyderef (tl V2736) V2820) (if (= () V2737) (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (if (shen.pvar? V2737) (do (shen.bindv V2737 () V2820) (let Result (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (do (shen.unbindv V2737 V2820) Result))) false)))) (if (shen.pvar? V2736) (let Direction (shen.newpv V2820) (do (shen.bindv V2736 (cons Direction ()) V2820) (let Result (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (do (shen.unbindv V2736 V2820) Result)))) false))) (if (shen.pvar? V2735) (do (shen.bindv V2735 stream V2820) (let Result (let V2738 (shen.lazyderef (tl V2734) V2820) (if (cons? V2738) (let Direction (hd V2738) (let V2739 (shen.lazyderef (tl V2738) V2820) (if (= () V2739) (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (if (shen.pvar? V2739) (do (shen.bindv V2739 () V2820) (let Result (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (do (shen.unbindv V2739 V2820) Result))) false)))) (if (shen.pvar? V2738) (let Direction (shen.newpv V2820) (do (shen.bindv V2738 (cons Direction ()) V2820) (let Result (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (do (shen.unbindv V2738 V2820) Result)))) false))) (do (shen.unbindv V2735 V2820) Result))) false))) (if (shen.pvar? V2734) (let Direction (shen.newpv V2820) (do (shen.bindv V2734 (cons stream (cons Direction ())) V2820) (let Result (do (shen.incinfs) (unify! Direction Direction2662 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* FileName string V2819 V2820 V2821)))))) (do (shen.unbindv V2734 V2820) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2740 (shen.lazyderef V2817 V2820) (if (cons? V2740) (let V2741 (shen.lazyderef (hd V2740) V2820) (if (= type V2741) (let V2742 (shen.lazyderef (tl V2740) V2820) (if (cons? V2742) (let X (hd V2742) (let V2743 (shen.lazyderef (tl V2742) V2820) (if (cons? V2743) (let A (hd V2743) (let V2744 (shen.lazyderef (tl V2743) V2820) (if (= () V2744) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (unify A V2818 V2820 (freeze (shen.th* X A V2819 V2820 V2821)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2745 (shen.lazyderef V2817 V2820) (if (cons? V2745) (let V2746 (shen.lazyderef (hd V2745) V2820) (if (= input+ V2746) (let V2747 (shen.lazyderef (tl V2745) V2820) (if (cons? V2747) (let A (hd V2747) (let V2748 (shen.lazyderef (tl V2747) V2820) (if (cons? V2748) (let Stream (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2820) (if (= () V2749) (let C (shen.newpv V2820) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2820)) V2820 (freeze (unify V2818 C V2820 (freeze (shen.th* Stream (cons stream (cons in ())) V2819 V2820 V2821))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2750 (shen.lazyderef V2817 V2820) (if (cons? V2750) (let V2751 (shen.lazyderef (hd V2750) V2820) (if (= set V2751) (let V2752 (shen.lazyderef (tl V2750) V2820) (if (cons? V2752) (let Var (hd V2752) (let V2753 (shen.lazyderef (tl V2752) V2820) (if (cons? V2753) (let Val (hd V2753) (let V2754 (shen.lazyderef (tl V2753) V2820) (if (= () V2754) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (shen.th* Var symbol V2819 V2820 (freeze (cut Throwcontrol V2820 (freeze (shen.th* (cons value (cons Var ())) V2818 V2819 V2820 (freeze (shen.th* Val V2818 V2819 V2820 V2821)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2755 (shen.lazyderef V2817 V2820) (if (cons? V2755) (let V2756 (shen.lazyderef (hd V2755) V2820) (if (= fail V2756) (let V2757 (shen.lazyderef (tl V2755) V2820) (if (= () V2757) (let V2758 (shen.lazyderef V2818 V2820) (if (= symbol V2758) (do (shen.incinfs) (thaw V2821)) (if (shen.pvar? V2758) (do (shen.bindv V2758 symbol V2820) (let Result (do (shen.incinfs) (thaw V2821)) (do (shen.unbindv V2758 V2820) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2820) (do (shen.incinfs) (shen.t*-hyps V2819 NewHyp V2820 (freeze (shen.th* V2817 V2818 NewHyp V2820 V2821))))) (if (= Case false) (let Case (let V2759 (shen.lazyderef V2817 V2820) (if (cons? V2759) (let V2760 (shen.lazyderef (hd V2759) V2820) (if (= define V2760) (let V2761 (shen.lazyderef (tl V2759) V2820) (if (cons? V2761) (let F (hd V2761) (let X (tl V2761) (do (shen.incinfs) (cut Throwcontrol V2820 (freeze (shen.t*-def (cons define (cons F X)) V2818 V2819 V2820 V2821)))))) false)) false)) false)) (if (= Case false) (let Case (let V2762 (shen.lazyderef V2817 V2820) (if (cons? V2762) (let V2763 (shen.lazyderef (hd V2762) V2820) (if (= defmacro V2763) (let V2764 (shen.lazyderef V2818 V2820) (if (= unit V2764) (do (shen.incinfs) (cut Throwcontrol V2820 V2821)) (if (shen.pvar? V2764) (do (shen.bindv V2764 unit V2820) (let Result (do (shen.incinfs) (cut Throwcontrol V2820 V2821)) (do (shen.unbindv V2764 V2820) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2765 (shen.lazyderef V2817 V2820) (if (cons? V2765) (let V2766 (shen.lazyderef (hd V2765) V2820) (if (= shen.process-datatype V2766) (let V2767 (shen.lazyderef V2818 V2820) (if (= symbol V2767) (do (shen.incinfs) (thaw V2821)) (if (shen.pvar? V2767) (do (shen.bindv V2767 symbol V2820) (let Result (do (shen.incinfs) (thaw V2821)) (do (shen.unbindv V2767 V2820) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2768 (shen.lazyderef V2817 V2820) (if (cons? V2768) (let V2769 (shen.lazyderef (hd V2768) V2820) (if (= shen.synonyms-help V2769) (let V2770 (shen.lazyderef V2818 V2820) (if (= symbol V2770) (do (shen.incinfs) (thaw V2821)) (if (shen.pvar? V2770) (do (shen.bindv V2770 symbol V2820) (let Result (do (shen.incinfs) (thaw V2821)) (do (shen.unbindv V2770 V2820) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2820) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2820 (freeze (shen.udefs* (cons V2817 (cons : (cons V2818 ()))) V2819 Datatypes V2820 V2821))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2822 V2823 V2824 V2825) (let Case (let V2577 (shen.lazyderef V2822 V2824) (if (cons? V2577) (let V2578 (shen.lazyderef (hd V2577) V2824) (if (cons? V2578) (let V2579 (shen.lazyderef (hd V2578) V2824) (if (cons? V2579) (let V2580 (shen.lazyderef (hd V2579) V2824) (if (= cons V2580) (let V2581 (shen.lazyderef (tl V2579) V2824) (if (cons? V2581) (let X (hd V2581) (let V2582 (shen.lazyderef (tl V2581) V2824) (if (cons? V2582) (let Y (hd V2582) (let V2583 (shen.lazyderef (tl V2582) V2824) (if (= () V2583) (let V2584 (shen.lazyderef (tl V2578) V2824) (if (cons? V2584) (let V2585 (shen.lazyderef (hd V2584) V2824) (if (= : V2585) (let V2586 (shen.lazyderef (tl V2584) V2824) (if (cons? V2586) (let V2587 (shen.lazyderef (hd V2586) V2824) (if (cons? V2587) (let V2588 (shen.lazyderef (hd V2587) V2824) (if (= list V2588) (let V2589 (shen.lazyderef (tl V2587) V2824) (if (cons? V2589) (let A (hd V2589) (let V2590 (shen.lazyderef (tl V2589) V2824) (if (= () V2590) (let V2591 (shen.lazyderef (tl V2586) V2824) (if (= () V2591) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2591) (do (shen.bindv V2591 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2591 V2824) Result))) false))) (if (shen.pvar? V2590) (do (shen.bindv V2590 () V2824) (let Result (let V2592 (shen.lazyderef (tl V2586) V2824) (if (= () V2592) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2592) (do (shen.bindv V2592 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2592 V2824) Result))) false))) (do (shen.unbindv V2590 V2824) Result))) false)))) (if (shen.pvar? V2589) (let A (shen.newpv V2824) (do (shen.bindv V2589 (cons A ()) V2824) (let Result (let V2593 (shen.lazyderef (tl V2586) V2824) (if (= () V2593) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2593) (do (shen.bindv V2593 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2593 V2824) Result))) false))) (do (shen.unbindv V2589 V2824) Result)))) false))) (if (shen.pvar? V2588) (do (shen.bindv V2588 list V2824) (let Result (let V2594 (shen.lazyderef (tl V2587) V2824) (if (cons? V2594) (let A (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2824) (if (= () V2595) (let V2596 (shen.lazyderef (tl V2586) V2824) (if (= () V2596) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2596) (do (shen.bindv V2596 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2596 V2824) Result))) false))) (if (shen.pvar? V2595) (do (shen.bindv V2595 () V2824) (let Result (let V2597 (shen.lazyderef (tl V2586) V2824) (if (= () V2597) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2597) (do (shen.bindv V2597 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2597 V2824) Result))) false))) (do (shen.unbindv V2595 V2824) Result))) false)))) (if (shen.pvar? V2594) (let A (shen.newpv V2824) (do (shen.bindv V2594 (cons A ()) V2824) (let Result (let V2598 (shen.lazyderef (tl V2586) V2824) (if (= () V2598) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2598) (do (shen.bindv V2598 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2598 V2824) Result))) false))) (do (shen.unbindv V2594 V2824) Result)))) false))) (do (shen.unbindv V2588 V2824) Result))) false))) (if (shen.pvar? V2587) (let A (shen.newpv V2824) (do (shen.bindv V2587 (cons list (cons A ())) V2824) (let Result (let V2599 (shen.lazyderef (tl V2586) V2824) (if (= () V2599) (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2599) (do (shen.bindv V2599 () V2824) (let Result (let Hyp (tl V2577) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons list (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2599 V2824) Result))) false))) (do (shen.unbindv V2587 V2824) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2600 (shen.lazyderef V2822 V2824) (if (cons? V2600) (let V2601 (shen.lazyderef (hd V2600) V2824) (if (cons? V2601) (let V2602 (shen.lazyderef (hd V2601) V2824) (if (cons? V2602) (let V2603 (shen.lazyderef (hd V2602) V2824) (if (= @p V2603) (let V2604 (shen.lazyderef (tl V2602) V2824) (if (cons? V2604) (let X (hd V2604) (let V2605 (shen.lazyderef (tl V2604) V2824) (if (cons? V2605) (let Y (hd V2605) (let V2606 (shen.lazyderef (tl V2605) V2824) (if (= () V2606) (let V2607 (shen.lazyderef (tl V2601) V2824) (if (cons? V2607) (let V2608 (shen.lazyderef (hd V2607) V2824) (if (= : V2608) (let V2609 (shen.lazyderef (tl V2607) V2824) (if (cons? V2609) (let V2610 (shen.lazyderef (hd V2609) V2824) (if (cons? V2610) (let A (hd V2610) (let V2611 (shen.lazyderef (tl V2610) V2824) (if (cons? V2611) (let V2612 (shen.lazyderef (hd V2611) V2824) (if (= * V2612) (let V2613 (shen.lazyderef (tl V2611) V2824) (if (cons? V2613) (let B (hd V2613) (let V2614 (shen.lazyderef (tl V2613) V2824) (if (= () V2614) (let V2615 (shen.lazyderef (tl V2609) V2824) (if (= () V2615) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2615) (do (shen.bindv V2615 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2615 V2824) Result))) false))) (if (shen.pvar? V2614) (do (shen.bindv V2614 () V2824) (let Result (let V2616 (shen.lazyderef (tl V2609) V2824) (if (= () V2616) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2616) (do (shen.bindv V2616 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2616 V2824) Result))) false))) (do (shen.unbindv V2614 V2824) Result))) false)))) (if (shen.pvar? V2613) (let B (shen.newpv V2824) (do (shen.bindv V2613 (cons B ()) V2824) (let Result (let V2617 (shen.lazyderef (tl V2609) V2824) (if (= () V2617) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2617) (do (shen.bindv V2617 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2617 V2824) Result))) false))) (do (shen.unbindv V2613 V2824) Result)))) false))) (if (shen.pvar? V2612) (do (shen.bindv V2612 * V2824) (let Result (let V2618 (shen.lazyderef (tl V2611) V2824) (if (cons? V2618) (let B (hd V2618) (let V2619 (shen.lazyderef (tl V2618) V2824) (if (= () V2619) (let V2620 (shen.lazyderef (tl V2609) V2824) (if (= () V2620) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2620) (do (shen.bindv V2620 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2620 V2824) Result))) false))) (if (shen.pvar? V2619) (do (shen.bindv V2619 () V2824) (let Result (let V2621 (shen.lazyderef (tl V2609) V2824) (if (= () V2621) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2621) (do (shen.bindv V2621 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2621 V2824) Result))) false))) (do (shen.unbindv V2619 V2824) Result))) false)))) (if (shen.pvar? V2618) (let B (shen.newpv V2824) (do (shen.bindv V2618 (cons B ()) V2824) (let Result (let V2622 (shen.lazyderef (tl V2609) V2824) (if (= () V2622) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2622) (do (shen.bindv V2622 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2622 V2824) Result))) false))) (do (shen.unbindv V2618 V2824) Result)))) false))) (do (shen.unbindv V2612 V2824) Result))) false))) (if (shen.pvar? V2611) (let B (shen.newpv V2824) (do (shen.bindv V2611 (cons * (cons B ())) V2824) (let Result (let V2623 (shen.lazyderef (tl V2609) V2824) (if (= () V2623) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2623) (do (shen.bindv V2623 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2623 V2824) Result))) false))) (do (shen.unbindv V2611 V2824) Result)))) false)))) (if (shen.pvar? V2610) (let A (shen.newpv V2824) (let B (shen.newpv V2824) (do (shen.bindv V2610 (cons A (cons * (cons B ()))) V2824) (let Result (let V2624 (shen.lazyderef (tl V2609) V2824) (if (= () V2624) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2624) (do (shen.bindv V2624 () V2824) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (shen.lazyderef B V2824) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2624 V2824) Result))) false))) (do (shen.unbindv V2610 V2824) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2625 (shen.lazyderef V2822 V2824) (if (cons? V2625) (let V2626 (shen.lazyderef (hd V2625) V2824) (if (cons? V2626) (let V2627 (shen.lazyderef (hd V2626) V2824) (if (cons? V2627) (let V2628 (shen.lazyderef (hd V2627) V2824) (if (= @v V2628) (let V2629 (shen.lazyderef (tl V2627) V2824) (if (cons? V2629) (let X (hd V2629) (let V2630 (shen.lazyderef (tl V2629) V2824) (if (cons? V2630) (let Y (hd V2630) (let V2631 (shen.lazyderef (tl V2630) V2824) (if (= () V2631) (let V2632 (shen.lazyderef (tl V2626) V2824) (if (cons? V2632) (let V2633 (shen.lazyderef (hd V2632) V2824) (if (= : V2633) (let V2634 (shen.lazyderef (tl V2632) V2824) (if (cons? V2634) (let V2635 (shen.lazyderef (hd V2634) V2824) (if (cons? V2635) (let V2636 (shen.lazyderef (hd V2635) V2824) (if (= vector V2636) (let V2637 (shen.lazyderef (tl V2635) V2824) (if (cons? V2637) (let A (hd V2637) (let V2638 (shen.lazyderef (tl V2637) V2824) (if (= () V2638) (let V2639 (shen.lazyderef (tl V2634) V2824) (if (= () V2639) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2639) (do (shen.bindv V2639 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2639 V2824) Result))) false))) (if (shen.pvar? V2638) (do (shen.bindv V2638 () V2824) (let Result (let V2640 (shen.lazyderef (tl V2634) V2824) (if (= () V2640) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2640) (do (shen.bindv V2640 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2640 V2824) Result))) false))) (do (shen.unbindv V2638 V2824) Result))) false)))) (if (shen.pvar? V2637) (let A (shen.newpv V2824) (do (shen.bindv V2637 (cons A ()) V2824) (let Result (let V2641 (shen.lazyderef (tl V2634) V2824) (if (= () V2641) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2641) (do (shen.bindv V2641 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2641 V2824) Result))) false))) (do (shen.unbindv V2637 V2824) Result)))) false))) (if (shen.pvar? V2636) (do (shen.bindv V2636 vector V2824) (let Result (let V2642 (shen.lazyderef (tl V2635) V2824) (if (cons? V2642) (let A (hd V2642) (let V2643 (shen.lazyderef (tl V2642) V2824) (if (= () V2643) (let V2644 (shen.lazyderef (tl V2634) V2824) (if (= () V2644) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2644) (do (shen.bindv V2644 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2644 V2824) Result))) false))) (if (shen.pvar? V2643) (do (shen.bindv V2643 () V2824) (let Result (let V2645 (shen.lazyderef (tl V2634) V2824) (if (= () V2645) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2645) (do (shen.bindv V2645 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2645 V2824) Result))) false))) (do (shen.unbindv V2643 V2824) Result))) false)))) (if (shen.pvar? V2642) (let A (shen.newpv V2824) (do (shen.bindv V2642 (cons A ()) V2824) (let Result (let V2646 (shen.lazyderef (tl V2634) V2824) (if (= () V2646) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2646) (do (shen.bindv V2646 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2646 V2824) Result))) false))) (do (shen.unbindv V2642 V2824) Result)))) false))) (do (shen.unbindv V2636 V2824) Result))) false))) (if (shen.pvar? V2635) (let A (shen.newpv V2824) (do (shen.bindv V2635 (cons vector (cons A ())) V2824) (let Result (let V2647 (shen.lazyderef (tl V2634) V2824) (if (= () V2647) (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2647) (do (shen.bindv V2647 () V2824) (let Result (let Hyp (tl V2625) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons (shen.lazyderef A V2824) ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons (cons vector (cons (shen.lazyderef A V2824) ())) ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2647 V2824) Result))) false))) (do (shen.unbindv V2635 V2824) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2648 (shen.lazyderef V2822 V2824) (if (cons? V2648) (let V2649 (shen.lazyderef (hd V2648) V2824) (if (cons? V2649) (let V2650 (shen.lazyderef (hd V2649) V2824) (if (cons? V2650) (let V2651 (shen.lazyderef (hd V2650) V2824) (if (= @s V2651) (let V2652 (shen.lazyderef (tl V2650) V2824) (if (cons? V2652) (let X (hd V2652) (let V2653 (shen.lazyderef (tl V2652) V2824) (if (cons? V2653) (let Y (hd V2653) (let V2654 (shen.lazyderef (tl V2653) V2824) (if (= () V2654) (let V2655 (shen.lazyderef (tl V2649) V2824) (if (cons? V2655) (let V2656 (shen.lazyderef (hd V2655) V2824) (if (= : V2656) (let V2657 (shen.lazyderef (tl V2655) V2824) (if (cons? V2657) (let V2658 (shen.lazyderef (hd V2657) V2824) (if (= string V2658) (let V2659 (shen.lazyderef (tl V2657) V2824) (if (= () V2659) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons string ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2659) (do (shen.bindv V2659 () V2824) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons string ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2659 V2824) Result))) false))) (if (shen.pvar? V2658) (do (shen.bindv V2658 string V2824) (let Result (let V2660 (shen.lazyderef (tl V2657) V2824) (if (= () V2660) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons string ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (if (shen.pvar? V2660) (do (shen.bindv V2660 () V2824) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2823 (cons (cons (shen.lazyderef X V2824) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2824) (cons : (cons string ()))) (shen.lazyderef Hyp V2824))) V2824 V2825))) (do (shen.unbindv V2660 V2824) Result))) false))) (do (shen.unbindv V2658 V2824) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2661 (shen.lazyderef V2822 V2824) (if (cons? V2661) (let X (hd V2661) (let Hyp (tl V2661) (let NewHyps (shen.newpv V2824) (do (shen.incinfs) (bind V2823 (cons (shen.lazyderef X V2824) (shen.lazyderef NewHyps V2824)) V2824 (freeze (shen.t*-hyps Hyp NewHyps V2824 V2825))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2838 V2839 V2840 V2841) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2838 V2840)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2839 V2840) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2841))))))))) (true (thaw V2841))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2842) (cond ((and (cons? V2842) (and (cons? (tl V2842)) (and (= : (hd (tl V2842))) (and (cons? (tl (tl V2842))) (= () (tl (tl (tl V2842)))))))) (shen.prhush (shen.app (hd V2842) (cn " : " (shen.app (hd (tl (tl V2842))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2842 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2845 V2846) (cond ((= () V2845) shen.skip) ((cons? V2845) (do (shen.prhush (shen.app V2846 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2845)) (do (nl 1) (shen.show-assumptions (tl V2845) (+ V2846 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2847) (cons? (assoc V2847 (value shen.*signedfuncs*))))

(defun shen.sigf (V2848) (concat shen.type-signature-of- V2848))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2849 V2850 V2851 V2852) (let Case (let V2564 (shen.lazyderef V2850 V2851) (if (= number V2564) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2849 V2851)) V2851 V2852)) (if (shen.pvar? V2564) (do (shen.bindv V2564 number V2851) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2849 V2851)) V2851 V2852)) (do (shen.unbindv V2564 V2851) Result))) false))) (if (= Case false) (let Case (let V2565 (shen.lazyderef V2850 V2851) (if (= boolean V2565) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2849 V2851)) V2851 V2852)) (if (shen.pvar? V2565) (do (shen.bindv V2565 boolean V2851) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2849 V2851)) V2851 V2852)) (do (shen.unbindv V2565 V2851) Result))) false))) (if (= Case false) (let Case (let V2566 (shen.lazyderef V2850 V2851) (if (= string V2566) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2849 V2851)) V2851 V2852)) (if (shen.pvar? V2566) (do (shen.bindv V2566 string V2851) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2849 V2851)) V2851 V2852)) (do (shen.unbindv V2566 V2851) Result))) false))) (if (= Case false) (let Case (let V2567 (shen.lazyderef V2850 V2851) (if (= symbol V2567) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2849 V2851)) V2851 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2849 V2851))) V2851 V2852)))) (if (shen.pvar? V2567) (do (shen.bindv V2567 symbol V2851) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2849 V2851)) V2851 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2849 V2851))) V2851 V2852)))) (do (shen.unbindv V2567 V2851) Result))) false))) (if (= Case false) (let V2568 (shen.lazyderef V2849 V2851) (if (= () V2568) (let V2569 (shen.lazyderef V2850 V2851) (if (cons? V2569) (let V2570 (shen.lazyderef (hd V2569) V2851) (if (= list V2570) (let V2571 (shen.lazyderef (tl V2569) V2851) (if (cons? V2571) (let A (hd V2571) (let V2572 (shen.lazyderef (tl V2571) V2851) (if (= () V2572) (do (shen.incinfs) (thaw V2852)) (if (shen.pvar? V2572) (do (shen.bindv V2572 () V2851) (let Result (do (shen.incinfs) (thaw V2852)) (do (shen.unbindv V2572 V2851) Result))) false)))) (if (shen.pvar? V2571) (let A (shen.newpv V2851) (do (shen.bindv V2571 (cons A ()) V2851) (let Result (do (shen.incinfs) (thaw V2852)) (do (shen.unbindv V2571 V2851) Result)))) false))) (if (shen.pvar? V2570) (do (shen.bindv V2570 list V2851) (let Result (let V2573 (shen.lazyderef (tl V2569) V2851) (if (cons? V2573) (let A (hd V2573) (let V2574 (shen.lazyderef (tl V2573) V2851) (if (= () V2574) (do (shen.incinfs) (thaw V2852)) (if (shen.pvar? V2574) (do (shen.bindv V2574 () V2851) (let Result (do (shen.incinfs) (thaw V2852)) (do (shen.unbindv V2574 V2851) Result))) false)))) (if (shen.pvar? V2573) (let A (shen.newpv V2851) (do (shen.bindv V2573 (cons A ()) V2851) (let Result (do (shen.incinfs) (thaw V2852)) (do (shen.unbindv V2573 V2851) Result)))) false))) (do (shen.unbindv V2570 V2851) Result))) false))) (if (shen.pvar? V2569) (let A (shen.newpv V2851) (do (shen.bindv V2569 (cons list (cons A ())) V2851) (let Result (do (shen.incinfs) (thaw V2852)) (do (shen.unbindv V2569 V2851) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2853 V2854 V2855 V2856 V2857) (let Case (let V2555 (shen.lazyderef V2855 V2856) (if (cons? V2555) (let V2556 (shen.lazyderef (hd V2555) V2856) (if (cons? V2556) (let Y (hd V2556) (let V2557 (shen.lazyderef (tl V2556) V2856) (if (cons? V2557) (let V2558 (shen.lazyderef (hd V2557) V2856) (if (= : V2558) (let V2559 (shen.lazyderef (tl V2557) V2856) (if (cons? V2559) (let B (hd V2559) (let V2560 (shen.lazyderef (tl V2559) V2856) (if (= () V2560) (do (shen.incinfs) (identical V2853 Y V2856 (freeze (unify! V2854 B V2856 V2857)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2561 (shen.lazyderef V2855 V2856) (if (cons? V2561) (let Hyp (tl V2561) (do (shen.incinfs) (shen.by_hypothesis V2853 V2854 Hyp V2856 V2857))) false)) Case)))

(defun shen.t*-def (V2858 V2859 V2860 V2861 V2862) (let V2549 (shen.lazyderef V2858 V2861) (if (cons? V2549) (let V2550 (shen.lazyderef (hd V2549) V2861) (if (= define V2550) (let V2551 (shen.lazyderef (tl V2549) V2861) (if (cons? V2551) (let F (hd V2551) (let X (tl V2551) (let E (shen.newpv V2861) (do (shen.incinfs) (shen.t*-defh (compile (lambda X2785 (shen.<sig+rules> X2785)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2859 V2860 V2861 V2862))))) false)) false)) false)))

(defun shen.t*-defh (V2863 V2864 V2865 V2866 V2867 V2868) (let V2545 (shen.lazyderef V2863 V2867) (if (cons? V2545) (let Sig (hd V2545) (let Rules (tl V2545) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2864 V2865 V2866 Rules V2867 V2868)))) false)))

(defun shen.t*-defhh (V2869 V2870 V2871 V2872 V2873 V2874 V2875 V2876) (do (shen.incinfs) (shen.t*-rules V2874 V2870 1 V2871 (cons (cons V2871 (cons : (cons V2870 ()))) V2873) V2875 (freeze (shen.memo V2871 V2869 V2872 V2875 V2876)))))

(defun shen.memo (V2877 V2878 V2879 V2880 V2881) (let Jnk (shen.newpv V2880) (do (shen.incinfs) (unify! V2879 V2878 V2880 (freeze (bind Jnk (declare (shen.lazyderef V2877 V2880) (shen.lazyderef V2879 V2880)) V2880 V2881))))))

(defun shen.<sig+rules> (V2886) (let Result (let Parse_shen.<signature> (shen.<signature> V2886) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2887) (cond ((and (cons? V2887) (and (cons? (tl V2887)) (and (= () (tl (tl V2887))) (= (hd V2887) protect)))) V2887) ((cons? V2887) (map (lambda X2786 (shen.ue X2786)) V2887)) ((variable? V2887) (concat && V2887)) (true V2887)))

(defun shen.ue-sig (V2888) (cond ((cons? V2888) (map (lambda X2787 (shen.ue-sig X2787)) V2888)) ((variable? V2888) (concat &&& V2888)) (true V2888)))

(defun shen.ues (V2893) (cond ((shen.ue? V2893) (cons V2893 ())) ((cons? V2893) (union (shen.ues (hd V2893)) (shen.ues (tl V2893)))) (true ())))

(defun shen.ue? (V2894) (and (symbol? V2894) (shen.ue-h? (str V2894))))

(defun shen.ue-h? (V2901) (cond ((and (shen.+string? V2901) (and (= "&" (pos V2901 0)) (and (shen.+string? (tlstr V2901)) (= "&" (pos (tlstr V2901) 0))))) true) (true false)))

(defun shen.t*-rules (V2902 V2903 V2904 V2905 V2906 V2907 V2908) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2520 (shen.lazyderef V2902 V2907) (if (= () V2520) (do (shen.incinfs) (thaw V2908)) false)) (if (= Case false) (let Case (let V2521 (shen.lazyderef V2902 V2907) (if (cons? V2521) (let V2522 (shen.lazyderef (hd V2521) V2907) (if (cons? V2522) (let V2523 (shen.lazyderef (hd V2522) V2907) (if (= () V2523) (let V2524 (shen.lazyderef (tl V2522) V2907) (if (cons? V2524) (let Action (hd V2524) (let V2525 (shen.lazyderef (tl V2524) V2907) (if (= () V2525) (let Rules (tl V2521) (let V2526 (shen.lazyderef V2903 V2907) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2907) (if (= --> V2527) (let V2528 (shen.lazyderef (tl V2526) V2907) (if (cons? V2528) (let A (hd V2528) (let V2529 (shen.lazyderef (tl V2528) V2907) (if (= () V2529) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2906 V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-rules Rules A (+ V2904 1) V2905 V2906 V2907 V2908)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2530 (shen.lazyderef V2902 V2907) (if (cons? V2530) (let Rule (hd V2530) (let Rules (tl V2530) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2903 V2906 V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-rules Rules V2903 (+ V2904 1) V2905 V2906 V2907 V2908)))))))) false)) (if (= Case false) (let Err (shen.newpv V2907) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2904 V2907) (cn " of " (shen.app (shen.lazyderef V2905 V2907) "" shen.a)) shen.a))) V2907 V2908))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2909 V2910 V2911 V2912 V2913) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2502 (shen.lazyderef V2909 V2912) (if (cons? V2502) (let V2503 (shen.lazyderef (hd V2502) V2912) (if (= () V2503) (let V2504 (shen.lazyderef (tl V2502) V2912) (if (cons? V2504) (let Action (hd V2504) (let V2505 (shen.lazyderef (tl V2504) V2912) (if (= () V2505) (do (shen.incinfs) (cut Throwcontrol V2912 (freeze (shen.t*-action (shen.curry Action) V2910 V2911 V2912 V2913)))) false))) false)) false)) false)) (if (= Case false) (let V2506 (shen.lazyderef V2909 V2912) (if (cons? V2506) (let V2507 (shen.lazyderef (hd V2506) V2912) (if (cons? V2507) (let Pattern (hd V2507) (let Patterns (tl V2507) (let V2508 (shen.lazyderef (tl V2506) V2912) (if (cons? V2508) (let Action (hd V2508) (let V2509 (shen.lazyderef (tl V2508) V2912) (if (= () V2509) (let V2510 (shen.lazyderef V2910 V2912) (if (cons? V2510) (let A (hd V2510) (let V2511 (shen.lazyderef (tl V2510) V2912) (if (cons? V2511) (let V2512 (shen.lazyderef (hd V2511) V2912) (if (= --> V2512) (let V2513 (shen.lazyderef (tl V2511) V2912) (if (cons? V2513) (let B (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2912) (if (= () V2514) (do (shen.incinfs) (shen.t*-pattern Pattern A V2912 (freeze (cut Throwcontrol V2912 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2911) V2912 V2913)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2914 V2915 V2916 V2917 V2918) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2479 (shen.lazyderef V2914 V2917) (if (cons? V2479) (let V2480 (shen.lazyderef (hd V2479) V2917) (if (= where V2480) (let V2481 (shen.lazyderef (tl V2479) V2917) (if (cons? V2481) (let P (hd V2481) (let V2482 (shen.lazyderef (tl V2481) V2917) (if (cons? V2482) (let Action (hd V2482) (let V2483 (shen.lazyderef (tl V2482) V2917) (if (= () V2483) (do (shen.incinfs) (cut Throwcontrol V2917 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2916 V2917 (freeze (cut Throwcontrol V2917 (freeze (shen.t*-action Action V2915 (cons (cons P (cons : (cons verified ()))) V2916) V2917 V2918)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2484 (shen.lazyderef V2914 V2917) (if (cons? V2484) (let V2485 (shen.lazyderef (hd V2484) V2917) (if (= shen.choicepoint! V2485) (let V2486 (shen.lazyderef (tl V2484) V2917) (if (cons? V2486) (let V2487 (shen.lazyderef (hd V2486) V2917) (if (cons? V2487) (let V2488 (shen.lazyderef (hd V2487) V2917) (if (cons? V2488) (let V2489 (shen.lazyderef (hd V2488) V2917) (if (= fail-if V2489) (let V2490 (shen.lazyderef (tl V2488) V2917) (if (cons? V2490) (let F (hd V2490) (let V2491 (shen.lazyderef (tl V2490) V2917) (if (= () V2491) (let V2492 (shen.lazyderef (tl V2487) V2917) (if (cons? V2492) (let Action (hd V2492) (let V2493 (shen.lazyderef (tl V2492) V2917) (if (= () V2493) (let V2494 (shen.lazyderef (tl V2486) V2917) (if (= () V2494) (do (shen.incinfs) (cut Throwcontrol V2917 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2915 V2916 V2917 V2918)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2495 (shen.lazyderef V2914 V2917) (if (cons? V2495) (let V2496 (shen.lazyderef (hd V2495) V2917) (if (= shen.choicepoint! V2496) (let V2497 (shen.lazyderef (tl V2495) V2917) (if (cons? V2497) (let Action (hd V2497) (let V2498 (shen.lazyderef (tl V2497) V2917) (if (= () V2498) (do (shen.incinfs) (cut Throwcontrol V2917 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2915 V2916 V2917 V2918)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2914 (cons : (cons V2915 ()))) V2916 V2917 V2918)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2919 V2920 V2921 V2922) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2921) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2919) Hyp V2921 (freeze (cut Throwcontrol V2921 (freeze (shen.t* (cons V2919 (cons : (cons V2920 ()))) Hyp V2921 V2922))))))))))

(defun shen.tms->hyp (V2923 V2924 V2925 V2926) (let Case (let V2463 (shen.lazyderef V2923 V2925) (if (= () V2463) (let V2464 (shen.lazyderef V2924 V2925) (if (= () V2464) (do (shen.incinfs) (thaw V2926)) (if (shen.pvar? V2464) (do (shen.bindv V2464 () V2925) (let Result (do (shen.incinfs) (thaw V2926)) (do (shen.unbindv V2464 V2925) Result))) false))) false)) (if (= Case false) (let V2465 (shen.lazyderef V2923 V2925) (if (cons? V2465) (let Tm2460 (hd V2465) (let Tms (tl V2465) (let V2466 (shen.lazyderef V2924 V2925) (if (cons? V2466) (let V2467 (shen.lazyderef (hd V2466) V2925) (if (cons? V2467) (let Tm (hd V2467) (let V2468 (shen.lazyderef (tl V2467) V2925) (if (cons? V2468) (let V2469 (shen.lazyderef (hd V2468) V2925) (if (= : V2469) (let V2470 (shen.lazyderef (tl V2468) V2925) (if (cons? V2470) (let A (hd V2470) (let V2471 (shen.lazyderef (tl V2470) V2925) (if (= () V2471) (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (if (shen.pvar? V2471) (do (shen.bindv V2471 () V2925) (let Result (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (do (shen.unbindv V2471 V2925) Result))) false)))) (if (shen.pvar? V2470) (let A (shen.newpv V2925) (do (shen.bindv V2470 (cons A ()) V2925) (let Result (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (do (shen.unbindv V2470 V2925) Result)))) false))) (if (shen.pvar? V2469) (do (shen.bindv V2469 : V2925) (let Result (let V2472 (shen.lazyderef (tl V2468) V2925) (if (cons? V2472) (let A (hd V2472) (let V2473 (shen.lazyderef (tl V2472) V2925) (if (= () V2473) (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (if (shen.pvar? V2473) (do (shen.bindv V2473 () V2925) (let Result (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (do (shen.unbindv V2473 V2925) Result))) false)))) (if (shen.pvar? V2472) (let A (shen.newpv V2925) (do (shen.bindv V2472 (cons A ()) V2925) (let Result (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (do (shen.unbindv V2472 V2925) Result)))) false))) (do (shen.unbindv V2469 V2925) Result))) false))) (if (shen.pvar? V2468) (let A (shen.newpv V2925) (do (shen.bindv V2468 (cons : (cons A ())) V2925) (let Result (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (do (shen.unbindv V2468 V2925) Result)))) false)))) (if (shen.pvar? V2467) (let Tm (shen.newpv V2925) (let A (shen.newpv V2925) (do (shen.bindv V2467 (cons Tm (cons : (cons A ()))) V2925) (let Result (let Hyp (tl V2466) (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926))))) (do (shen.unbindv V2467 V2925) Result))))) false))) (if (shen.pvar? V2466) (let Tm (shen.newpv V2925) (let A (shen.newpv V2925) (let Hyp (shen.newpv V2925) (do (shen.bindv V2466 (cons (cons Tm (cons : (cons A ()))) Hyp) V2925) (let Result (do (shen.incinfs) (unify! Tm Tm2460 V2925 (freeze (shen.tms->hyp Tms Hyp V2925 V2926)))) (do (shen.unbindv V2466 V2925) Result)))))) false))))) false)) Case)))

(defun findall (V2927 V2928 V2929 V2930 V2931) (let B (shen.newpv V2930) (let A (shen.newpv V2930) (do (shen.incinfs) (bind A (gensym shen.a) V2930 (freeze (bind B (set (shen.lazyderef A V2930) ()) V2930 (freeze (shen.findallhelp V2927 V2928 V2929 A V2930 V2931)))))))))

(defun shen.findallhelp (V2932 V2933 V2934 V2935 V2936 V2937) (let Case (do (shen.incinfs) (call V2933 V2936 (freeze (shen.remember V2935 V2932 V2936 (freeze (fwhen false V2936 V2937)))))) (if (= Case false) (do (shen.incinfs) (bind V2934 (value (shen.lazyderef V2935 V2936)) V2936 V2937)) Case)))

(defun shen.remember (V2938 V2939 V2940 V2941) (let B (shen.newpv V2940) (do (shen.incinfs) (bind B (set (shen.deref V2938 V2940) (cons (shen.deref V2939 V2940) (value (shen.deref V2938 V2940)))) V2940 V2941))))



