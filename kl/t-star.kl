"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.typecheck (V2067 V2068) (let Curry (shen.curry V2067) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2068)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2069) (cond ((and (cons? V2069) (shen.special? (hd V2069))) (cons (hd V2069) (map (lambda V1744 (shen.curry V1744)) (tl V2069)))) ((and (cons? V2069) (and (cons? (tl V2069)) (shen.extraspecial? (hd V2069)))) V2069) ((and (cons? V2069) (and (= type (hd V2069)) (and (cons? (tl V2069)) (and (cons? (tl (tl V2069))) (= () (tl (tl (tl V2069)))))))) (cons type (cons (shen.curry (hd (tl V2069))) (tl (tl V2069))))) ((and (cons? V2069) (and (cons? (tl V2069)) (cons? (tl (tl V2069))))) (shen.curry (cons (cons (hd V2069) (cons (hd (tl V2069)) ())) (tl (tl V2069))))) ((and (cons? V2069) (and (cons? (tl V2069)) (= () (tl (tl V2069))))) (cons (shen.curry (hd V2069)) (cons (shen.curry (hd (tl V2069))) ()))) (true V2069)))

(defun shen.special? (V2070) (element? V2070 (value shen.*special*)))

(defun shen.extraspecial? (V2071) (element? V2071 (value shen.*extraspecial*)))

(defun shen.t* (V2072 V2073 V2074 V2075) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2074) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2074 (freeze (bind Error (shen.errormaxinfs) V2074 V2075))))) (if (= Case false) (let Case (let V2061 (shen.lazyderef V2072 V2074) (if (= fail V2061) (do (shen.incinfs) (cut Throwcontrol V2074 (freeze (shen.prolog-failure V2074 V2075)))) false)) (if (= Case false) (let Case (let V2062 (shen.lazyderef V2072 V2074) (if (cons? V2062) (let X (hd V2062) (let V2063 (shen.lazyderef (tl V2062) V2074) (if (cons? V2063) (let V2064 (shen.lazyderef (hd V2063) V2074) (if (= : V2064) (let V2065 (shen.lazyderef (tl V2063) V2074) (if (cons? V2065) (let A (hd V2065) (let V2066 (shen.lazyderef (tl V2065) V2074) (if (= () V2066) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2074 (freeze (cut Throwcontrol V2074 (freeze (shen.th* X A V2073 V2074 V2075)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2074) (do (shen.incinfs) (shen.show V2072 V2073 V2074 (freeze (bind Datatypes (value shen.*datatypes*) V2074 (freeze (shen.udefs* V2072 V2073 Datatypes V2074 V2075))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2080) (cond ((= + V2080) (set shen.*shen-type-theory-enabled?* true)) ((= - V2080) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2089 V2090) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2091 V2092 V2093 V2094 V2095) (let Case (let V2057 (shen.lazyderef V2093 V2094) (if (cons? V2057) (let D (hd V2057) (do (shen.incinfs) (call (cons D (cons V2091 (cons V2092 ()))) V2094 V2095))) false)) (if (= Case false) (let V2058 (shen.lazyderef V2093 V2094) (if (cons? V2058) (let Ds (tl V2058) (do (shen.incinfs) (shen.udefs* V2091 V2092 Ds V2094 V2095))) false)) Case)))

(defun shen.th* (V2096 V2097 V2098 V2099 V2100) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2096 (cons : (cons V2097 ()))) V2098 V2099 (freeze (fwhen false V2099 V2100)))) (if (= Case false) (let Case (let F (shen.newpv V2099) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2096 V2099)) V2099 (freeze (bind F (shen.sigf (shen.lazyderef V2096 V2099)) V2099 (freeze (call (cons F (cons V2097 ())) V2099 V2100))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2096 V2097 V2099 V2100)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2096 V2097 V2098 V2099 V2100)) (if (= Case false) (let Case (let V1953 (shen.lazyderef V2096 V2099) (if (cons? V1953) (let F (hd V1953) (let V1954 (shen.lazyderef (tl V1953) V2099) (if (= () V1954) (do (shen.incinfs) (shen.th* F (cons --> (cons V2097 ())) V2098 V2099 V2100)) false))) false)) (if (= Case false) (let Case (let V1955 (shen.lazyderef V2096 V2099) (if (cons? V1955) (let F (hd V1955) (let V1956 (shen.lazyderef (tl V1955) V2099) (if (cons? V1956) (let X (hd V1956) (let V1957 (shen.lazyderef (tl V1956) V2099) (if (= () V1957) (let B (shen.newpv V2099) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2097 ()))) V2098 V2099 (freeze (shen.th* X B V2098 V2099 V2100))))) false))) false))) false)) (if (= Case false) (let Case (let V1958 (shen.lazyderef V2096 V2099) (if (cons? V1958) (let V1959 (shen.lazyderef (hd V1958) V2099) (if (= cons V1959) (let V1960 (shen.lazyderef (tl V1958) V2099) (if (cons? V1960) (let X (hd V1960) (let V1961 (shen.lazyderef (tl V1960) V2099) (if (cons? V1961) (let Y (hd V1961) (let V1962 (shen.lazyderef (tl V1961) V2099) (if (= () V1962) (let V1963 (shen.lazyderef V2097 V2099) (if (cons? V1963) (let V1964 (shen.lazyderef (hd V1963) V2099) (if (= list V1964) (let V1965 (shen.lazyderef (tl V1963) V2099) (if (cons? V1965) (let A (hd V1965) (let V1966 (shen.lazyderef (tl V1965) V2099) (if (= () V1966) (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (if (shen.pvar? V1966) (do (shen.bindv V1966 () V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1966 V2099) Result))) false)))) (if (shen.pvar? V1965) (let A (shen.newpv V2099) (do (shen.bindv V1965 (cons A ()) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1965 V2099) Result)))) false))) (if (shen.pvar? V1964) (do (shen.bindv V1964 list V2099) (let Result (let V1967 (shen.lazyderef (tl V1963) V2099) (if (cons? V1967) (let A (hd V1967) (let V1968 (shen.lazyderef (tl V1967) V2099) (if (= () V1968) (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (if (shen.pvar? V1968) (do (shen.bindv V1968 () V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1968 V2099) Result))) false)))) (if (shen.pvar? V1967) (let A (shen.newpv V2099) (do (shen.bindv V1967 (cons A ()) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1967 V2099) Result)))) false))) (do (shen.unbindv V1964 V2099) Result))) false))) (if (shen.pvar? V1963) (let A (shen.newpv V2099) (do (shen.bindv V1963 (cons list (cons A ())) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons list (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1963 V2099) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1969 (shen.lazyderef V2096 V2099) (if (cons? V1969) (let V1970 (shen.lazyderef (hd V1969) V2099) (if (= @p V1970) (let V1971 (shen.lazyderef (tl V1969) V2099) (if (cons? V1971) (let X (hd V1971) (let V1972 (shen.lazyderef (tl V1971) V2099) (if (cons? V1972) (let Y (hd V1972) (let V1973 (shen.lazyderef (tl V1972) V2099) (if (= () V1973) (let V1974 (shen.lazyderef V2097 V2099) (if (cons? V1974) (let A (hd V1974) (let V1975 (shen.lazyderef (tl V1974) V2099) (if (cons? V1975) (let V1976 (shen.lazyderef (hd V1975) V2099) (if (= * V1976) (let V1977 (shen.lazyderef (tl V1975) V2099) (if (cons? V1977) (let B (hd V1977) (let V1978 (shen.lazyderef (tl V1977) V2099) (if (= () V1978) (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (if (shen.pvar? V1978) (do (shen.bindv V1978 () V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (do (shen.unbindv V1978 V2099) Result))) false)))) (if (shen.pvar? V1977) (let B (shen.newpv V2099) (do (shen.bindv V1977 (cons B ()) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (do (shen.unbindv V1977 V2099) Result)))) false))) (if (shen.pvar? V1976) (do (shen.bindv V1976 * V2099) (let Result (let V1979 (shen.lazyderef (tl V1975) V2099) (if (cons? V1979) (let B (hd V1979) (let V1980 (shen.lazyderef (tl V1979) V2099) (if (= () V1980) (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (if (shen.pvar? V1980) (do (shen.bindv V1980 () V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (do (shen.unbindv V1980 V2099) Result))) false)))) (if (shen.pvar? V1979) (let B (shen.newpv V2099) (do (shen.bindv V1979 (cons B ()) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (do (shen.unbindv V1979 V2099) Result)))) false))) (do (shen.unbindv V1976 V2099) Result))) false))) (if (shen.pvar? V1975) (let B (shen.newpv V2099) (do (shen.bindv V1975 (cons * (cons B ())) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (do (shen.unbindv V1975 V2099) Result)))) false)))) (if (shen.pvar? V1974) (let A (shen.newpv V2099) (let B (shen.newpv V2099) (do (shen.bindv V1974 (cons A (cons * (cons B ()))) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y B V2098 V2099 V2100)))) (do (shen.unbindv V1974 V2099) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1981 (shen.lazyderef V2096 V2099) (if (cons? V1981) (let V1982 (shen.lazyderef (hd V1981) V2099) (if (= @v V1982) (let V1983 (shen.lazyderef (tl V1981) V2099) (if (cons? V1983) (let X (hd V1983) (let V1984 (shen.lazyderef (tl V1983) V2099) (if (cons? V1984) (let Y (hd V1984) (let V1985 (shen.lazyderef (tl V1984) V2099) (if (= () V1985) (let V1986 (shen.lazyderef V2097 V2099) (if (cons? V1986) (let V1987 (shen.lazyderef (hd V1986) V2099) (if (= vector V1987) (let V1988 (shen.lazyderef (tl V1986) V2099) (if (cons? V1988) (let A (hd V1988) (let V1989 (shen.lazyderef (tl V1988) V2099) (if (= () V1989) (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (if (shen.pvar? V1989) (do (shen.bindv V1989 () V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1989 V2099) Result))) false)))) (if (shen.pvar? V1988) (let A (shen.newpv V2099) (do (shen.bindv V1988 (cons A ()) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1988 V2099) Result)))) false))) (if (shen.pvar? V1987) (do (shen.bindv V1987 vector V2099) (let Result (let V1990 (shen.lazyderef (tl V1986) V2099) (if (cons? V1990) (let A (hd V1990) (let V1991 (shen.lazyderef (tl V1990) V2099) (if (= () V1991) (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (if (shen.pvar? V1991) (do (shen.bindv V1991 () V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1991 V2099) Result))) false)))) (if (shen.pvar? V1990) (let A (shen.newpv V2099) (do (shen.bindv V1990 (cons A ()) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1990 V2099) Result)))) false))) (do (shen.unbindv V1987 V2099) Result))) false))) (if (shen.pvar? V1986) (let A (shen.newpv V2099) (do (shen.bindv V1986 (cons vector (cons A ())) V2099) (let Result (do (shen.incinfs) (shen.th* X A V2098 V2099 (freeze (shen.th* Y (cons vector (cons A ())) V2098 V2099 V2100)))) (do (shen.unbindv V1986 V2099) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1992 (shen.lazyderef V2096 V2099) (if (cons? V1992) (let V1993 (shen.lazyderef (hd V1992) V2099) (if (= @s V1993) (let V1994 (shen.lazyderef (tl V1992) V2099) (if (cons? V1994) (let X (hd V1994) (let V1995 (shen.lazyderef (tl V1994) V2099) (if (cons? V1995) (let Y (hd V1995) (let V1996 (shen.lazyderef (tl V1995) V2099) (if (= () V1996) (let V1997 (shen.lazyderef V2097 V2099) (if (= string V1997) (do (shen.incinfs) (shen.th* X string V2098 V2099 (freeze (shen.th* Y string V2098 V2099 V2100)))) (if (shen.pvar? V1997) (do (shen.bindv V1997 string V2099) (let Result (do (shen.incinfs) (shen.th* X string V2098 V2099 (freeze (shen.th* Y string V2098 V2099 V2100)))) (do (shen.unbindv V1997 V2099) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1998 (shen.lazyderef V2096 V2099) (if (cons? V1998) (let V1999 (shen.lazyderef (hd V1998) V2099) (if (= lambda V1999) (let V2000 (shen.lazyderef (tl V1998) V2099) (if (cons? V2000) (let X (hd V2000) (let V2001 (shen.lazyderef (tl V2000) V2099) (if (cons? V2001) (let Y (hd V2001) (let V2002 (shen.lazyderef (tl V2001) V2099) (if (= () V2002) (let V2003 (shen.lazyderef V2097 V2099) (if (cons? V2003) (let A (hd V2003) (let V2004 (shen.lazyderef (tl V2003) V2099) (if (cons? V2004) (let V2005 (shen.lazyderef (hd V2004) V2099) (if (= --> V2005) (let V2006 (shen.lazyderef (tl V2004) V2099) (if (cons? V2006) (let B (hd V2006) (let V2007 (shen.lazyderef (tl V2006) V2099) (if (= () V2007) (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (if (shen.pvar? V2007) (do (shen.bindv V2007 () V2099) (let Result (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (do (shen.unbindv V2007 V2099) Result))) false)))) (if (shen.pvar? V2006) (let B (shen.newpv V2099) (do (shen.bindv V2006 (cons B ()) V2099) (let Result (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (do (shen.unbindv V2006 V2099) Result)))) false))) (if (shen.pvar? V2005) (do (shen.bindv V2005 --> V2099) (let Result (let V2008 (shen.lazyderef (tl V2004) V2099) (if (cons? V2008) (let B (hd V2008) (let V2009 (shen.lazyderef (tl V2008) V2099) (if (= () V2009) (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (if (shen.pvar? V2009) (do (shen.bindv V2009 () V2099) (let Result (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (do (shen.unbindv V2009 V2099) Result))) false)))) (if (shen.pvar? V2008) (let B (shen.newpv V2099) (do (shen.bindv V2008 (cons B ()) V2099) (let Result (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (do (shen.unbindv V2008 V2099) Result)))) false))) (do (shen.unbindv V2005 V2099) Result))) false))) (if (shen.pvar? V2004) (let B (shen.newpv V2099) (do (shen.bindv V2004 (cons --> (cons B ())) V2099) (let Result (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (do (shen.unbindv V2004 V2099) Result)))) false)))) (if (shen.pvar? V2003) (let A (shen.newpv V2099) (let B (shen.newpv V2099) (do (shen.bindv V2003 (cons A (cons --> (cons B ()))) V2099) (let Result (let Z (shen.newpv V2099) (let X&& (shen.newpv V2099) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Y V2099)) V2099 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2098) V2099 V2100)))))))))) (do (shen.unbindv V2003 V2099) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2010 (shen.lazyderef V2096 V2099) (if (cons? V2010) (let V2011 (shen.lazyderef (hd V2010) V2099) (if (= let V2011) (let V2012 (shen.lazyderef (tl V2010) V2099) (if (cons? V2012) (let X (hd V2012) (let V2013 (shen.lazyderef (tl V2012) V2099) (if (cons? V2013) (let Y (hd V2013) (let V2014 (shen.lazyderef (tl V2013) V2099) (if (cons? V2014) (let Z (hd V2014) (let V2015 (shen.lazyderef (tl V2014) V2099) (if (= () V2015) (let W (shen.newpv V2099) (let X&& (shen.newpv V2099) (let B (shen.newpv V2099) (do (shen.incinfs) (shen.th* Y B V2098 V2099 (freeze (bind X&& (shen.placeholder) V2099 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2099) (shen.lazyderef X V2099) (shen.lazyderef Z V2099)) V2099 (freeze (shen.th* W V2097 (cons (cons X&& (cons : (cons B ()))) V2098) V2099 V2100))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2016 (shen.lazyderef V2096 V2099) (if (cons? V2016) (let V2017 (shen.lazyderef (hd V2016) V2099) (if (= open V2017) (let V2018 (shen.lazyderef (tl V2016) V2099) (if (cons? V2018) (let FileName (hd V2018) (let V2019 (shen.lazyderef (tl V2018) V2099) (if (cons? V2019) (let Direction1949 (hd V2019) (let V2020 (shen.lazyderef (tl V2019) V2099) (if (= () V2020) (let V2021 (shen.lazyderef V2097 V2099) (if (cons? V2021) (let V2022 (shen.lazyderef (hd V2021) V2099) (if (= stream V2022) (let V2023 (shen.lazyderef (tl V2021) V2099) (if (cons? V2023) (let Direction (hd V2023) (let V2024 (shen.lazyderef (tl V2023) V2099) (if (= () V2024) (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (if (shen.pvar? V2024) (do (shen.bindv V2024 () V2099) (let Result (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (do (shen.unbindv V2024 V2099) Result))) false)))) (if (shen.pvar? V2023) (let Direction (shen.newpv V2099) (do (shen.bindv V2023 (cons Direction ()) V2099) (let Result (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (do (shen.unbindv V2023 V2099) Result)))) false))) (if (shen.pvar? V2022) (do (shen.bindv V2022 stream V2099) (let Result (let V2025 (shen.lazyderef (tl V2021) V2099) (if (cons? V2025) (let Direction (hd V2025) (let V2026 (shen.lazyderef (tl V2025) V2099) (if (= () V2026) (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (if (shen.pvar? V2026) (do (shen.bindv V2026 () V2099) (let Result (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (do (shen.unbindv V2026 V2099) Result))) false)))) (if (shen.pvar? V2025) (let Direction (shen.newpv V2099) (do (shen.bindv V2025 (cons Direction ()) V2099) (let Result (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (do (shen.unbindv V2025 V2099) Result)))) false))) (do (shen.unbindv V2022 V2099) Result))) false))) (if (shen.pvar? V2021) (let Direction (shen.newpv V2099) (do (shen.bindv V2021 (cons stream (cons Direction ())) V2099) (let Result (do (shen.incinfs) (unify! Direction Direction1949 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* FileName string V2098 V2099 V2100)))))) (do (shen.unbindv V2021 V2099) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2027 (shen.lazyderef V2096 V2099) (if (cons? V2027) (let V2028 (shen.lazyderef (hd V2027) V2099) (if (= type V2028) (let V2029 (shen.lazyderef (tl V2027) V2099) (if (cons? V2029) (let X (hd V2029) (let V2030 (shen.lazyderef (tl V2029) V2099) (if (cons? V2030) (let A (hd V2030) (let V2031 (shen.lazyderef (tl V2030) V2099) (if (= () V2031) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (unify A V2097 V2099 (freeze (shen.th* X A V2098 V2099 V2100)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2032 (shen.lazyderef V2096 V2099) (if (cons? V2032) (let V2033 (shen.lazyderef (hd V2032) V2099) (if (= input+ V2033) (let V2034 (shen.lazyderef (tl V2032) V2099) (if (cons? V2034) (let A (hd V2034) (let V2035 (shen.lazyderef (tl V2034) V2099) (if (cons? V2035) (let Stream (hd V2035) (let V2036 (shen.lazyderef (tl V2035) V2099) (if (= () V2036) (let C (shen.newpv V2099) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2099)) V2099 (freeze (unify V2097 C V2099 (freeze (shen.th* Stream (cons stream (cons in ())) V2098 V2099 V2100))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2037 (shen.lazyderef V2096 V2099) (if (cons? V2037) (let V2038 (shen.lazyderef (hd V2037) V2099) (if (= set V2038) (let V2039 (shen.lazyderef (tl V2037) V2099) (if (cons? V2039) (let Var (hd V2039) (let V2040 (shen.lazyderef (tl V2039) V2099) (if (cons? V2040) (let Val (hd V2040) (let V2041 (shen.lazyderef (tl V2040) V2099) (if (= () V2041) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (shen.th* Var symbol V2098 V2099 (freeze (cut Throwcontrol V2099 (freeze (shen.th* (cons value (cons Var ())) V2097 V2098 V2099 (freeze (shen.th* Val V2097 V2098 V2099 V2100)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2099) (do (shen.incinfs) (shen.t*-hyps V2098 NewHyp V2099 (freeze (shen.th* V2096 V2097 NewHyp V2099 V2100))))) (if (= Case false) (let Case (let V2042 (shen.lazyderef V2096 V2099) (if (cons? V2042) (let V2043 (shen.lazyderef (hd V2042) V2099) (if (= define V2043) (let V2044 (shen.lazyderef (tl V2042) V2099) (if (cons? V2044) (let F (hd V2044) (let X (tl V2044) (do (shen.incinfs) (cut Throwcontrol V2099 (freeze (shen.t*-def (cons define (cons F X)) V2097 V2098 V2099 V2100)))))) false)) false)) false)) (if (= Case false) (let Case (let V2045 (shen.lazyderef V2096 V2099) (if (cons? V2045) (let V2046 (shen.lazyderef (hd V2045) V2099) (if (= defmacro V2046) (let V2047 (shen.lazyderef V2097 V2099) (if (= unit V2047) (do (shen.incinfs) (cut Throwcontrol V2099 V2100)) (if (shen.pvar? V2047) (do (shen.bindv V2047 unit V2099) (let Result (do (shen.incinfs) (cut Throwcontrol V2099 V2100)) (do (shen.unbindv V2047 V2099) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2048 (shen.lazyderef V2096 V2099) (if (cons? V2048) (let V2049 (shen.lazyderef (hd V2048) V2099) (if (= shen.process-datatype V2049) (let V2050 (shen.lazyderef V2097 V2099) (if (= symbol V2050) (do (shen.incinfs) (thaw V2100)) (if (shen.pvar? V2050) (do (shen.bindv V2050 symbol V2099) (let Result (do (shen.incinfs) (thaw V2100)) (do (shen.unbindv V2050 V2099) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2051 (shen.lazyderef V2096 V2099) (if (cons? V2051) (let V2052 (shen.lazyderef (hd V2051) V2099) (if (= shen.synonyms-help V2052) (let V2053 (shen.lazyderef V2097 V2099) (if (= symbol V2053) (do (shen.incinfs) (thaw V2100)) (if (shen.pvar? V2053) (do (shen.bindv V2053 symbol V2099) (let Result (do (shen.incinfs) (thaw V2100)) (do (shen.unbindv V2053 V2099) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2099) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2099 (freeze (shen.udefs* (cons V2096 (cons : (cons V2097 ()))) V2098 Datatypes V2099 V2100))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2101 V2102 V2103 V2104) (let Case (let V1864 (shen.lazyderef V2101 V2103) (if (cons? V1864) (let V1865 (shen.lazyderef (hd V1864) V2103) (if (cons? V1865) (let V1866 (shen.lazyderef (hd V1865) V2103) (if (cons? V1866) (let V1867 (shen.lazyderef (hd V1866) V2103) (if (= cons V1867) (let V1868 (shen.lazyderef (tl V1866) V2103) (if (cons? V1868) (let X (hd V1868) (let V1869 (shen.lazyderef (tl V1868) V2103) (if (cons? V1869) (let Y (hd V1869) (let V1870 (shen.lazyderef (tl V1869) V2103) (if (= () V1870) (let V1871 (shen.lazyderef (tl V1865) V2103) (if (cons? V1871) (let V1872 (shen.lazyderef (hd V1871) V2103) (if (= : V1872) (let V1873 (shen.lazyderef (tl V1871) V2103) (if (cons? V1873) (let V1874 (shen.lazyderef (hd V1873) V2103) (if (cons? V1874) (let V1875 (shen.lazyderef (hd V1874) V2103) (if (= list V1875) (let V1876 (shen.lazyderef (tl V1874) V2103) (if (cons? V1876) (let A (hd V1876) (let V1877 (shen.lazyderef (tl V1876) V2103) (if (= () V1877) (let V1878 (shen.lazyderef (tl V1873) V2103) (if (= () V1878) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1878) (do (shen.bindv V1878 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1878 V2103) Result))) false))) (if (shen.pvar? V1877) (do (shen.bindv V1877 () V2103) (let Result (let V1879 (shen.lazyderef (tl V1873) V2103) (if (= () V1879) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1879) (do (shen.bindv V1879 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1879 V2103) Result))) false))) (do (shen.unbindv V1877 V2103) Result))) false)))) (if (shen.pvar? V1876) (let A (shen.newpv V2103) (do (shen.bindv V1876 (cons A ()) V2103) (let Result (let V1880 (shen.lazyderef (tl V1873) V2103) (if (= () V1880) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1880) (do (shen.bindv V1880 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1880 V2103) Result))) false))) (do (shen.unbindv V1876 V2103) Result)))) false))) (if (shen.pvar? V1875) (do (shen.bindv V1875 list V2103) (let Result (let V1881 (shen.lazyderef (tl V1874) V2103) (if (cons? V1881) (let A (hd V1881) (let V1882 (shen.lazyderef (tl V1881) V2103) (if (= () V1882) (let V1883 (shen.lazyderef (tl V1873) V2103) (if (= () V1883) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1883) (do (shen.bindv V1883 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1883 V2103) Result))) false))) (if (shen.pvar? V1882) (do (shen.bindv V1882 () V2103) (let Result (let V1884 (shen.lazyderef (tl V1873) V2103) (if (= () V1884) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1884) (do (shen.bindv V1884 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1884 V2103) Result))) false))) (do (shen.unbindv V1882 V2103) Result))) false)))) (if (shen.pvar? V1881) (let A (shen.newpv V2103) (do (shen.bindv V1881 (cons A ()) V2103) (let Result (let V1885 (shen.lazyderef (tl V1873) V2103) (if (= () V1885) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1885) (do (shen.bindv V1885 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1885 V2103) Result))) false))) (do (shen.unbindv V1881 V2103) Result)))) false))) (do (shen.unbindv V1875 V2103) Result))) false))) (if (shen.pvar? V1874) (let A (shen.newpv V2103) (do (shen.bindv V1874 (cons list (cons A ())) V2103) (let Result (let V1886 (shen.lazyderef (tl V1873) V2103) (if (= () V1886) (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1886) (do (shen.bindv V1886 () V2103) (let Result (let Hyp (tl V1864) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons list (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1886 V2103) Result))) false))) (do (shen.unbindv V1874 V2103) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1887 (shen.lazyderef V2101 V2103) (if (cons? V1887) (let V1888 (shen.lazyderef (hd V1887) V2103) (if (cons? V1888) (let V1889 (shen.lazyderef (hd V1888) V2103) (if (cons? V1889) (let V1890 (shen.lazyderef (hd V1889) V2103) (if (= @p V1890) (let V1891 (shen.lazyderef (tl V1889) V2103) (if (cons? V1891) (let X (hd V1891) (let V1892 (shen.lazyderef (tl V1891) V2103) (if (cons? V1892) (let Y (hd V1892) (let V1893 (shen.lazyderef (tl V1892) V2103) (if (= () V1893) (let V1894 (shen.lazyderef (tl V1888) V2103) (if (cons? V1894) (let V1895 (shen.lazyderef (hd V1894) V2103) (if (= : V1895) (let V1896 (shen.lazyderef (tl V1894) V2103) (if (cons? V1896) (let V1897 (shen.lazyderef (hd V1896) V2103) (if (cons? V1897) (let A (hd V1897) (let V1898 (shen.lazyderef (tl V1897) V2103) (if (cons? V1898) (let V1899 (shen.lazyderef (hd V1898) V2103) (if (= * V1899) (let V1900 (shen.lazyderef (tl V1898) V2103) (if (cons? V1900) (let B (hd V1900) (let V1901 (shen.lazyderef (tl V1900) V2103) (if (= () V1901) (let V1902 (shen.lazyderef (tl V1896) V2103) (if (= () V1902) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1902) (do (shen.bindv V1902 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1902 V2103) Result))) false))) (if (shen.pvar? V1901) (do (shen.bindv V1901 () V2103) (let Result (let V1903 (shen.lazyderef (tl V1896) V2103) (if (= () V1903) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1903) (do (shen.bindv V1903 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1903 V2103) Result))) false))) (do (shen.unbindv V1901 V2103) Result))) false)))) (if (shen.pvar? V1900) (let B (shen.newpv V2103) (do (shen.bindv V1900 (cons B ()) V2103) (let Result (let V1904 (shen.lazyderef (tl V1896) V2103) (if (= () V1904) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1904) (do (shen.bindv V1904 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1904 V2103) Result))) false))) (do (shen.unbindv V1900 V2103) Result)))) false))) (if (shen.pvar? V1899) (do (shen.bindv V1899 * V2103) (let Result (let V1905 (shen.lazyderef (tl V1898) V2103) (if (cons? V1905) (let B (hd V1905) (let V1906 (shen.lazyderef (tl V1905) V2103) (if (= () V1906) (let V1907 (shen.lazyderef (tl V1896) V2103) (if (= () V1907) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1907) (do (shen.bindv V1907 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1907 V2103) Result))) false))) (if (shen.pvar? V1906) (do (shen.bindv V1906 () V2103) (let Result (let V1908 (shen.lazyderef (tl V1896) V2103) (if (= () V1908) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1908) (do (shen.bindv V1908 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1908 V2103) Result))) false))) (do (shen.unbindv V1906 V2103) Result))) false)))) (if (shen.pvar? V1905) (let B (shen.newpv V2103) (do (shen.bindv V1905 (cons B ()) V2103) (let Result (let V1909 (shen.lazyderef (tl V1896) V2103) (if (= () V1909) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1909) (do (shen.bindv V1909 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1909 V2103) Result))) false))) (do (shen.unbindv V1905 V2103) Result)))) false))) (do (shen.unbindv V1899 V2103) Result))) false))) (if (shen.pvar? V1898) (let B (shen.newpv V2103) (do (shen.bindv V1898 (cons * (cons B ())) V2103) (let Result (let V1910 (shen.lazyderef (tl V1896) V2103) (if (= () V1910) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1910) (do (shen.bindv V1910 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1910 V2103) Result))) false))) (do (shen.unbindv V1898 V2103) Result)))) false)))) (if (shen.pvar? V1897) (let A (shen.newpv V2103) (let B (shen.newpv V2103) (do (shen.bindv V1897 (cons A (cons * (cons B ()))) V2103) (let Result (let V1911 (shen.lazyderef (tl V1896) V2103) (if (= () V1911) (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1911) (do (shen.bindv V1911 () V2103) (let Result (let Hyp (tl V1887) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (shen.lazyderef B V2103) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1911 V2103) Result))) false))) (do (shen.unbindv V1897 V2103) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1912 (shen.lazyderef V2101 V2103) (if (cons? V1912) (let V1913 (shen.lazyderef (hd V1912) V2103) (if (cons? V1913) (let V1914 (shen.lazyderef (hd V1913) V2103) (if (cons? V1914) (let V1915 (shen.lazyderef (hd V1914) V2103) (if (= @v V1915) (let V1916 (shen.lazyderef (tl V1914) V2103) (if (cons? V1916) (let X (hd V1916) (let V1917 (shen.lazyderef (tl V1916) V2103) (if (cons? V1917) (let Y (hd V1917) (let V1918 (shen.lazyderef (tl V1917) V2103) (if (= () V1918) (let V1919 (shen.lazyderef (tl V1913) V2103) (if (cons? V1919) (let V1920 (shen.lazyderef (hd V1919) V2103) (if (= : V1920) (let V1921 (shen.lazyderef (tl V1919) V2103) (if (cons? V1921) (let V1922 (shen.lazyderef (hd V1921) V2103) (if (cons? V1922) (let V1923 (shen.lazyderef (hd V1922) V2103) (if (= vector V1923) (let V1924 (shen.lazyderef (tl V1922) V2103) (if (cons? V1924) (let A (hd V1924) (let V1925 (shen.lazyderef (tl V1924) V2103) (if (= () V1925) (let V1926 (shen.lazyderef (tl V1921) V2103) (if (= () V1926) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1926) (do (shen.bindv V1926 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1926 V2103) Result))) false))) (if (shen.pvar? V1925) (do (shen.bindv V1925 () V2103) (let Result (let V1927 (shen.lazyderef (tl V1921) V2103) (if (= () V1927) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1927) (do (shen.bindv V1927 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1927 V2103) Result))) false))) (do (shen.unbindv V1925 V2103) Result))) false)))) (if (shen.pvar? V1924) (let A (shen.newpv V2103) (do (shen.bindv V1924 (cons A ()) V2103) (let Result (let V1928 (shen.lazyderef (tl V1921) V2103) (if (= () V1928) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1928) (do (shen.bindv V1928 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1928 V2103) Result))) false))) (do (shen.unbindv V1924 V2103) Result)))) false))) (if (shen.pvar? V1923) (do (shen.bindv V1923 vector V2103) (let Result (let V1929 (shen.lazyderef (tl V1922) V2103) (if (cons? V1929) (let A (hd V1929) (let V1930 (shen.lazyderef (tl V1929) V2103) (if (= () V1930) (let V1931 (shen.lazyderef (tl V1921) V2103) (if (= () V1931) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1931) (do (shen.bindv V1931 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1931 V2103) Result))) false))) (if (shen.pvar? V1930) (do (shen.bindv V1930 () V2103) (let Result (let V1932 (shen.lazyderef (tl V1921) V2103) (if (= () V1932) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1932) (do (shen.bindv V1932 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1932 V2103) Result))) false))) (do (shen.unbindv V1930 V2103) Result))) false)))) (if (shen.pvar? V1929) (let A (shen.newpv V2103) (do (shen.bindv V1929 (cons A ()) V2103) (let Result (let V1933 (shen.lazyderef (tl V1921) V2103) (if (= () V1933) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1933) (do (shen.bindv V1933 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1933 V2103) Result))) false))) (do (shen.unbindv V1929 V2103) Result)))) false))) (do (shen.unbindv V1923 V2103) Result))) false))) (if (shen.pvar? V1922) (let A (shen.newpv V2103) (do (shen.bindv V1922 (cons vector (cons A ())) V2103) (let Result (let V1934 (shen.lazyderef (tl V1921) V2103) (if (= () V1934) (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1934) (do (shen.bindv V1934 () V2103) (let Result (let Hyp (tl V1912) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons (shen.lazyderef A V2103) ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons (cons vector (cons (shen.lazyderef A V2103) ())) ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1934 V2103) Result))) false))) (do (shen.unbindv V1922 V2103) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1935 (shen.lazyderef V2101 V2103) (if (cons? V1935) (let V1936 (shen.lazyderef (hd V1935) V2103) (if (cons? V1936) (let V1937 (shen.lazyderef (hd V1936) V2103) (if (cons? V1937) (let V1938 (shen.lazyderef (hd V1937) V2103) (if (= @s V1938) (let V1939 (shen.lazyderef (tl V1937) V2103) (if (cons? V1939) (let X (hd V1939) (let V1940 (shen.lazyderef (tl V1939) V2103) (if (cons? V1940) (let Y (hd V1940) (let V1941 (shen.lazyderef (tl V1940) V2103) (if (= () V1941) (let V1942 (shen.lazyderef (tl V1936) V2103) (if (cons? V1942) (let V1943 (shen.lazyderef (hd V1942) V2103) (if (= : V1943) (let V1944 (shen.lazyderef (tl V1942) V2103) (if (cons? V1944) (let V1945 (shen.lazyderef (hd V1944) V2103) (if (= string V1945) (let V1946 (shen.lazyderef (tl V1944) V2103) (if (= () V1946) (let Hyp (tl V1935) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons string ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1946) (do (shen.bindv V1946 () V2103) (let Result (let Hyp (tl V1935) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons string ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1946 V2103) Result))) false))) (if (shen.pvar? V1945) (do (shen.bindv V1945 string V2103) (let Result (let V1947 (shen.lazyderef (tl V1944) V2103) (if (= () V1947) (let Hyp (tl V1935) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons string ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (if (shen.pvar? V1947) (do (shen.bindv V1947 () V2103) (let Result (let Hyp (tl V1935) (do (shen.incinfs) (bind V2102 (cons (cons (shen.lazyderef X V2103) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2103) (cons : (cons string ()))) (shen.lazyderef Hyp V2103))) V2103 V2104))) (do (shen.unbindv V1947 V2103) Result))) false))) (do (shen.unbindv V1945 V2103) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V1948 (shen.lazyderef V2101 V2103) (if (cons? V1948) (let X (hd V1948) (let Hyp (tl V1948) (let NewHyps (shen.newpv V2103) (do (shen.incinfs) (bind V2102 (cons (shen.lazyderef X V2103) (shen.lazyderef NewHyps V2103)) V2103 (freeze (shen.t*-hyps Hyp NewHyps V2103 V2104))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2117 V2118 V2119 V2120) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2117 V2119)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2118 V2119) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2120))))))))) (true (thaw V2120))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2121) (cond ((and (cons? V2121) (and (cons? (tl V2121)) (and (= : (hd (tl V2121))) (and (cons? (tl (tl V2121))) (= () (tl (tl (tl V2121)))))))) (shen.prhush (shen.app (hd V2121) (cn " : " (shen.app (hd (tl (tl V2121))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2121 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2124 V2125) (cond ((= () V2124) shen.skip) ((cons? V2124) (do (shen.prhush (shen.app V2125 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2124)) (do (nl 1) (shen.show-assumptions (tl V2124) (+ V2125 1)))))) (true (shen.f_error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (read-byte (stinput)) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2126) (cons? (assoc V2126 (value shen.*signedfuncs*))))

(defun shen.sigf (V2127) (concat shen.type-signature-of- V2127))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2128 V2129 V2130 V2131) (let Case (let V1851 (shen.lazyderef V2129 V2130) (if (= number V1851) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2128 V2130)) V2130 V2131)) (if (shen.pvar? V1851) (do (shen.bindv V1851 number V2130) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2128 V2130)) V2130 V2131)) (do (shen.unbindv V1851 V2130) Result))) false))) (if (= Case false) (let Case (let V1852 (shen.lazyderef V2129 V2130) (if (= boolean V1852) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2128 V2130)) V2130 V2131)) (if (shen.pvar? V1852) (do (shen.bindv V1852 boolean V2130) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2128 V2130)) V2130 V2131)) (do (shen.unbindv V1852 V2130) Result))) false))) (if (= Case false) (let Case (let V1853 (shen.lazyderef V2129 V2130) (if (= string V1853) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2128 V2130)) V2130 V2131)) (if (shen.pvar? V1853) (do (shen.bindv V1853 string V2130) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2128 V2130)) V2130 V2131)) (do (shen.unbindv V1853 V2130) Result))) false))) (if (= Case false) (let Case (let V1854 (shen.lazyderef V2129 V2130) (if (= symbol V1854) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2128 V2130)) V2130 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2128 V2130))) V2130 V2131)))) (if (shen.pvar? V1854) (do (shen.bindv V1854 symbol V2130) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2128 V2130)) V2130 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2128 V2130))) V2130 V2131)))) (do (shen.unbindv V1854 V2130) Result))) false))) (if (= Case false) (let V1855 (shen.lazyderef V2128 V2130) (if (= () V1855) (let V1856 (shen.lazyderef V2129 V2130) (if (cons? V1856) (let V1857 (shen.lazyderef (hd V1856) V2130) (if (= list V1857) (let V1858 (shen.lazyderef (tl V1856) V2130) (if (cons? V1858) (let A (hd V1858) (let V1859 (shen.lazyderef (tl V1858) V2130) (if (= () V1859) (do (shen.incinfs) (thaw V2131)) (if (shen.pvar? V1859) (do (shen.bindv V1859 () V2130) (let Result (do (shen.incinfs) (thaw V2131)) (do (shen.unbindv V1859 V2130) Result))) false)))) (if (shen.pvar? V1858) (let A (shen.newpv V2130) (do (shen.bindv V1858 (cons A ()) V2130) (let Result (do (shen.incinfs) (thaw V2131)) (do (shen.unbindv V1858 V2130) Result)))) false))) (if (shen.pvar? V1857) (do (shen.bindv V1857 list V2130) (let Result (let V1860 (shen.lazyderef (tl V1856) V2130) (if (cons? V1860) (let A (hd V1860) (let V1861 (shen.lazyderef (tl V1860) V2130) (if (= () V1861) (do (shen.incinfs) (thaw V2131)) (if (shen.pvar? V1861) (do (shen.bindv V1861 () V2130) (let Result (do (shen.incinfs) (thaw V2131)) (do (shen.unbindv V1861 V2130) Result))) false)))) (if (shen.pvar? V1860) (let A (shen.newpv V2130) (do (shen.bindv V1860 (cons A ()) V2130) (let Result (do (shen.incinfs) (thaw V2131)) (do (shen.unbindv V1860 V2130) Result)))) false))) (do (shen.unbindv V1857 V2130) Result))) false))) (if (shen.pvar? V1856) (let A (shen.newpv V2130) (do (shen.bindv V1856 (cons list (cons A ())) V2130) (let Result (do (shen.incinfs) (thaw V2131)) (do (shen.unbindv V1856 V2130) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2132 V2133 V2134 V2135 V2136) (let Case (let V1842 (shen.lazyderef V2134 V2135) (if (cons? V1842) (let V1843 (shen.lazyderef (hd V1842) V2135) (if (cons? V1843) (let Y (hd V1843) (let V1844 (shen.lazyderef (tl V1843) V2135) (if (cons? V1844) (let V1845 (shen.lazyderef (hd V1844) V2135) (if (= : V1845) (let V1846 (shen.lazyderef (tl V1844) V2135) (if (cons? V1846) (let B (hd V1846) (let V1847 (shen.lazyderef (tl V1846) V2135) (if (= () V1847) (do (shen.incinfs) (identical V2132 Y V2135 (freeze (unify! V2133 B V2135 V2136)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V1848 (shen.lazyderef V2134 V2135) (if (cons? V1848) (let Hyp (tl V1848) (do (shen.incinfs) (shen.by_hypothesis V2132 V2133 Hyp V2135 V2136))) false)) Case)))

(defun shen.t*-def (V2137 V2138 V2139 V2140 V2141) (let V1836 (shen.lazyderef V2137 V2140) (if (cons? V1836) (let V1837 (shen.lazyderef (hd V1836) V2140) (if (= define V1837) (let V1838 (shen.lazyderef (tl V1836) V2140) (if (cons? V1838) (let F (hd V1838) (let X (tl V1838) (let V1745 (shen.newpv V2140) (let E (shen.newpv V2140) (do (shen.incinfs) (shen.t*-defh (compile (lambda V1745 (shen.<sig+rules> V1745)) X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2138 V2139 V2140 V2141)))))) false)) false)) false)))

(defun shen.t*-defh (V2142 V2143 V2144 V2145 V2146 V2147) (let V1832 (shen.lazyderef V2142 V2146) (if (cons? V1832) (let Sig (hd V1832) (let Rules (tl V1832) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2143 V2144 V2145 Rules V2146 V2147)))) false)))

(defun shen.t*-defhh (V2148 V2149 V2150 V2151 V2152 V2153 V2154 V2155) (do (shen.incinfs) (shen.t*-rules V2153 V2149 1 V2150 (cons (cons V2150 (cons : (cons V2149 ()))) V2152) V2154 (freeze (shen.memo V2150 V2148 V2151 V2154 V2155)))))

(defun shen.memo (V2156 V2157 V2158 V2159 V2160) (let Jnk (shen.newpv V2159) (do (shen.incinfs) (unify! V2158 V2157 V2159 (freeze (bind Jnk (declare (shen.lazyderef V2156 V2159) (shen.lazyderef V2158 V2159)) V2159 V2160))))))

(defun shen.<sig+rules> (V2161) (let Parse_shen.<signature> (shen.<signature> V2161) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))))

(defun shen.<non-ll-rules> (V2162) (let YaccParse (let Parse_shen.<rule> (shen.<rule> V2162) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<non-ll-rules> (shen.<non-ll-rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<non-ll-rules>)) (shen.pair (hd Parse_shen.<non-ll-rules>) (cons (shen.hdtl Parse_shen.<rule>) (shen.hdtl Parse_shen.<non-ll-rules>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<rule> (shen.<rule> V2162) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.hdtl Parse_shen.<rule>) ())) (fail))) YaccParse)))

(defun shen.ue (V2163) (cond ((and (cons? V2163) (and (cons? (tl V2163)) (and (= () (tl (tl V2163))) (= (hd V2163) protect)))) V2163) ((cons? V2163) (map (lambda V1746 (shen.ue V1746)) V2163)) ((variable? V2163) (concat && V2163)) (true V2163)))

(defun shen.ue-sig (V2164) (cond ((cons? V2164) (map (lambda V1747 (shen.ue-sig V1747)) V2164)) ((variable? V2164) (concat &&& V2164)) (true V2164)))

(defun shen.ues (V2169) (cond ((shen.ue? V2169) (cons V2169 ())) ((cons? V2169) (union (shen.ues (hd V2169)) (shen.ues (tl V2169)))) (true ())))

(defun shen.ue? (V2170) (and (symbol? V2170) (shen.ue-h? (str V2170))))

(defun shen.ue-h? (V2177) (cond ((and (shen.+string? V2177) (and (= "&" (pos V2177 0)) (and (shen.+string? (tlstr V2177)) (= "&" (pos (tlstr V2177) 0))))) true) (true false)))

(defun shen.t*-rules (V2178 V2179 V2180 V2181 V2182 V2183 V2184) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1816 (shen.lazyderef V2178 V2183) (if (= () V1816) (do (shen.incinfs) (thaw V2184)) false)) (if (= Case false) (let Case (let V1817 (shen.lazyderef V2178 V2183) (if (cons? V1817) (let Rule (hd V1817) (let Rules (tl V1817) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2179 V2182 V2183 (freeze (cut Throwcontrol V2183 (freeze (shen.t*-rules Rules V2179 (+ V2180 1) V2181 V2182 V2183 V2184)))))))) false)) (if (= Case false) (let Err (shen.newpv V2183) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2180 V2183) (cn " of " (shen.app (shen.lazyderef V2181 V2183) "" shen.a)) shen.a))) V2183 V2184))) Case)) Case)))))

(defun shen.t*-rule (V2185 V2186 V2187 V2188 V2189) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V1808 (shen.lazyderef V2185 V2188) (if (cons? V1808) (let Patterns (hd V1808) (let V1809 (shen.lazyderef (tl V1808) V2188) (if (cons? V1809) (let Action (hd V1809) (let V1810 (shen.lazyderef (tl V1809) V2188) (if (= () V1810) (let NewHyps (shen.newpv V2188) (do (shen.incinfs) (shen.newhyps (shen.placeholders Patterns) V2187 NewHyps V2188 (freeze (shen.t*-patterns Patterns V2186 NewHyps V2188 (freeze (cut Throwcontrol V2188 (freeze (shen.t*-action (shen.curry (shen.ue Action)) (shen.result-type Patterns V2186) (shen.patthyps Patterns V2186 V2187) V2188 V2189))))))))) false))) false))) false)))))

(defun shen.placeholders (V2194) (cond ((shen.ue? V2194) (cons V2194 ())) ((cons? V2194) (union (shen.placeholders (hd V2194)) (shen.placeholders (tl V2194)))) (true ())))

(defun shen.newhyps (V2195 V2196 V2197 V2198 V2199) (let Case (let V1795 (shen.lazyderef V2195 V2198) (if (= () V1795) (do (shen.incinfs) (unify! V2197 V2196 V2198 V2199)) false)) (if (= Case false) (let V1796 (shen.lazyderef V2195 V2198) (if (cons? V1796) (let V1791 (hd V1796) (let Vs (tl V1796) (let V1797 (shen.lazyderef V2197 V2198) (if (cons? V1797) (let V1798 (shen.lazyderef (hd V1797) V2198) (if (cons? V1798) (let V (hd V1798) (let V1799 (shen.lazyderef (tl V1798) V2198) (if (cons? V1799) (let V1800 (shen.lazyderef (hd V1799) V2198) (if (= : V1800) (let V1801 (shen.lazyderef (tl V1799) V2198) (if (cons? V1801) (let A (hd V1801) (let V1802 (shen.lazyderef (tl V1801) V2198) (if (= () V1802) (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (if (shen.pvar? V1802) (do (shen.bindv V1802 () V2198) (let Result (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (do (shen.unbindv V1802 V2198) Result))) false)))) (if (shen.pvar? V1801) (let A (shen.newpv V2198) (do (shen.bindv V1801 (cons A ()) V2198) (let Result (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (do (shen.unbindv V1801 V2198) Result)))) false))) (if (shen.pvar? V1800) (do (shen.bindv V1800 : V2198) (let Result (let V1803 (shen.lazyderef (tl V1799) V2198) (if (cons? V1803) (let A (hd V1803) (let V1804 (shen.lazyderef (tl V1803) V2198) (if (= () V1804) (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (if (shen.pvar? V1804) (do (shen.bindv V1804 () V2198) (let Result (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (do (shen.unbindv V1804 V2198) Result))) false)))) (if (shen.pvar? V1803) (let A (shen.newpv V2198) (do (shen.bindv V1803 (cons A ()) V2198) (let Result (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (do (shen.unbindv V1803 V2198) Result)))) false))) (do (shen.unbindv V1800 V2198) Result))) false))) (if (shen.pvar? V1799) (let A (shen.newpv V2198) (do (shen.bindv V1799 (cons : (cons A ())) V2198) (let Result (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (do (shen.unbindv V1799 V2198) Result)))) false)))) (if (shen.pvar? V1798) (let V (shen.newpv V2198) (let A (shen.newpv V2198) (do (shen.bindv V1798 (cons V (cons : (cons A ()))) V2198) (let Result (let NewHyp (tl V1797) (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199))))) (do (shen.unbindv V1798 V2198) Result))))) false))) (if (shen.pvar? V1797) (let V (shen.newpv V2198) (let A (shen.newpv V2198) (let NewHyp (shen.newpv V2198) (do (shen.bindv V1797 (cons (cons V (cons : (cons A ()))) NewHyp) V2198) (let Result (do (shen.incinfs) (unify! V V1791 V2198 (freeze (shen.newhyps Vs V2196 NewHyp V2198 V2199)))) (do (shen.unbindv V1797 V2198) Result)))))) false))))) false)) Case)))

(defun shen.patthyps (V2202 V2203 V2204) (cond ((= () V2202) V2204) ((and (cons? V2202) (and (cons? V2203) (and (cons? (tl V2203)) (and (= --> (hd (tl V2203))) (and (cons? (tl (tl V2203))) (= () (tl (tl (tl V2203))))))))) (adjoin (cons (hd V2202) (cons : (cons (hd V2203) ()))) (shen.patthyps (tl V2202) (hd (tl (tl V2203))) V2204))) (true (shen.f_error shen.patthyps))))

(defun shen.result-type (V2209 V2210) (cond ((= () V2209) V2210) ((and (cons? V2209) (and (cons? V2210) (and (cons? (tl V2210)) (and (= --> (hd (tl V2210))) (and (cons? (tl (tl V2210))) (= () (tl (tl (tl V2210))))))))) (shen.result-type (tl V2209) (hd (tl (tl V2210))))) (true (shen.f_error shen.result-type))))

(defun shen.t*-patterns (V2211 V2212 V2213 V2214 V2215) (let Case (let V1783 (shen.lazyderef V2211 V2214) (if (= () V1783) (do (shen.incinfs) (thaw V2215)) false)) (if (= Case false) (let V1784 (shen.lazyderef V2211 V2214) (if (cons? V1784) (let Pattern (hd V1784) (let Patterns (tl V1784) (let V1785 (shen.lazyderef V2212 V2214) (if (cons? V1785) (let A (hd V1785) (let V1786 (shen.lazyderef (tl V1785) V2214) (if (cons? V1786) (let V1787 (shen.lazyderef (hd V1786) V2214) (if (= --> V1787) (let V1788 (shen.lazyderef (tl V1786) V2214) (if (cons? V1788) (let B (hd V1788) (let V1789 (shen.lazyderef (tl V1788) V2214) (if (= () V1789) (do (shen.incinfs) (shen.t* (cons Pattern (cons : (cons A ()))) V2213 V2214 (freeze (shen.t*-patterns Patterns B V2213 V2214 V2215)))) false))) false)) false)) false))) false)))) false)) Case)))

(defun shen.t*-action (V2216 V2217 V2218 V2219 V2220) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V1760 (shen.lazyderef V2216 V2219) (if (cons? V1760) (let V1761 (shen.lazyderef (hd V1760) V2219) (if (= where V1761) (let V1762 (shen.lazyderef (tl V1760) V2219) (if (cons? V1762) (let P (hd V1762) (let V1763 (shen.lazyderef (tl V1762) V2219) (if (cons? V1763) (let Action (hd V1763) (let V1764 (shen.lazyderef (tl V1763) V2219) (if (= () V1764) (do (shen.incinfs) (cut Throwcontrol V2219 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2218 V2219 (freeze (cut Throwcontrol V2219 (freeze (shen.t*-action Action V2217 (cons (cons P (cons : (cons verified ()))) V2218) V2219 V2220)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V1765 (shen.lazyderef V2216 V2219) (if (cons? V1765) (let V1766 (shen.lazyderef (hd V1765) V2219) (if (= shen.choicepoint! V1766) (let V1767 (shen.lazyderef (tl V1765) V2219) (if (cons? V1767) (let V1768 (shen.lazyderef (hd V1767) V2219) (if (cons? V1768) (let V1769 (shen.lazyderef (hd V1768) V2219) (if (cons? V1769) (let V1770 (shen.lazyderef (hd V1769) V2219) (if (= fail-if V1770) (let V1771 (shen.lazyderef (tl V1769) V2219) (if (cons? V1771) (let F (hd V1771) (let V1772 (shen.lazyderef (tl V1771) V2219) (if (= () V1772) (let V1773 (shen.lazyderef (tl V1768) V2219) (if (cons? V1773) (let Action (hd V1773) (let V1774 (shen.lazyderef (tl V1773) V2219) (if (= () V1774) (let V1775 (shen.lazyderef (tl V1767) V2219) (if (= () V1775) (do (shen.incinfs) (cut Throwcontrol V2219 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2217 V2218 V2219 V2220)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V1776 (shen.lazyderef V2216 V2219) (if (cons? V1776) (let V1777 (shen.lazyderef (hd V1776) V2219) (if (= shen.choicepoint! V1777) (let V1778 (shen.lazyderef (tl V1776) V2219) (if (cons? V1778) (let Action (hd V1778) (let V1779 (shen.lazyderef (tl V1778) V2219) (if (= () V1779) (do (shen.incinfs) (cut Throwcontrol V2219 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2217 V2218 V2219 V2220)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2216 (cons : (cons V2217 ()))) V2218 V2219 V2220)) Case)) Case)) Case)))))

(defun findall (V2221 V2222 V2223 V2224 V2225) (let B (shen.newpv V2224) (let A (shen.newpv V2224) (do (shen.incinfs) (bind A (gensym shen.a) V2224 (freeze (bind B (set (shen.lazyderef A V2224) ()) V2224 (freeze (shen.findallhelp V2221 V2222 V2223 A V2224 V2225)))))))))

(defun shen.findallhelp (V2226 V2227 V2228 V2229 V2230 V2231) (let Case (do (shen.incinfs) (call V2227 V2230 (freeze (shen.remember V2229 V2226 V2230 (freeze (fwhen false V2230 V2231)))))) (if (= Case false) (do (shen.incinfs) (bind V2228 (value (shen.lazyderef V2229 V2230)) V2230 V2231)) Case)))

(defun shen.remember (V2232 V2233 V2234 V2235) (let B (shen.newpv V2234) (do (shen.incinfs) (bind B (set (shen.deref V2232 V2234) (cons (shen.deref V2233 V2234) (value (shen.deref V2232 V2234)))) V2234 V2235))))



