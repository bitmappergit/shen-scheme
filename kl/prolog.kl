"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V16383) (let Parse_shen.<predicate*> (shen.<predicate*> V16383) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V16392 V16393) (cond ((and (cons? V16393) (and (cons? (tl V16393)) (= () (tl (tl V16393))))) (simple-error (cn "prolog syntax error in " (shen.app V16392 (cn " here:

 " (shen.app (shen.next-50 50 (hd V16393)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V16392 "
" shen.a))))))

(defun shen.next-50 (V16400 V16401) (cond ((= () V16401) "") ((= 0 V16400) "") ((cons? V16401) (cn (shen.decons-string (hd V16401)) (shen.next-50 (- V16400 1) (tl V16401)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V16403) (cond ((and (cons? V16403) (and (= cons (hd V16403)) (and (cons? (tl V16403)) (and (cons? (tl (tl V16403))) (= () (tl (tl (tl V16403)))))))) (shen.app (shen.eval-cons V16403) " " shen.s)) (true (shen.app V16403 " " shen.r))))

(defun shen.insert-predicate (V16406 V16407) (cond ((and (cons? V16407) (and (cons? (tl V16407)) (= () (tl (tl V16407))))) (cons (cons V16406 (hd V16407)) (cons :- (tl V16407)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V16409) (if (cons? (hd V16409)) (let Parse_X (hd (hd V16409)) (shen.pair (hd (shen.pair (tl (hd V16409)) (shen.hdtl V16409))) Parse_X)) (fail)))

(defun shen.<clauses*> (V16411) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V16411) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V16411) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V16413) (let Parse_shen.<head*> (shen.<head*> V16413) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V16415) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V16415) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V16415) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V16417) (if (cons? (hd V16417)) (let Parse_X (hd (hd V16417)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V16417)) (shen.hdtl V16417))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V16423) (cond ((and (cons? V16423) (and (= cons (hd V16423)) (and (cons? (tl V16423)) (and (cons? (tl (tl V16423))) (= () (tl (tl (tl V16423)))))))) (and (shen.legitimate-term? (hd (tl V16423))) (shen.legitimate-term? (hd (tl (tl V16423)))))) ((and (cons? V16423) (and (= mode (hd V16423)) (and (cons? (tl V16423)) (and (cons? (tl (tl V16423))) (and (= + (hd (tl (tl V16423)))) (= () (tl (tl (tl V16423))))))))) (shen.legitimate-term? (hd (tl V16423)))) ((and (cons? V16423) (and (= mode (hd V16423)) (and (cons? (tl V16423)) (and (cons? (tl (tl V16423))) (and (= - (hd (tl (tl V16423)))) (= () (tl (tl (tl V16423))))))))) (shen.legitimate-term? (hd (tl V16423)))) ((cons? V16423) false) (true true)))

(defun shen.eval-cons (V16425) (cond ((and (cons? V16425) (and (= cons (hd V16425)) (and (cons? (tl V16425)) (and (cons? (tl (tl V16425))) (= () (tl (tl (tl V16425)))))))) (cons (shen.eval-cons (hd (tl V16425))) (shen.eval-cons (hd (tl (tl V16425)))))) ((and (cons? V16425) (and (= mode (hd V16425)) (and (cons? (tl V16425)) (and (cons? (tl (tl V16425))) (= () (tl (tl (tl V16425)))))))) (cons mode (cons (shen.eval-cons (hd (tl V16425))) (tl (tl V16425))))) (true V16425)))

(defun shen.<body*> (V16427) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V16427) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V16427) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V16429) (let YaccParse (if (and (cons? (hd V16429)) (= ! (hd (hd V16429)))) (shen.pair (hd (shen.pair (tl (hd V16429)) (shen.hdtl V16429))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V16429)) (let Parse_X (hd (hd V16429)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V16429)) (shen.hdtl V16429))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V16431) (if (cons? (hd V16431)) (let Parse_X (hd (hd V16431)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V16431)) (shen.hdtl V16431))) Parse_X) (fail))) (fail)))

(defun cut (V16435 V16436 V16437) (let Result (thaw V16437) (if (= Result false) V16435 Result)))

(defun shen.insert_modes (V16439) (cond ((and (cons? V16439) (and (= mode (hd V16439)) (and (cons? (tl V16439)) (and (cons? (tl (tl V16439))) (= () (tl (tl (tl V16439)))))))) V16439) ((= () V16439) ()) ((cons? V16439) (cons (cons mode (cons (hd V16439) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V16439)) (cons - ()))))) (true V16439)))

(defun shen.s-prolog (V16441) (map (lambda X (eval X)) (shen.prolog->shen V16441)))

(defun shen.prolog->shen (V16443) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V16443)))))

(defun shen.s-prolog_clause (V16445) (cond ((and (cons? V16445) (and (cons? (tl V16445)) (and (= :- (hd (tl V16445))) (and (cons? (tl (tl V16445))) (= () (tl (tl (tl V16445)))))))) (cons (hd V16445) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V16445)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V16447) (cond ((and (cons? V16447) (and (cons? (tl V16447)) (and (= :- (hd (tl V16447))) (and (cons? (tl (tl V16447))) (and (= () (tl (tl (tl V16447)))) (< (shen.complexity_head (hd V16447)) (value shen.*maxcomplexity*))))))) (cons V16447 ())) ((and (cons? V16447) (and (cons? (hd V16447)) (and (cons? (tl V16447)) (and (= :- (hd (tl V16447))) (and (cons? (tl (tl V16447))) (= () (tl (tl (tl V16447))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V16447))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V16447)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V16447)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V16447)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V16453) (cond ((cons? V16453) (shen.product (map (lambda X (shen.complexity X)) (tl V16453)))) (true (shen.f_error shen.complexity_head))))

(defun shen.complexity (V16462) (cond ((and (cons? V16462) (and (= mode (hd V16462)) (and (cons? (tl V16462)) (and (cons? (hd (tl V16462))) (and (= mode (hd (hd (tl V16462)))) (and (cons? (tl (hd (tl V16462)))) (and (cons? (tl (tl (hd (tl V16462))))) (and (= () (tl (tl (tl (hd (tl V16462)))))) (and (cons? (tl (tl V16462))) (= () (tl (tl (tl V16462))))))))))))) (shen.complexity (hd (tl V16462)))) ((and (cons? V16462) (and (= mode (hd V16462)) (and (cons? (tl V16462)) (and (cons? (hd (tl V16462))) (and (cons? (tl (tl V16462))) (and (= + (hd (tl (tl V16462)))) (= () (tl (tl (tl V16462)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V16462))) (tl (tl V16462))))) (shen.complexity (cons mode (cons (tl (hd (tl V16462))) (tl (tl V16462)))))))) ((and (cons? V16462) (and (= mode (hd V16462)) (and (cons? (tl V16462)) (and (cons? (hd (tl V16462))) (and (cons? (tl (tl V16462))) (and (= - (hd (tl (tl V16462)))) (= () (tl (tl (tl V16462)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V16462))) (tl (tl V16462))))) (shen.complexity (cons mode (cons (tl (hd (tl V16462))) (tl (tl V16462))))))) ((and (cons? V16462) (and (= mode (hd V16462)) (and (cons? (tl V16462)) (and (cons? (tl (tl V16462))) (and (= () (tl (tl (tl V16462)))) (variable? (hd (tl V16462)))))))) 1) ((and (cons? V16462) (and (= mode (hd V16462)) (and (cons? (tl V16462)) (and (cons? (tl (tl V16462))) (and (= + (hd (tl (tl V16462)))) (= () (tl (tl (tl V16462))))))))) 2) ((and (cons? V16462) (and (= mode (hd V16462)) (and (cons? (tl V16462)) (and (cons? (tl (tl V16462))) (and (= - (hd (tl (tl V16462)))) (= () (tl (tl (tl V16462))))))))) 1) (true (shen.complexity (cons mode (cons V16462 (cons + ())))))))

(defun shen.product (V16464) (cond ((= () V16464) 1) ((cons? V16464) (* (hd V16464) (shen.product (tl V16464)))) (true (shen.f_error shen.product))))

(defun shen.s-prolog_literal (V16466) (cond ((and (cons? V16466) (and (= is (hd V16466)) (and (cons? (tl V16466)) (and (cons? (tl (tl V16466))) (= () (tl (tl (tl V16466)))))))) (cons bind (cons (hd (tl V16466)) (cons (shen.insert_deref (hd (tl (tl V16466)))) ())))) ((and (cons? V16466) (and (= when (hd V16466)) (and (cons? (tl V16466)) (= () (tl (tl V16466)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V16466))) ()))) ((and (cons? V16466) (and (= bind (hd V16466)) (and (cons? (tl V16466)) (and (cons? (tl (tl V16466))) (= () (tl (tl (tl V16466)))))))) (cons bind (cons (hd (tl V16466)) (cons (shen.insert_lazyderef (hd (tl (tl V16466)))) ())))) ((and (cons? V16466) (and (= fwhen (hd V16466)) (and (cons? (tl V16466)) (= () (tl (tl V16466)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V16466))) ()))) ((cons? V16466) V16466) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V16468) (cond ((variable? V16468) (cons shen.deref (cons V16468 (cons ProcessN ())))) ((cons? V16468) (cons (shen.insert_deref (hd V16468)) (shen.insert_deref (tl V16468)))) (true V16468)))

(defun shen.insert_lazyderef (V16470) (cond ((variable? V16470) (cons shen.lazyderef (cons V16470 (cons ProcessN ())))) ((cons? V16470) (cons (shen.insert_lazyderef (hd V16470)) (shen.insert_lazyderef (tl V16470)))) (true V16470)))

(defun shen.group_clauses (V16472) (cond ((= () V16472) ()) ((cons? V16472) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V16472) X)) V16472) (let Rest (difference V16472 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V16477 V16478) (cond ((= () V16478) ()) ((cons? V16478) (if (V16477 (hd V16478)) (cons (hd V16478) (shen.collect V16477 (tl V16478))) (shen.collect V16477 (tl V16478)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V16497 V16498) (cond ((and (cons? V16497) (and (cons? (hd V16497)) (and (cons? V16498) (cons? (hd V16498))))) (= (hd (hd V16497)) (hd (hd V16498)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V16500) (let F (shen.procedure_name V16500) (let Shen (shen.clauses-to-shen F V16500) Shen)))

(defun shen.procedure_name (V16514) (cond ((and (cons? V16514) (and (cons? (hd V16514)) (cons? (hd (hd V16514))))) (hd (hd (hd V16514)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V16517 V16518) (let Linear (map (lambda X (shen.linearise-clause X)) V16518) (let Arity (shen.prolog-aritycheck V16517 (map (lambda X (head X)) V16518)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V16517 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V16520) (cond ((not (shen.occurs? cut V16520)) V16520) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V16520 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V16528 V16529) (cond ((= V16529 V16528) false) (true V16529)))

(defun shen.nest-disjunct (V16531) (cond ((and (cons? V16531) (= () (tl V16531))) (hd V16531)) ((cons? V16531) (shen.lisp-or (hd V16531) (shen.nest-disjunct (tl V16531)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V16534 V16535) (cons let (cons Case (cons V16534 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V16535 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V16540 V16541) (cond ((and (cons? V16541) (= () (tl V16541))) (- (length (hd V16541)) 1)) ((and (cons? V16541) (cons? (tl V16541))) (if (= (length (hd V16541)) (length (hd (tl V16541)))) (shen.prolog-aritycheck V16540 (tl V16541)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V16540 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V16543) (cond ((and (cons? V16543) (and (cons? (tl V16543)) (and (= :- (hd (tl V16543))) (and (cons? (tl (tl V16543))) (= () (tl (tl (tl V16543)))))))) (let Linear (shen.linearise (cons (hd V16543) (tl (tl V16543)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V16545) (cond ((and (cons? V16545) (and (cons? (tl V16545)) (= () (tl (tl V16545))))) (cons (shen.explicit_modes (hd V16545)) (cons :- (cons (shen.cf_help (hd (tl V16545))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V16547) (cond ((cons? V16547) (cons (hd V16547) (map (lambda X (shen.em_help X)) (tl V16547)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V16549) (cond ((and (cons? V16549) (and (= mode (hd V16549)) (and (cons? (tl V16549)) (and (cons? (tl (tl V16549))) (= () (tl (tl (tl V16549)))))))) V16549) (true (cons mode (cons V16549 (cons + ()))))))

(defun shen.cf_help (V16551) (cond ((and (cons? V16551) (and (= where (hd V16551)) (and (cons? (tl V16551)) (and (cons? (hd (tl V16551))) (and (= = (hd (hd (tl V16551)))) (and (cons? (tl (hd (tl V16551)))) (and (cons? (tl (tl (hd (tl V16551))))) (and (= () (tl (tl (tl (hd (tl V16551)))))) (and (cons? (tl (tl V16551))) (= () (tl (tl (tl V16551))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V16551)))) (shen.cf_help (hd (tl (tl V16551)))))) (true V16551)))

(defun occurs-check (V16557) (cond ((= + V16557) (set shen.*occurs* true)) ((= - V16557) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V16560 V16561) (cond ((and (cons? V16560) (and (cons? (hd V16560)) (and (cons? (tl V16560)) (and (= :- (hd (tl V16560))) (and (cons? (tl (tl V16560))) (= () (tl (tl (tl V16560))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V16560)) (cons (shen.continuation_call (tl (hd V16560)) (hd (tl (tl V16560)))) ()))) V16561) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V16564 V16565) (let VTerms (cons ProcessN (shen.extract_vars V16564)) (let VBody (shen.extract_vars V16565) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V16565)))))

(defun remove (V16568 V16569) (shen.remove-h V16568 V16569 ()))

(defun shen.remove-h (V16576 V16577 V16578) (cond ((= () V16577) (reverse V16578)) ((and (cons? V16577) (= (hd V16577) V16576)) (shen.remove-h (hd V16577) (tl V16577) V16578)) ((cons? V16577) (shen.remove-h V16576 (tl V16577) (cons (hd V16577) V16578))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V16581 V16582) (cond ((and (= () V16581) (= () V16582)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V16582) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V16581 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V16581) (cons call (cons shen.the (cons shen.continuation (cons V16582 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V16581 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V16582 ())))) ())))))))))))

(defun shen.make_mu_application (V16585 V16586) (cond ((and (cons? V16585) (and (= shen.mu (hd V16585)) (and (cons? (tl V16585)) (and (= () (hd (tl V16585))) (and (cons? (tl (tl V16585))) (and (= () (tl (tl (tl V16585)))) (= () V16586))))))) (hd (tl (tl V16585)))) ((and (cons? V16585) (and (= shen.mu (hd V16585)) (and (cons? (tl V16585)) (and (cons? (hd (tl V16585))) (and (cons? (tl (tl V16585))) (and (= () (tl (tl (tl V16585)))) (cons? V16586))))))) (cons (cons shen.mu (cons (hd (hd (tl V16585))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V16585))) (tl (tl V16585)))) (tl V16586)) ()))) (cons (hd V16586) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V16595 V16596) (cond ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (hd (tl (hd V16595)))) (and (= mode (hd (hd (tl (hd V16595))))) (and (cons? (tl (hd (tl (hd V16595))))) (and (cons? (tl (tl (hd (tl (hd V16595)))))) (and (= () (tl (tl (tl (hd (tl (hd V16595))))))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (= () (tl (tl V16595))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V16595))))) (tl (tl (hd V16595))))) (tl V16595)) (hd (tl (tl (hd (tl (hd V16595)))))))) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (= _ (hd (tl (hd V16595)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V16595)))) V16596)) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (shen.ephemeral_variable? (hd (tl (hd V16595))) (hd (tl V16595))))))))))) (subst (hd (tl V16595)) (hd (tl (hd V16595))) (shen.mu_reduction (hd (tl (tl (hd V16595)))) V16596))) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (variable? (hd (tl (hd V16595)))))))))))) (cons let (cons (hd (tl (hd V16595))) (cons shen.be (cons (hd (tl V16595)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V16595)))) V16596) ()))))))) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (and (= - V16596) (shen.prolog_constant? (hd (tl (hd V16595))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V16595))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V16595))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V16595)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (and (= + V16596) (shen.prolog_constant? (hd (tl (hd V16595))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V16595))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V16595))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V16595)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V16595))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V16595)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (hd (tl (hd V16595)))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (= - V16596)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V16595))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V16595)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V16595)))) (tl (tl (hd V16595))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V16595) (and (cons? (hd V16595)) (and (= shen.mu (hd (hd V16595))) (and (cons? (tl (hd V16595))) (and (cons? (hd (tl (hd V16595)))) (and (cons? (tl (tl (hd V16595)))) (and (= () (tl (tl (tl (hd V16595))))) (and (cons? (tl V16595)) (and (= () (tl (tl V16595))) (= + V16596)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V16595))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V16595)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V16595)))) (tl (tl (hd V16595))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V16595)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V16595))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V16595)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V16595)))

(defun shen.rcons_form (V16598) (cond ((cons? V16598) (cons cons (cons (shen.rcons_form (hd V16598)) (cons (shen.rcons_form (tl V16598)) ())))) (true V16598)))

(defun shen.remove_modes (V16600) (cond ((and (cons? V16600) (and (= mode (hd V16600)) (and (cons? (tl V16600)) (and (cons? (tl (tl V16600))) (and (= + (hd (tl (tl V16600)))) (= () (tl (tl (tl V16600))))))))) (shen.remove_modes (hd (tl V16600)))) ((and (cons? V16600) (and (= mode (hd V16600)) (and (cons? (tl V16600)) (and (cons? (tl (tl V16600))) (and (= - (hd (tl (tl V16600)))) (= () (tl (tl (tl V16600))))))))) (shen.remove_modes (hd (tl V16600)))) ((cons? V16600) (cons (shen.remove_modes (hd V16600)) (shen.remove_modes (tl V16600)))) (true V16600)))

(defun shen.ephemeral_variable? (V16603 V16604) (and (variable? V16603) (variable? V16604)))

(defun shen.prolog_constant? (V16614) (cond ((cons? V16614) false) (true true)))

(defun shen.aum_to_shen (V16616) (cond ((and (cons? V16616) (and (= let (hd V16616)) (and (cons? (tl V16616)) (and (cons? (tl (tl V16616))) (and (= shen.be (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (cons? (tl (tl (tl (tl V16616))))) (and (= in (hd (tl (tl (tl (tl V16616)))))) (and (cons? (tl (tl (tl (tl (tl V16616)))))) (= () (tl (tl (tl (tl (tl (tl V16616)))))))))))))))) (cons let (cons (hd (tl V16616)) (cons (shen.aum_to_shen (hd (tl (tl (tl V16616))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V16616))))))) ()))))) ((and (cons? V16616) (and (= shen.the (hd V16616)) (and (cons? (tl V16616)) (and (= shen.result (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.of (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (= shen.dereferencing (hd (tl (tl (tl V16616))))) (and (cons? (tl (tl (tl (tl V16616))))) (= () (tl (tl (tl (tl (tl V16616))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V16616)))))) (cons ProcessN ())))) ((and (cons? V16616) (and (= if (hd V16616)) (and (cons? (tl V16616)) (and (cons? (tl (tl V16616))) (and (= shen.then (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (cons? (tl (tl (tl (tl V16616))))) (and (= shen.else (hd (tl (tl (tl (tl V16616)))))) (and (cons? (tl (tl (tl (tl (tl V16616)))))) (= () (tl (tl (tl (tl (tl (tl V16616)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V16616))) (cons (shen.aum_to_shen (hd (tl (tl (tl V16616))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V16616))))))) ()))))) ((and (cons? V16616) (and (cons? (tl V16616)) (and (= is (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.a (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (= shen.variable (hd (tl (tl (tl V16616))))) (= () (tl (tl (tl (tl V16616)))))))))))) (cons shen.pvar? (cons (hd V16616) ()))) ((and (cons? V16616) (and (cons? (tl V16616)) (and (= is (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.a (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (= shen.non-empty (hd (tl (tl (tl V16616))))) (and (cons? (tl (tl (tl (tl V16616))))) (and (= list (hd (tl (tl (tl (tl V16616)))))) (= () (tl (tl (tl (tl (tl V16616))))))))))))))) (cons cons? (cons (hd V16616) ()))) ((and (cons? V16616) (and (= shen.rename (hd V16616)) (and (cons? (tl V16616)) (and (= shen.the (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.variables (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (= in (hd (tl (tl (tl V16616))))) (and (cons? (tl (tl (tl (tl V16616))))) (and (= () (hd (tl (tl (tl (tl V16616)))))) (and (cons? (tl (tl (tl (tl (tl V16616)))))) (and (= and (hd (tl (tl (tl (tl (tl V16616))))))) (and (cons? (tl (tl (tl (tl (tl (tl V16616))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V16616)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V16616)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V16616)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V16616)))))))))) ((and (cons? V16616) (and (= shen.rename (hd V16616)) (and (cons? (tl V16616)) (and (= shen.the (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.variables (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (= in (hd (tl (tl (tl V16616))))) (and (cons? (tl (tl (tl (tl V16616))))) (and (cons? (hd (tl (tl (tl (tl V16616)))))) (and (cons? (tl (tl (tl (tl (tl V16616)))))) (and (= and (hd (tl (tl (tl (tl (tl V16616))))))) (and (cons? (tl (tl (tl (tl (tl (tl V16616))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V16616)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V16616)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V16616)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V16616)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V16616)))))) (tl (tl (tl (tl (tl V16616))))))))))) ()))))) ((and (cons? V16616) (and (= bind (hd V16616)) (and (cons? (tl V16616)) (and (cons? (tl (tl V16616))) (and (= shen.to (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (cons? (tl (tl (tl (tl V16616))))) (and (= in (hd (tl (tl (tl (tl V16616)))))) (and (cons? (tl (tl (tl (tl (tl V16616)))))) (= () (tl (tl (tl (tl (tl (tl V16616)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V16616)) (cons (shen.chwild (hd (tl (tl (tl V16616))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V16616))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V16616)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V16616) (and (cons? (tl V16616)) (and (= is (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= identical (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (and (= shen.to (hd (tl (tl (tl V16616))))) (and (cons? (tl (tl (tl (tl V16616))))) (= () (tl (tl (tl (tl (tl V16616)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V16616))))) (cons (hd V16616) ())))) ((= shen.failed! V16616) false) ((and (cons? V16616) (and (= shen.the (hd V16616)) (and (cons? (tl V16616)) (and (= head (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.of (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (= () (tl (tl (tl (tl V16616)))))))))))) (cons hd (tl (tl (tl V16616))))) ((and (cons? V16616) (and (= shen.the (hd V16616)) (and (cons? (tl V16616)) (and (= tail (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.of (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (= () (tl (tl (tl (tl V16616)))))))))))) (cons tl (tl (tl (tl V16616))))) ((and (cons? V16616) (and (= shen.pop (hd V16616)) (and (cons? (tl V16616)) (and (= shen.the (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.stack (hd (tl (tl V16616)))) (= () (tl (tl (tl V16616)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V16616) (and (= call (hd V16616)) (and (cons? (tl V16616)) (and (= shen.the (hd (tl V16616))) (and (cons? (tl (tl V16616))) (and (= shen.continuation (hd (tl (tl V16616)))) (and (cons? (tl (tl (tl V16616)))) (= () (tl (tl (tl (tl V16616)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V16616))))) ProcessN Continuation) ())))) (true V16616)))

(defun shen.chwild (V16618) (cond ((= V16618 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V16618) (map (lambda Z (shen.chwild Z)) V16618)) (true V16618)))

(defun shen.newpv (V16620) (let Count+1 (+ (<-address (value shen.*varcounter*) V16620) 1) (let IncVar (address-> (value shen.*varcounter*) V16620 Count+1) (let Vector (<-address (value shen.*prologvectors*) V16620) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V16620 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V16623 V16624) (let Vector (<-address (value shen.*prologvectors*) V16623) (let BigVector (shen.resize-vector Vector (+ V16624 V16624) shen.-null-) (address-> (value shen.*prologvectors*) V16623 BigVector))))

(defun shen.resize-vector (V16628 V16629 V16630) (let BigVector (address-> (absvector (+ 1 V16629)) 0 V16629) (shen.copy-vector V16628 BigVector (limit V16628) V16629 V16630)))

(defun shen.copy-vector (V16636 V16637 V16638 V16639 V16640) (shen.copy-vector-stage-2 (+ 1 V16638) (+ V16639 1) V16640 (shen.copy-vector-stage-1 1 V16636 V16637 (+ 1 V16638))))

(defun shen.copy-vector-stage-1 (V16648 V16649 V16650 V16651) (cond ((= V16651 V16648) V16650) (true (shen.copy-vector-stage-1 (+ 1 V16648) V16649 (address-> V16650 V16648 (<-address V16649 V16648)) V16651))))

(defun shen.copy-vector-stage-2 (V16659 V16660 V16661 V16662) (cond ((= V16660 V16659) V16662) (true (shen.copy-vector-stage-2 (+ V16659 1) V16660 V16661 (address-> V16662 V16659 V16661)))))

(defun shen.mk-pvar (V16664) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V16664))

(defun shen.pvar? (V16666) (trap-error (and (absvector? V16666) (= (<-address V16666 0) shen.pvar)) (lambda E false)))

(defun shen.bindv (V16670 V16671 V16672) (let Vector (<-address (value shen.*prologvectors*) V16672) (address-> Vector (<-address V16670 1) V16671)))

(defun shen.unbindv (V16675 V16676) (let Vector (<-address (value shen.*prologvectors*) V16676) (address-> Vector (<-address V16675 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V16680 V16681 V16682) (cond ((and (cons? V16680) (and (cons? (hd V16680)) (= () (tl V16680)))) (cons (hd (hd V16680)) (append (tl (hd V16680)) (cons V16681 (cons V16682 ()))))) ((and (cons? V16680) (cons? (hd V16680))) (let NewContinuation (shen.newcontinuation (tl V16680) V16681 V16682) (cons (hd (hd V16680)) (append (tl (hd V16680)) (cons V16681 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V16686 V16687 V16688) (cond ((= () V16686) V16688) ((and (cons? V16686) (cons? (hd V16686))) (cons freeze (cons (cons (hd (hd V16686)) (append (tl (hd V16686)) (cons V16687 (cons (shen.newcontinuation (tl V16686) V16687 V16688) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V16696 V16697 V16698) (shen.deref V16696 V16697))

(defun shen.measure&return (V16706 V16707 V16708) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V16706 V16707)))

(defun unify (V16713 V16714 V16715 V16716) (shen.lzy= (shen.lazyderef V16713 V16715) (shen.lazyderef V16714 V16715) V16715 V16716))

(defun shen.lzy= (V16738 V16739 V16740 V16741) (cond ((= V16739 V16738) (thaw V16741)) ((shen.pvar? V16738) (bind V16738 V16739 V16740 V16741)) ((shen.pvar? V16739) (bind V16739 V16738 V16740 V16741)) ((and (cons? V16738) (cons? V16739)) (shen.lzy= (shen.lazyderef (hd V16738) V16740) (shen.lazyderef (hd V16739) V16740) V16740 (freeze (shen.lzy= (shen.lazyderef (tl V16738) V16740) (shen.lazyderef (tl V16739) V16740) V16740 V16741)))) (true false)))

(defun shen.deref (V16744 V16745) (cond ((cons? V16744) (cons (shen.deref (hd V16744) V16745) (shen.deref (tl V16744) V16745))) (true (if (shen.pvar? V16744) (let Value (shen.valvector V16744 V16745) (if (= Value shen.-null-) V16744 (shen.deref Value V16745))) V16744))))

(defun shen.lazyderef (V16748 V16749) (if (shen.pvar? V16748) (let Value (shen.valvector V16748 V16749) (if (= Value shen.-null-) V16748 (shen.lazyderef Value V16749))) V16748))

(defun shen.valvector (V16752 V16753) (<-address (<-address (value shen.*prologvectors*) V16753) (<-address V16752 1)))

(defun unify! (V16758 V16759 V16760 V16761) (shen.lzy=! (shen.lazyderef V16758 V16760) (shen.lazyderef V16759 V16760) V16760 V16761))

(defun shen.lzy=! (V16783 V16784 V16785 V16786) (cond ((= V16784 V16783) (thaw V16786)) ((and (shen.pvar? V16783) (not (shen.occurs? V16783 (shen.deref V16784 V16785)))) (bind V16783 V16784 V16785 V16786)) ((and (shen.pvar? V16784) (not (shen.occurs? V16784 (shen.deref V16783 V16785)))) (bind V16784 V16783 V16785 V16786)) ((and (cons? V16783) (cons? V16784)) (shen.lzy=! (shen.lazyderef (hd V16783) V16785) (shen.lazyderef (hd V16784) V16785) V16785 (freeze (shen.lzy=! (shen.lazyderef (tl V16783) V16785) (shen.lazyderef (tl V16784) V16785) V16785 V16786)))) (true false)))

(defun shen.occurs? (V16798 V16799) (cond ((= V16799 V16798) true) ((cons? V16799) (or (shen.occurs? V16798 (hd V16799)) (shen.occurs? V16798 (tl V16799)))) (true false)))

(defun identical (V16804 V16805 V16806 V16807) (shen.lzy== (shen.lazyderef V16804 V16806) (shen.lazyderef V16805 V16806) V16806 V16807))

(defun shen.lzy== (V16829 V16830 V16831 V16832) (cond ((= V16830 V16829) (thaw V16832)) ((and (cons? V16829) (cons? V16830)) (shen.lzy== (shen.lazyderef (hd V16829) V16831) (shen.lazyderef (hd V16830) V16831) V16831 (freeze (shen.lzy== (tl V16829) (tl V16830) V16831 V16832)))) (true false)))

(defun shen.pvar (V16834) (cn "Var" (shen.app (<-address V16834 1) "" shen.a)))

(defun bind (V16839 V16840 V16841 V16842) (do (shen.bindv V16839 V16840 V16841) (let Result (thaw V16842) (do (shen.unbindv V16839 V16841) Result))))

(defun fwhen (V16860 V16861 V16862) (cond ((= true V16860) (thaw V16862)) ((= false V16860) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V16860 "%" shen.s))))))

(defun call (V16878 V16879 V16880) (cond ((cons? V16878) (shen.call-help (function (shen.lazyderef (hd V16878) V16879)) (tl V16878) V16879 V16880)) (true false)))

(defun shen.call-help (V16885 V16886 V16887 V16888) (cond ((= () V16886) (V16885 V16887 V16888)) ((cons? V16886) (shen.call-help (V16885 (hd V16886)) (tl V16886) V16887 V16888)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V16890) (cond ((and (cons? V16890) (cons? (hd V16890))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V16890)) (shen.insert-prolog-variables (cons (tl (hd V16890)) (cons (tl V16890) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V16894 V16895 V16896) (cond ((and (cons? V16895) (and (cons? (tl V16895)) (= () (tl (tl V16895))))) (shen.intprolog-help-help V16894 (hd V16895) (hd (tl V16895)) V16896)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V16901 V16902 V16903 V16904) (cond ((= () V16902) (V16901 V16904 (freeze (shen.call-rest V16903 V16904)))) ((cons? V16902) (shen.intprolog-help-help (V16901 (hd V16902)) (tl V16902) V16903 V16904)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V16909 V16910) (cond ((= () V16909) true) ((and (cons? V16909) (and (cons? (hd V16909)) (cons? (tl (hd V16909))))) (shen.call-rest (cons (cons ((hd (hd V16909)) (hd (tl (hd V16909)))) (tl (tl (hd V16909)))) (tl V16909)) V16910)) ((and (cons? V16909) (and (cons? (hd V16909)) (= () (tl (hd V16909))))) ((hd (hd V16909)) V16910 (freeze (shen.call-rest (tl V16909) V16910)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V16913 V16914) (shen.insert-prolog-variables-help V16913 (shen.flatten V16913) V16914))

(defun shen.insert-prolog-variables-help (V16922 V16923 V16924) (cond ((= () V16923) V16922) ((and (cons? V16923) (variable? (hd V16923))) (let V (shen.newpv V16924) (let XV/Y (subst V (hd V16923) V16922) (let Z-Y (remove (hd V16923) (tl V16923)) (shen.insert-prolog-variables-help XV/Y Z-Y V16924))))) ((cons? V16923) (shen.insert-prolog-variables-help V16922 (tl V16923) V16924)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V16926) (let Vector (address-> (value shen.*prologvectors*) V16926 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V16926 1) V16926)))



