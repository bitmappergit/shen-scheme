"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V826) (let Parse_shen.<predicate*> (shen.<predicate*> V826) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V833 V834) (cond ((and (cons? V834) (and (cons? (tl V834)) (= () (tl (tl V834))))) (simple-error (cn "prolog syntax error in " (shen.app V833 (cn " here:

 " (shen.app (shen.next-50 50 (hd V834)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V833 "
" shen.a))))))

(defun shen.next-50 (V839 V840) (cond ((= () V840) "") ((= 0 V839) "") ((cons? V840) (cn (shen.decons-string (hd V840)) (shen.next-50 (- V839 1) (tl V840)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V841) (cond ((and (cons? V841) (and (= cons (hd V841)) (and (cons? (tl V841)) (and (cons? (tl (tl V841))) (= () (tl (tl (tl V841)))))))) (shen.app (shen.eval-cons V841) " " shen.s)) (true (shen.app V841 " " shen.r))))

(defun shen.insert-predicate (V842 V843) (cond ((and (cons? V843) (and (cons? (tl V843)) (= () (tl (tl V843))))) (cons (cons V842 (hd V843)) (cons :- (tl V843)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V844) (if (cons? (hd V844)) (let Parse_X (hd (hd V844)) (shen.pair (hd (shen.pair (tl (hd V844)) (shen.hdtl V844))) Parse_X)) (fail)))

(defun shen.<clauses*> (V845) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V845) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V845) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (shen.hdtl Parse_<e>)) (fail))) YaccParse)))

(defun shen.<clause*> (V846) (let Parse_shen.<head*> (shen.<head*> V846) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V847) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V847) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V847) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V848) (if (cons? (hd V848)) (let Parse_X (hd (hd V848)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V848)) (shen.hdtl V848))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V853) (cond ((and (cons? V853) (and (= cons (hd V853)) (and (cons? (tl V853)) (and (cons? (tl (tl V853))) (= () (tl (tl (tl V853)))))))) (and (shen.legitimate-term? (hd (tl V853))) (shen.legitimate-term? (hd (tl (tl V853)))))) ((and (cons? V853) (and (= mode (hd V853)) (and (cons? (tl V853)) (and (cons? (tl (tl V853))) (and (= + (hd (tl (tl V853)))) (= () (tl (tl (tl V853))))))))) (shen.legitimate-term? (hd (tl V853)))) ((and (cons? V853) (and (= mode (hd V853)) (and (cons? (tl V853)) (and (cons? (tl (tl V853))) (and (= - (hd (tl (tl V853)))) (= () (tl (tl (tl V853))))))))) (shen.legitimate-term? (hd (tl V853)))) ((cons? V853) false) (true true)))

(defun shen.eval-cons (V854) (cond ((and (cons? V854) (and (= cons (hd V854)) (and (cons? (tl V854)) (and (cons? (tl (tl V854))) (= () (tl (tl (tl V854)))))))) (cons (shen.eval-cons (hd (tl V854))) (shen.eval-cons (hd (tl (tl V854)))))) ((and (cons? V854) (and (= mode (hd V854)) (and (cons? (tl V854)) (and (cons? (tl (tl V854))) (= () (tl (tl (tl V854)))))))) (cons mode (cons (shen.eval-cons (hd (tl V854))) (tl (tl V854))))) (true V854)))

(defun shen.<body*> (V855) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V855) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V855) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V856) (let YaccParse (if (and (cons? (hd V856)) (= ! (hd (hd V856)))) (shen.pair (hd (shen.pair (tl (hd V856)) (shen.hdtl V856))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V856)) (let Parse_X (hd (hd V856)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V856)) (shen.hdtl V856))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V857) (if (cons? (hd V857)) (let Parse_X (hd (hd V857)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V857)) (shen.hdtl V857))) Parse_X) (fail))) (fail)))

(defun cut (V858 V859 V860) (let Result (thaw V860) (if (= Result false) V858 Result)))

(defun shen.insert_modes (V861) (cond ((and (cons? V861) (and (= mode (hd V861)) (and (cons? (tl V861)) (and (cons? (tl (tl V861))) (= () (tl (tl (tl V861)))))))) V861) ((= () V861) ()) ((cons? V861) (cons (cons mode (cons (hd V861) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V861)) (cons - ()))))) (true V861)))

(defun shen.s-prolog (V862) (map (lambda V815 (eval V815)) (shen.prolog->shen V862)))

(defun shen.prolog->shen (V863) (map (lambda V818 (shen.compile_prolog_procedure V818)) (shen.group_clauses (map (lambda V817 (shen.s-prolog_clause V817)) (mapcan (lambda V816 (shen.head_abstraction V816)) V863)))))

(defun shen.s-prolog_clause (V864) (cond ((and (cons? V864) (and (cons? (tl V864)) (and (= :- (hd (tl V864))) (and (cons? (tl (tl V864))) (= () (tl (tl (tl V864)))))))) (cons (hd V864) (cons :- (cons (map (lambda V819 (shen.s-prolog_literal V819)) (hd (tl (tl V864)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V865) (cond ((and (cons? V865) (and (cons? (tl V865)) (and (= :- (hd (tl V865))) (and (cons? (tl (tl V865))) (and (= () (tl (tl (tl V865)))) (< (shen.complexity_head (hd V865)) (value shen.*maxcomplexity*))))))) (cons V865 ())) ((and (cons? V865) (and (cons? (hd V865)) (and (cons? (tl V865)) (and (= :- (hd (tl V865))) (and (cons? (tl (tl V865))) (= () (tl (tl (tl V865))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V865))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V865)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V865)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V865)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V870) (cond ((cons? V870) (shen.product (map (lambda V820 (shen.complexity V820)) (tl V870)))) (true (shen.f_error shen.complexity_head))))

(defun shen.complexity (V878) (cond ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (hd (tl V878))) (and (= mode (hd (hd (tl V878)))) (and (cons? (tl (hd (tl V878)))) (and (cons? (tl (tl (hd (tl V878))))) (and (= () (tl (tl (tl (hd (tl V878)))))) (and (cons? (tl (tl V878))) (= () (tl (tl (tl V878))))))))))))) (shen.complexity (hd (tl V878)))) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (hd (tl V878))) (and (cons? (tl (tl V878))) (and (= + (hd (tl (tl V878)))) (= () (tl (tl (tl V878)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V878))) (tl (tl V878))))) (shen.complexity (cons mode (cons (tl (hd (tl V878))) (tl (tl V878)))))))) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (hd (tl V878))) (and (cons? (tl (tl V878))) (and (= - (hd (tl (tl V878)))) (= () (tl (tl (tl V878)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V878))) (tl (tl V878))))) (shen.complexity (cons mode (cons (tl (hd (tl V878))) (tl (tl V878))))))) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (tl (tl V878))) (and (= () (tl (tl (tl V878)))) (variable? (hd (tl V878)))))))) 1) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (tl (tl V878))) (and (= + (hd (tl (tl V878)))) (= () (tl (tl (tl V878))))))))) 2) ((and (cons? V878) (and (= mode (hd V878)) (and (cons? (tl V878)) (and (cons? (tl (tl V878))) (and (= - (hd (tl (tl V878)))) (= () (tl (tl (tl V878))))))))) 1) (true (shen.complexity (cons mode (cons V878 (cons + ())))))))

(defun shen.product (V879) (cond ((= () V879) 1) ((cons? V879) (* (hd V879) (shen.product (tl V879)))) (true (shen.f_error shen.product))))

(defun shen.s-prolog_literal (V880) (cond ((and (cons? V880) (and (= is (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (= () (tl (tl (tl V880)))))))) (cons bind (cons (hd (tl V880)) (cons (shen.insert_deref (hd (tl (tl V880)))) ())))) ((and (cons? V880) (and (= when (hd V880)) (and (cons? (tl V880)) (= () (tl (tl V880)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V880))) ()))) ((and (cons? V880) (and (= bind (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (= () (tl (tl (tl V880)))))))) (cons bind (cons (hd (tl V880)) (cons (shen.insert_lazyderef (hd (tl (tl V880)))) ())))) ((and (cons? V880) (and (= fwhen (hd V880)) (and (cons? (tl V880)) (= () (tl (tl V880)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V880))) ()))) ((cons? V880) V880) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V881) (cond ((variable? V881) (cons shen.deref (cons V881 (cons ProcessN ())))) ((cons? V881) (cons (shen.insert_deref (hd V881)) (shen.insert_deref (tl V881)))) (true V881)))

(defun shen.insert_lazyderef (V882) (cond ((variable? V882) (cons shen.lazyderef (cons V882 (cons ProcessN ())))) ((cons? V882) (cons (shen.insert_lazyderef (hd V882)) (shen.insert_lazyderef (tl V882)))) (true V882)))

(defun shen.m_prolog_to_s-prolog_predicate (V883) (cond ((= = V883) unify) ((= =! V883) unify!) ((= == V883) identical) (true V883)))

(defun shen.group_clauses (V884) (cond ((= () V884) ()) ((cons? V884) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V884) X)) V884) (let Rest (difference V884 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V887 V888) (cond ((= () V888) ()) ((cons? V888) (if (V887 (hd V888)) (cons (hd V888) (shen.collect V887 (tl V888))) (shen.collect V887 (tl V888)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V905 V906) (cond ((and (cons? V905) (and (cons? (hd V905)) (and (cons? V906) (cons? (hd V906))))) (= (hd (hd V905)) (hd (hd V906)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V907) (let F (shen.procedure_name V907) (let Shen (shen.clauses-to-shen F V907) Shen)))

(defun shen.procedure_name (V920) (cond ((and (cons? V920) (and (cons? (hd V920)) (cons? (hd (hd V920))))) (hd (hd (hd V920)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V921 V922) (let Linear (map (lambda V821 (shen.linearise-clause V821)) V922) (let Arity (shen.prolog-aritycheck V921 (map (lambda V822 (head V822)) V922)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda V823 (shen.aum_to_shen V823)) AUM_instructions))) (let ShenDef (cons define (cons V921 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V923) (cond ((not (shen.occurs? cut V923)) V923) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V923 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V929 V930) (cond ((= V930 V929) false) (true V930)))

(defun shen.nest-disjunct (V931) (cond ((and (cons? V931) (= () (tl V931))) (hd V931)) ((cons? V931) (shen.lisp-or (hd V931) (shen.nest-disjunct (tl V931)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V932 V933) (cons let (cons Case (cons V932 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V933 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V936 V937) (cond ((and (cons? V937) (= () (tl V937))) (- (length (hd V937)) 1)) ((and (cons? V937) (cons? (tl V937))) (if (= (length (hd V937)) (length (hd (tl V937)))) (shen.prolog-aritycheck V936 (tl V937)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V936 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V938) (cond ((and (cons? V938) (and (cons? (tl V938)) (and (= :- (hd (tl V938))) (and (cons? (tl (tl V938))) (= () (tl (tl (tl V938)))))))) (let Linear (shen.linearise (cons (hd V938) (tl (tl V938)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V939) (cond ((and (cons? V939) (and (cons? (tl V939)) (= () (tl (tl V939))))) (cons (shen.explicit_modes (hd V939)) (cons :- (cons (shen.cf_help (hd (tl V939))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V940) (cond ((cons? V940) (cons (hd V940) (map (lambda V824 (shen.em_help V824)) (tl V940)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V941) (cond ((and (cons? V941) (and (= mode (hd V941)) (and (cons? (tl V941)) (and (cons? (tl (tl V941))) (= () (tl (tl (tl V941)))))))) V941) (true (cons mode (cons V941 (cons + ()))))))

(defun shen.cf_help (V942) (cond ((and (cons? V942) (and (= where (hd V942)) (and (cons? (tl V942)) (and (cons? (hd (tl V942))) (and (= = (hd (hd (tl V942)))) (and (cons? (tl (hd (tl V942)))) (and (cons? (tl (tl (hd (tl V942))))) (and (= () (tl (tl (tl (hd (tl V942)))))) (and (cons? (tl (tl V942))) (= () (tl (tl (tl V942))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V942)))) (shen.cf_help (hd (tl (tl V942)))))) (true V942)))

(defun occurs-check (V947) (cond ((= + V947) (set shen.*occurs* true)) ((= - V947) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V948 V949) (cond ((and (cons? V948) (and (cons? (hd V948)) (and (cons? (tl V948)) (and (= :- (hd (tl V948))) (and (cons? (tl (tl V948))) (= () (tl (tl (tl V948))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V948)) (cons (shen.continuation_call (tl (hd V948)) (hd (tl (tl V948)))) ()))) V949) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V950 V951) (let VTerms (cons ProcessN (shen.extract_vars V950)) (let VBody (shen.extract_vars V951) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V951)))))

(defun remove (V952 V953) (shen.remove-h V952 V953 ()))

(defun shen.remove-h (V957 V958 V959) (cond ((= () V958) (reverse V959)) ((and (cons? V958) (= (hd V958) V957)) (shen.remove-h (hd V958) (tl V958) V959)) ((cons? V958) (shen.remove-h V957 (tl V958) (cons (hd V958) V959))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V960 V961) (cond ((and (= () V960) (= () V961)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V961) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V960 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V960) (cons call (cons shen.the (cons shen.continuation (cons V961 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V960 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V961 ())))) ())))))))))))

(defun shen.make_mu_application (V962 V963) (cond ((and (cons? V962) (and (= shen.mu (hd V962)) (and (cons? (tl V962)) (and (= () (hd (tl V962))) (and (cons? (tl (tl V962))) (and (= () (tl (tl (tl V962)))) (= () V963))))))) (hd (tl (tl V962)))) ((and (cons? V962) (and (= shen.mu (hd V962)) (and (cons? (tl V962)) (and (cons? (hd (tl V962))) (and (cons? (tl (tl V962))) (and (= () (tl (tl (tl V962)))) (cons? V963))))))) (cons (cons shen.mu (cons (hd (hd (tl V962))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V962))) (tl (tl V962)))) (tl V963)) ()))) (cons (hd V963) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V970 V971) (cond ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (hd (tl (hd V970)))) (and (= mode (hd (hd (tl (hd V970))))) (and (cons? (tl (hd (tl (hd V970))))) (and (cons? (tl (tl (hd (tl (hd V970)))))) (and (= () (tl (tl (tl (hd (tl (hd V970))))))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (= () (tl (tl V970))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V970))))) (tl (tl (hd V970))))) (tl V970)) (hd (tl (tl (hd (tl (hd V970)))))))) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (= _ (hd (tl (hd V970)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V970)))) V971)) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (shen.ephemeral_variable? (hd (tl (hd V970))) (hd (tl V970))))))))))) (subst (hd (tl V970)) (hd (tl (hd V970))) (shen.mu_reduction (hd (tl (tl (hd V970)))) V971))) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (variable? (hd (tl (hd V970)))))))))))) (cons let (cons (hd (tl (hd V970))) (cons shen.be (cons (hd (tl V970)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V970)))) V971) ()))))))) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (and (= - V971) (shen.prolog_constant? (hd (tl (hd V970))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V970))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V970))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V970)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (and (= + V971) (shen.prolog_constant? (hd (tl (hd V970))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V970))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V970))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V970)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V970))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V970)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (hd (tl (hd V970)))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (= - V971)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V970))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V970)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V970)))) (tl (tl (hd V970))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V970) (and (cons? (hd V970)) (and (= shen.mu (hd (hd V970))) (and (cons? (tl (hd V970))) (and (cons? (hd (tl (hd V970)))) (and (cons? (tl (tl (hd V970)))) (and (= () (tl (tl (tl (hd V970))))) (and (cons? (tl V970)) (and (= () (tl (tl V970))) (= + V971)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V970))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V970)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V970)))) (tl (tl (hd V970))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V970)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V970))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V970)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V970)))

(defun shen.rcons_form (V972) (cond ((cons? V972) (cons cons (cons (shen.rcons_form (hd V972)) (cons (shen.rcons_form (tl V972)) ())))) (true V972)))

(defun shen.remove_modes (V973) (cond ((and (cons? V973) (and (= mode (hd V973)) (and (cons? (tl V973)) (and (cons? (tl (tl V973))) (and (= + (hd (tl (tl V973)))) (= () (tl (tl (tl V973))))))))) (shen.remove_modes (hd (tl V973)))) ((and (cons? V973) (and (= mode (hd V973)) (and (cons? (tl V973)) (and (cons? (tl (tl V973))) (and (= - (hd (tl (tl V973)))) (= () (tl (tl (tl V973))))))))) (shen.remove_modes (hd (tl V973)))) ((cons? V973) (cons (shen.remove_modes (hd V973)) (shen.remove_modes (tl V973)))) (true V973)))

(defun shen.ephemeral_variable? (V974 V975) (and (variable? V974) (variable? V975)))

(defun shen.prolog_constant? (V984) (cond ((cons? V984) false) (true true)))

(defun shen.aum_to_shen (V985) (cond ((and (cons? V985) (and (= let (hd V985)) (and (cons? (tl V985)) (and (cons? (tl (tl V985))) (and (= shen.be (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (cons? (tl (tl (tl (tl V985))))) (and (= in (hd (tl (tl (tl (tl V985)))))) (and (cons? (tl (tl (tl (tl (tl V985)))))) (= () (tl (tl (tl (tl (tl (tl V985)))))))))))))))) (cons let (cons (hd (tl V985)) (cons (shen.aum_to_shen (hd (tl (tl (tl V985))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V985))))))) ()))))) ((and (cons? V985) (and (= shen.the (hd V985)) (and (cons? (tl V985)) (and (= shen.result (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.of (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (= shen.dereferencing (hd (tl (tl (tl V985))))) (and (cons? (tl (tl (tl (tl V985))))) (= () (tl (tl (tl (tl (tl V985))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V985)))))) (cons ProcessN ())))) ((and (cons? V985) (and (= if (hd V985)) (and (cons? (tl V985)) (and (cons? (tl (tl V985))) (and (= shen.then (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (cons? (tl (tl (tl (tl V985))))) (and (= shen.else (hd (tl (tl (tl (tl V985)))))) (and (cons? (tl (tl (tl (tl (tl V985)))))) (= () (tl (tl (tl (tl (tl (tl V985)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V985))) (cons (shen.aum_to_shen (hd (tl (tl (tl V985))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V985))))))) ()))))) ((and (cons? V985) (and (cons? (tl V985)) (and (= is (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.a (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (= shen.variable (hd (tl (tl (tl V985))))) (= () (tl (tl (tl (tl V985)))))))))))) (cons shen.pvar? (cons (hd V985) ()))) ((and (cons? V985) (and (cons? (tl V985)) (and (= is (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.a (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (= shen.non-empty (hd (tl (tl (tl V985))))) (and (cons? (tl (tl (tl (tl V985))))) (and (= list (hd (tl (tl (tl (tl V985)))))) (= () (tl (tl (tl (tl (tl V985))))))))))))))) (cons cons? (cons (hd V985) ()))) ((and (cons? V985) (and (= shen.rename (hd V985)) (and (cons? (tl V985)) (and (= shen.the (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.variables (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (= in (hd (tl (tl (tl V985))))) (and (cons? (tl (tl (tl (tl V985))))) (and (= () (hd (tl (tl (tl (tl V985)))))) (and (cons? (tl (tl (tl (tl (tl V985)))))) (and (= and (hd (tl (tl (tl (tl (tl V985))))))) (and (cons? (tl (tl (tl (tl (tl (tl V985))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V985)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V985)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V985)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V985)))))))))) ((and (cons? V985) (and (= shen.rename (hd V985)) (and (cons? (tl V985)) (and (= shen.the (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.variables (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (= in (hd (tl (tl (tl V985))))) (and (cons? (tl (tl (tl (tl V985))))) (and (cons? (hd (tl (tl (tl (tl V985)))))) (and (cons? (tl (tl (tl (tl (tl V985)))))) (and (= and (hd (tl (tl (tl (tl (tl V985))))))) (and (cons? (tl (tl (tl (tl (tl (tl V985))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V985)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V985)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V985)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V985)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V985)))))) (tl (tl (tl (tl (tl V985))))))))))) ()))))) ((and (cons? V985) (and (= bind (hd V985)) (and (cons? (tl V985)) (and (cons? (tl (tl V985))) (and (= shen.to (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (cons? (tl (tl (tl (tl V985))))) (and (= in (hd (tl (tl (tl (tl V985)))))) (and (cons? (tl (tl (tl (tl (tl V985)))))) (= () (tl (tl (tl (tl (tl (tl V985)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V985)) (cons (shen.chwild (hd (tl (tl (tl V985))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V985))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V985)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V985) (and (cons? (tl V985)) (and (= is (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= identical (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (and (= shen.to (hd (tl (tl (tl V985))))) (and (cons? (tl (tl (tl (tl V985))))) (= () (tl (tl (tl (tl (tl V985)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V985))))) (cons (hd V985) ())))) ((= shen.failed! V985) false) ((and (cons? V985) (and (= shen.the (hd V985)) (and (cons? (tl V985)) (and (= head (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.of (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (= () (tl (tl (tl (tl V985)))))))))))) (cons hd (tl (tl (tl V985))))) ((and (cons? V985) (and (= shen.the (hd V985)) (and (cons? (tl V985)) (and (= tail (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.of (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (= () (tl (tl (tl (tl V985)))))))))))) (cons tl (tl (tl (tl V985))))) ((and (cons? V985) (and (= shen.pop (hd V985)) (and (cons? (tl V985)) (and (= shen.the (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.stack (hd (tl (tl V985)))) (= () (tl (tl (tl V985)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V985) (and (= call (hd V985)) (and (cons? (tl V985)) (and (= shen.the (hd (tl V985))) (and (cons? (tl (tl V985))) (and (= shen.continuation (hd (tl (tl V985)))) (and (cons? (tl (tl (tl V985)))) (= () (tl (tl (tl (tl V985)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V985))))) ProcessN Continuation) ())))) (true V985)))

(defun shen.chwild (V986) (cond ((= V986 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V986) (map (lambda V825 (shen.chwild V825)) V986)) (true V986)))

(defun shen.newpv (V987) (let Count+1 (+ (<-address (value shen.*varcounter*) V987) 1) (let IncVar (address-> (value shen.*varcounter*) V987 Count+1) (let Vector (<-address (value shen.*prologvectors*) V987) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V987 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V988 V989) (let Vector (<-address (value shen.*prologvectors*) V988) (let BigVector (shen.resize-vector Vector (+ V989 V989) shen.-null-) (address-> (value shen.*prologvectors*) V988 BigVector))))

(defun shen.resize-vector (V990 V991 V992) (let BigVector (address-> (absvector (+ 1 V991)) 0 V991) (shen.copy-vector V990 BigVector (limit V990) V991 V992)))

(defun shen.copy-vector (V993 V994 V995 V996 V997) (shen.copy-vector-stage-2 (+ 1 V995) (+ V996 1) V997 (shen.copy-vector-stage-1 1 V993 V994 (+ 1 V995))))

(defun shen.copy-vector-stage-1 (V1001 V1002 V1003 V1004) (cond ((= V1004 V1001) V1003) (true (shen.copy-vector-stage-1 (+ 1 V1001) V1002 (address-> V1003 V1001 (<-address V1002 V1001)) V1004))))

(defun shen.copy-vector-stage-2 (V1008 V1009 V1010 V1011) (cond ((= V1009 V1008) V1011) (true (shen.copy-vector-stage-2 (+ V1008 1) V1009 V1010 (address-> V1011 V1008 V1010)))))

(defun shen.mk-pvar (V1012) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1012))

(defun shen.pvar? (V1013) (trap-error (and (absvector? V1013) (= (<-address V1013 0) shen.pvar)) (lambda E false)))

(defun shen.bindv (V1014 V1015 V1016) (let Vector (<-address (value shen.*prologvectors*) V1016) (address-> Vector (<-address V1014 1) V1015)))

(defun shen.unbindv (V1017 V1018) (let Vector (<-address (value shen.*prologvectors*) V1018) (address-> Vector (<-address V1017 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1019 V1020 V1021) (cond ((and (cons? V1019) (and (cons? (hd V1019)) (= () (tl V1019)))) (cons (hd (hd V1019)) (append (tl (hd V1019)) (cons V1020 (cons V1021 ()))))) ((and (cons? V1019) (cons? (hd V1019))) (let NewContinuation (shen.newcontinuation (tl V1019) V1020 V1021) (cons (hd (hd V1019)) (append (tl (hd V1019)) (cons V1020 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1022 V1023 V1024) (cond ((= () V1022) V1024) ((and (cons? V1022) (cons? (hd V1022))) (cons freeze (cons (cons (hd (hd V1022)) (append (tl (hd V1022)) (cons V1023 (cons (shen.newcontinuation (tl V1022) V1023 V1024) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1029 V1030 V1031) (shen.deref V1029 V1030))

(defun shen.measure&return (V1036 V1037 V1038) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1036 V1037)))

(defun unify (V1039 V1040 V1041 V1042) (shen.lzy= (shen.lazyderef V1039 V1041) (shen.lazyderef V1040 V1041) V1041 V1042))

(defun shen.lzy= (V1060 V1061 V1062 V1063) (cond ((= V1061 V1060) (thaw V1063)) ((shen.pvar? V1060) (bind V1060 V1061 V1062 V1063)) ((shen.pvar? V1061) (bind V1061 V1060 V1062 V1063)) ((and (cons? V1060) (cons? V1061)) (shen.lzy= (shen.lazyderef (hd V1060) V1062) (shen.lazyderef (hd V1061) V1062) V1062 (freeze (shen.lzy= (shen.lazyderef (tl V1060) V1062) (shen.lazyderef (tl V1061) V1062) V1062 V1063)))) (true false)))

(defun shen.deref (V1064 V1065) (cond ((cons? V1064) (cons (shen.deref (hd V1064) V1065) (shen.deref (tl V1064) V1065))) (true (if (shen.pvar? V1064) (let Value (shen.valvector V1064 V1065) (if (= Value shen.-null-) V1064 (shen.deref Value V1065))) V1064))))

(defun shen.lazyderef (V1066 V1067) (if (shen.pvar? V1066) (let Value (shen.valvector V1066 V1067) (if (= Value shen.-null-) V1066 (shen.lazyderef Value V1067))) V1066))

(defun shen.valvector (V1068 V1069) (<-address (<-address (value shen.*prologvectors*) V1069) (<-address V1068 1)))

(defun unify! (V1070 V1071 V1072 V1073) (shen.lzy=! (shen.lazyderef V1070 V1072) (shen.lazyderef V1071 V1072) V1072 V1073))

(defun shen.lzy=! (V1091 V1092 V1093 V1094) (cond ((= V1092 V1091) (thaw V1094)) ((and (shen.pvar? V1091) (not (shen.occurs? V1091 (shen.deref V1092 V1093)))) (bind V1091 V1092 V1093 V1094)) ((and (shen.pvar? V1092) (not (shen.occurs? V1092 (shen.deref V1091 V1093)))) (bind V1092 V1091 V1093 V1094)) ((and (cons? V1091) (cons? V1092)) (shen.lzy=! (shen.lazyderef (hd V1091) V1093) (shen.lazyderef (hd V1092) V1093) V1093 (freeze (shen.lzy=! (shen.lazyderef (tl V1091) V1093) (shen.lazyderef (tl V1092) V1093) V1093 V1094)))) (true false)))

(defun shen.occurs? (V1104 V1105) (cond ((= V1105 V1104) true) ((cons? V1105) (or (shen.occurs? V1104 (hd V1105)) (shen.occurs? V1104 (tl V1105)))) (true false)))

(defun identical (V1106 V1107 V1108 V1109) (shen.lzy== (shen.lazyderef V1106 V1108) (shen.lazyderef V1107 V1108) V1108 V1109))

(defun shen.lzy== (V1127 V1128 V1129 V1130) (cond ((= V1128 V1127) (thaw V1130)) ((and (cons? V1127) (cons? V1128)) (shen.lzy== (shen.lazyderef (hd V1127) V1129) (shen.lazyderef (hd V1128) V1129) V1129 (freeze (shen.lzy== (tl V1127) (tl V1128) V1129 V1130)))) (true false)))

(defun shen.pvar (V1131) (cn "Var" (shen.app (<-address V1131 1) "" shen.a)))

(defun bind (V1132 V1133 V1134 V1135) (do (shen.bindv V1132 V1133 V1134) (let Result (thaw V1135) (do (shen.unbindv V1132 V1134) Result))))

(defun fwhen (V1150 V1151 V1152) (cond ((= true V1150) (thaw V1152)) ((= false V1150) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1150 "%" shen.s))))))

(defun call (V1165 V1166 V1167) (cond ((cons? V1165) (let Pred (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1165) V1166)) (let PredF (shen.symbol->function Pred (length (tl V1165))) (shen.call-help PredF (tl V1165) V1166 V1167)))) (true false)))

(defun shen.call-help (V1168 V1169 V1170 V1171) (cond ((= () V1169) (V1168 V1170 V1171)) ((cons? V1169) (shen.call-help (V1168 (hd V1169)) (tl V1169) V1170 V1171)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V1172) (cond ((and (cons? V1172) (cons? (hd V1172))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1172)) (shen.insert-prolog-variables (cons (tl (hd V1172)) (cons (tl V1172) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V1173 V1174 V1175) (cond ((and (cons? V1174) (and (cons? (tl V1174)) (= () (tl (tl V1174))))) (shen.intprolog-help-help V1173 (hd V1174) (hd (tl V1174)) V1175)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1176 V1177 V1178 V1179) (cond ((= () V1177) (V1176 V1179 (freeze (shen.call-rest V1178 V1179)))) ((cons? V1177) (shen.intprolog-help-help (V1176 (hd V1177)) (tl V1177) V1178 V1179)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V1182 V1183) (cond ((= () V1182) true) ((and (cons? V1182) (and (cons? (hd V1182)) (cons? (tl (hd V1182))))) (shen.call-rest (cons (cons ((hd (hd V1182)) (hd (tl (hd V1182)))) (tl (tl (hd V1182)))) (tl V1182)) V1183)) ((and (cons? V1182) (and (cons? (hd V1182)) (= () (tl (hd V1182))))) ((hd (hd V1182)) V1183 (freeze (shen.call-rest (tl V1182) V1183)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1184 V1185) (shen.insert-prolog-variables-help V1184 (shen.flatten V1184) V1185))

(defun shen.insert-prolog-variables-help (V1190 V1191 V1192) (cond ((= () V1191) V1190) ((and (cons? V1191) (variable? (hd V1191))) (let V (shen.newpv V1192) (let XV/Y (subst V (hd V1191) V1190) (let Z-Y (remove (hd V1191) (tl V1191)) (shen.insert-prolog-variables-help XV/Y Z-Y V1192))))) ((cons? V1191) (shen.insert-prolog-variables-help V1190 (tl V1191) V1192)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1193) (let Vector (address-> (value shen.*prologvectors*) V1193 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1193 1) V1193)))



