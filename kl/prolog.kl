"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V1666) (let Parse_shen.<predicate*> (shen.<predicate*> V1666) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V1675 V1676) (cond ((and (cons? V1676) (and (cons? (tl V1676)) (= () (tl (tl V1676))))) (simple-error (cn "prolog syntax error in " (shen.app V1675 (cn " here:

 " (shen.app (shen.next-50 50 (hd V1676)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V1675 "
" shen.a))))))

(defun shen.next-50 (V1683 V1684) (cond ((= () V1684) "") ((= 0 V1683) "") ((cons? V1684) (cn (shen.decons-string (hd V1684)) (shen.next-50 (- V1683 1) (tl V1684)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V1686) (cond ((and (cons? V1686) (and (= cons (hd V1686)) (and (cons? (tl V1686)) (and (cons? (tl (tl V1686))) (= () (tl (tl (tl V1686)))))))) (shen.app (shen.eval-cons V1686) " " shen.s)) (true (shen.app V1686 " " shen.r))))

(defun shen.insert-predicate (V1689 V1690) (cond ((and (cons? V1690) (and (cons? (tl V1690)) (= () (tl (tl V1690))))) (cons (cons V1689 (hd V1690)) (cons :- (tl V1690)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V1692) (if (cons? (hd V1692)) (let Parse_X (hd (hd V1692)) (shen.pair (hd (shen.pair (tl (hd V1692)) (shen.hdtl V1692))) Parse_X)) (fail)))

(defun shen.<clauses*> (V1694) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V1694) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1694) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<clause*> (V1696) (let Parse_shen.<head*> (shen.<head*> V1696) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V1698) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V1698) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1698) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<term*> (V1700) (if (cons? (hd V1700)) (let Parse_X (hd (hd V1700)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V1700)) (shen.hdtl V1700))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V1706) (cond ((and (cons? V1706) (and (= cons (hd V1706)) (and (cons? (tl V1706)) (and (cons? (tl (tl V1706))) (= () (tl (tl (tl V1706)))))))) (and (shen.legitimate-term? (hd (tl V1706))) (shen.legitimate-term? (hd (tl (tl V1706)))))) ((and (cons? V1706) (and (= mode (hd V1706)) (and (cons? (tl V1706)) (and (cons? (tl (tl V1706))) (and (= + (hd (tl (tl V1706)))) (= () (tl (tl (tl V1706))))))))) (shen.legitimate-term? (hd (tl V1706)))) ((and (cons? V1706) (and (= mode (hd V1706)) (and (cons? (tl V1706)) (and (cons? (tl (tl V1706))) (and (= - (hd (tl (tl V1706)))) (= () (tl (tl (tl V1706))))))))) (shen.legitimate-term? (hd (tl V1706)))) ((cons? V1706) false) (true true)))

(defun shen.eval-cons (V1708) (cond ((and (cons? V1708) (and (= cons (hd V1708)) (and (cons? (tl V1708)) (and (cons? (tl (tl V1708))) (= () (tl (tl (tl V1708)))))))) (cons (shen.eval-cons (hd (tl V1708))) (shen.eval-cons (hd (tl (tl V1708)))))) ((and (cons? V1708) (and (= mode (hd V1708)) (and (cons? (tl V1708)) (and (cons? (tl (tl V1708))) (= () (tl (tl (tl V1708)))))))) (cons mode (cons (shen.eval-cons (hd (tl V1708))) (tl (tl V1708))))) (true V1708)))

(defun shen.<body*> (V1710) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V1710) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1710) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<literal*> (V1712) (let YaccParse (if (and (cons? (hd V1712)) (= ! (hd (hd V1712)))) (shen.pair (hd (shen.pair (tl (hd V1712)) (shen.hdtl V1712))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V1712)) (let Parse_X (hd (hd V1712)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1712)) (shen.hdtl V1712))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V1714) (if (cons? (hd V1714)) (let Parse_X (hd (hd V1714)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V1714)) (shen.hdtl V1714))) Parse_X) (fail))) (fail)))

(defun cut (V1718 V1719 V1720) (let Result (thaw V1720) (if (= Result false) V1718 Result)))

(defun shen.insert_modes (V1722) (cond ((and (cons? V1722) (and (= mode (hd V1722)) (and (cons? (tl V1722)) (and (cons? (tl (tl V1722))) (= () (tl (tl (tl V1722)))))))) V1722) ((= () V1722) ()) ((cons? V1722) (cons (cons mode (cons (hd V1722) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V1722)) (cons - ()))))) (true V1722)))

(defun shen.s-prolog (V1724) (map (lambda X (eval X)) (shen.prolog->shen V1724)))

(defun shen.prolog->shen (V1726) (map (lambda X (shen.compile_prolog_procedure X)) (shen.group_clauses (map (lambda X (shen.s-prolog_clause X)) (mapcan (lambda X (shen.head_abstraction X)) V1726)))))

(defun shen.s-prolog_clause (V1728) (cond ((and (cons? V1728) (and (cons? (tl V1728)) (and (= :- (hd (tl V1728))) (and (cons? (tl (tl V1728))) (= () (tl (tl (tl V1728)))))))) (cons (hd V1728) (cons :- (cons (map (lambda X (shen.s-prolog_literal X)) (hd (tl (tl V1728)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V1730) (cond ((and (cons? V1730) (and (cons? (tl V1730)) (and (= :- (hd (tl V1730))) (and (cons? (tl (tl V1730))) (and (= () (tl (tl (tl V1730)))) (< (shen.complexity_head (hd V1730)) (value shen.*maxcomplexity*))))))) (cons V1730 ())) ((and (cons? V1730) (and (cons? (hd V1730)) (and (cons? (tl V1730)) (and (= :- (hd (tl V1730))) (and (cons? (tl (tl V1730))) (= () (tl (tl (tl V1730))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V1730))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V1730)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V1730)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V1730)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V1736) (cond ((cons? V1736) (shen.product (map (lambda X (shen.complexity X)) (tl V1736)))) (true (shen.f_error shen.complexity_head))))

(defun shen.complexity (V1745) (cond ((and (cons? V1745) (and (= mode (hd V1745)) (and (cons? (tl V1745)) (and (cons? (hd (tl V1745))) (and (= mode (hd (hd (tl V1745)))) (and (cons? (tl (hd (tl V1745)))) (and (cons? (tl (tl (hd (tl V1745))))) (and (= () (tl (tl (tl (hd (tl V1745)))))) (and (cons? (tl (tl V1745))) (= () (tl (tl (tl V1745))))))))))))) (shen.complexity (hd (tl V1745)))) ((and (cons? V1745) (and (= mode (hd V1745)) (and (cons? (tl V1745)) (and (cons? (hd (tl V1745))) (and (cons? (tl (tl V1745))) (and (= + (hd (tl (tl V1745)))) (= () (tl (tl (tl V1745)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V1745))) (tl (tl V1745))))) (shen.complexity (cons mode (cons (tl (hd (tl V1745))) (tl (tl V1745)))))))) ((and (cons? V1745) (and (= mode (hd V1745)) (and (cons? (tl V1745)) (and (cons? (hd (tl V1745))) (and (cons? (tl (tl V1745))) (and (= - (hd (tl (tl V1745)))) (= () (tl (tl (tl V1745)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V1745))) (tl (tl V1745))))) (shen.complexity (cons mode (cons (tl (hd (tl V1745))) (tl (tl V1745))))))) ((and (cons? V1745) (and (= mode (hd V1745)) (and (cons? (tl V1745)) (and (cons? (tl (tl V1745))) (and (= () (tl (tl (tl V1745)))) (variable? (hd (tl V1745)))))))) 1) ((and (cons? V1745) (and (= mode (hd V1745)) (and (cons? (tl V1745)) (and (cons? (tl (tl V1745))) (and (= + (hd (tl (tl V1745)))) (= () (tl (tl (tl V1745))))))))) 2) ((and (cons? V1745) (and (= mode (hd V1745)) (and (cons? (tl V1745)) (and (cons? (tl (tl V1745))) (and (= - (hd (tl (tl V1745)))) (= () (tl (tl (tl V1745))))))))) 1) (true (shen.complexity (cons mode (cons V1745 (cons + ())))))))

(defun shen.product (V1747) (cond ((= () V1747) 1) ((cons? V1747) (* (hd V1747) (shen.product (tl V1747)))) (true (shen.f_error shen.product))))

(defun shen.s-prolog_literal (V1749) (cond ((and (cons? V1749) (and (= is (hd V1749)) (and (cons? (tl V1749)) (and (cons? (tl (tl V1749))) (= () (tl (tl (tl V1749)))))))) (cons bind (cons (hd (tl V1749)) (cons (shen.insert_deref (hd (tl (tl V1749)))) ())))) ((and (cons? V1749) (and (= when (hd V1749)) (and (cons? (tl V1749)) (= () (tl (tl V1749)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V1749))) ()))) ((and (cons? V1749) (and (= bind (hd V1749)) (and (cons? (tl V1749)) (and (cons? (tl (tl V1749))) (= () (tl (tl (tl V1749)))))))) (cons bind (cons (hd (tl V1749)) (cons (shen.insert_lazyderef (hd (tl (tl V1749)))) ())))) ((and (cons? V1749) (and (= fwhen (hd V1749)) (and (cons? (tl V1749)) (= () (tl (tl V1749)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V1749))) ()))) ((cons? V1749) V1749) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V1751) (cond ((variable? V1751) (cons shen.deref (cons V1751 (cons ProcessN ())))) ((cons? V1751) (cons (shen.insert_deref (hd V1751)) (shen.insert_deref (tl V1751)))) (true V1751)))

(defun shen.insert_lazyderef (V1753) (cond ((variable? V1753) (cons shen.lazyderef (cons V1753 (cons ProcessN ())))) ((cons? V1753) (cons (shen.insert_lazyderef (hd V1753)) (shen.insert_lazyderef (tl V1753)))) (true V1753)))

(defun shen.group_clauses (V1755) (cond ((= () V1755) ()) ((cons? V1755) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V1755) X)) V1755) (let Rest (difference V1755 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V1760 V1761) (cond ((= () V1761) ()) ((cons? V1761) (if (V1760 (hd V1761)) (cons (hd V1761) (shen.collect V1760 (tl V1761))) (shen.collect V1760 (tl V1761)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V1780 V1781) (cond ((and (cons? V1780) (and (cons? (hd V1780)) (and (cons? V1781) (cons? (hd V1781))))) (= (hd (hd V1780)) (hd (hd V1781)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1783) (let F (shen.procedure_name V1783) (let Shen (shen.clauses-to-shen F V1783) Shen)))

(defun shen.procedure_name (V1797) (cond ((and (cons? V1797) (and (cons? (hd V1797)) (cons? (hd (hd V1797))))) (hd (hd (hd V1797)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V1800 V1801) (let Linear (map (lambda X (shen.linearise-clause X)) V1801) (let Arity (shen.prolog-aritycheck V1800 (map (lambda X (head X)) V1801)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda X (shen.aum_to_shen X)) AUM_instructions))) (let ShenDef (cons define (cons V1800 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1803) (cond ((not (shen.occurs? cut V1803)) V1803) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1803 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1811 V1812) (cond ((= V1812 V1811) false) (true V1812)))

(defun shen.nest-disjunct (V1814) (cond ((and (cons? V1814) (= () (tl V1814))) (hd V1814)) ((cons? V1814) (shen.lisp-or (hd V1814) (shen.nest-disjunct (tl V1814)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V1817 V1818) (cons let (cons Case (cons V1817 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1818 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1823 V1824) (cond ((and (cons? V1824) (= () (tl V1824))) (- (length (hd V1824)) 1)) ((and (cons? V1824) (cons? (tl V1824))) (if (= (length (hd V1824)) (length (hd (tl V1824)))) (shen.prolog-aritycheck V1823 (tl V1824)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1823 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1826) (cond ((and (cons? V1826) (and (cons? (tl V1826)) (and (= :- (hd (tl V1826))) (and (cons? (tl (tl V1826))) (= () (tl (tl (tl V1826)))))))) (let Linear (shen.linearise (cons (hd V1826) (tl (tl V1826)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V1828) (cond ((and (cons? V1828) (and (cons? (tl V1828)) (= () (tl (tl V1828))))) (cons (shen.explicit_modes (hd V1828)) (cons :- (cons (shen.cf_help (hd (tl V1828))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V1830) (cond ((cons? V1830) (cons (hd V1830) (map (lambda X (shen.em_help X)) (tl V1830)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V1832) (cond ((and (cons? V1832) (and (= mode (hd V1832)) (and (cons? (tl V1832)) (and (cons? (tl (tl V1832))) (= () (tl (tl (tl V1832)))))))) V1832) (true (cons mode (cons V1832 (cons + ()))))))

(defun shen.cf_help (V1834) (cond ((and (cons? V1834) (and (= where (hd V1834)) (and (cons? (tl V1834)) (and (cons? (hd (tl V1834))) (and (= = (hd (hd (tl V1834)))) (and (cons? (tl (hd (tl V1834)))) (and (cons? (tl (tl (hd (tl V1834))))) (and (= () (tl (tl (tl (hd (tl V1834)))))) (and (cons? (tl (tl V1834))) (= () (tl (tl (tl V1834))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1834)))) (shen.cf_help (hd (tl (tl V1834)))))) (true V1834)))

(defun occurs-check (V1840) (cond ((= + V1840) (set shen.*occurs* true)) ((= - V1840) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1843 V1844) (cond ((and (cons? V1843) (and (cons? (hd V1843)) (and (cons? (tl V1843)) (and (= :- (hd (tl V1843))) (and (cons? (tl (tl V1843))) (= () (tl (tl (tl V1843))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1843)) (cons (shen.continuation_call (tl (hd V1843)) (hd (tl (tl V1843)))) ()))) V1844) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V1847 V1848) (let VTerms (cons ProcessN (shen.extract_vars V1847)) (let VBody (shen.extract_vars V1848) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1848)))))

(defun remove (V1851 V1852) (shen.remove-h V1851 V1852 ()))

(defun shen.remove-h (V1859 V1860 V1861) (cond ((= () V1860) (reverse V1861)) ((and (cons? V1860) (= (hd V1860) V1859)) (shen.remove-h (hd V1860) (tl V1860) V1861)) ((cons? V1860) (shen.remove-h V1859 (tl V1860) (cons (hd V1860) V1861))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V1864 V1865) (cond ((and (= () V1864) (= () V1865)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1865) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1864 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1864) (cons call (cons shen.the (cons shen.continuation (cons V1865 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1864 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1865 ())))) ())))))))))))

(defun shen.make_mu_application (V1868 V1869) (cond ((and (cons? V1868) (and (= shen.mu (hd V1868)) (and (cons? (tl V1868)) (and (= () (hd (tl V1868))) (and (cons? (tl (tl V1868))) (and (= () (tl (tl (tl V1868)))) (= () V1869))))))) (hd (tl (tl V1868)))) ((and (cons? V1868) (and (= shen.mu (hd V1868)) (and (cons? (tl V1868)) (and (cons? (hd (tl V1868))) (and (cons? (tl (tl V1868))) (and (= () (tl (tl (tl V1868)))) (cons? V1869))))))) (cons (cons shen.mu (cons (hd (hd (tl V1868))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1868))) (tl (tl V1868)))) (tl V1869)) ()))) (cons (hd V1869) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V1878 V1879) (cond ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (hd (tl (hd V1878)))) (and (= mode (hd (hd (tl (hd V1878))))) (and (cons? (tl (hd (tl (hd V1878))))) (and (cons? (tl (tl (hd (tl (hd V1878)))))) (and (= () (tl (tl (tl (hd (tl (hd V1878))))))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (= () (tl (tl V1878))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1878))))) (tl (tl (hd V1878))))) (tl V1878)) (hd (tl (tl (hd (tl (hd V1878)))))))) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (= _ (hd (tl (hd V1878)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1878)))) V1879)) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (shen.ephemeral_variable? (hd (tl (hd V1878))) (hd (tl V1878))))))))))) (subst (hd (tl V1878)) (hd (tl (hd V1878))) (shen.mu_reduction (hd (tl (tl (hd V1878)))) V1879))) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (variable? (hd (tl (hd V1878)))))))))))) (cons let (cons (hd (tl (hd V1878))) (cons shen.be (cons (hd (tl V1878)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1878)))) V1879) ()))))))) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (and (= - V1879) (shen.prolog_constant? (hd (tl (hd V1878))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1878))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1878))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1878)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (and (= + V1879) (shen.prolog_constant? (hd (tl (hd V1878))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1878))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1878))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1878)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1878))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1878)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (hd (tl (hd V1878)))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (= - V1879)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1878))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1878)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1878)))) (tl (tl (hd V1878))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1878) (and (cons? (hd V1878)) (and (= shen.mu (hd (hd V1878))) (and (cons? (tl (hd V1878))) (and (cons? (hd (tl (hd V1878)))) (and (cons? (tl (tl (hd V1878)))) (and (= () (tl (tl (tl (hd V1878))))) (and (cons? (tl V1878)) (and (= () (tl (tl V1878))) (= + V1879)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1878))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1878)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1878)))) (tl (tl (hd V1878))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1878)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1878))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1878)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1878)))

(defun shen.rcons_form (V1881) (cond ((cons? V1881) (cons cons (cons (shen.rcons_form (hd V1881)) (cons (shen.rcons_form (tl V1881)) ())))) (true V1881)))

(defun shen.remove_modes (V1883) (cond ((and (cons? V1883) (and (= mode (hd V1883)) (and (cons? (tl V1883)) (and (cons? (tl (tl V1883))) (and (= + (hd (tl (tl V1883)))) (= () (tl (tl (tl V1883))))))))) (shen.remove_modes (hd (tl V1883)))) ((and (cons? V1883) (and (= mode (hd V1883)) (and (cons? (tl V1883)) (and (cons? (tl (tl V1883))) (and (= - (hd (tl (tl V1883)))) (= () (tl (tl (tl V1883))))))))) (shen.remove_modes (hd (tl V1883)))) ((cons? V1883) (cons (shen.remove_modes (hd V1883)) (shen.remove_modes (tl V1883)))) (true V1883)))

(defun shen.ephemeral_variable? (V1886 V1887) (and (variable? V1886) (variable? V1887)))

(defun shen.prolog_constant? (V1897) (cond ((cons? V1897) false) (true true)))

(defun shen.aum_to_shen (V1899) (cond ((and (cons? V1899) (and (= let (hd V1899)) (and (cons? (tl V1899)) (and (cons? (tl (tl V1899))) (and (= shen.be (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (cons? (tl (tl (tl (tl V1899))))) (and (= in (hd (tl (tl (tl (tl V1899)))))) (and (cons? (tl (tl (tl (tl (tl V1899)))))) (= () (tl (tl (tl (tl (tl (tl V1899)))))))))))))))) (cons let (cons (hd (tl V1899)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1899))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1899))))))) ()))))) ((and (cons? V1899) (and (= shen.the (hd V1899)) (and (cons? (tl V1899)) (and (= shen.result (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.of (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (= shen.dereferencing (hd (tl (tl (tl V1899))))) (and (cons? (tl (tl (tl (tl V1899))))) (= () (tl (tl (tl (tl (tl V1899))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1899)))))) (cons ProcessN ())))) ((and (cons? V1899) (and (= if (hd V1899)) (and (cons? (tl V1899)) (and (cons? (tl (tl V1899))) (and (= shen.then (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (cons? (tl (tl (tl (tl V1899))))) (and (= shen.else (hd (tl (tl (tl (tl V1899)))))) (and (cons? (tl (tl (tl (tl (tl V1899)))))) (= () (tl (tl (tl (tl (tl (tl V1899)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1899))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1899))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1899))))))) ()))))) ((and (cons? V1899) (and (cons? (tl V1899)) (and (= is (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.a (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (= shen.variable (hd (tl (tl (tl V1899))))) (= () (tl (tl (tl (tl V1899)))))))))))) (cons shen.pvar? (cons (hd V1899) ()))) ((and (cons? V1899) (and (cons? (tl V1899)) (and (= is (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.a (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (= shen.non-empty (hd (tl (tl (tl V1899))))) (and (cons? (tl (tl (tl (tl V1899))))) (and (= list (hd (tl (tl (tl (tl V1899)))))) (= () (tl (tl (tl (tl (tl V1899))))))))))))))) (cons cons? (cons (hd V1899) ()))) ((and (cons? V1899) (and (= shen.rename (hd V1899)) (and (cons? (tl V1899)) (and (= shen.the (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.variables (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (= in (hd (tl (tl (tl V1899))))) (and (cons? (tl (tl (tl (tl V1899))))) (and (= () (hd (tl (tl (tl (tl V1899)))))) (and (cons? (tl (tl (tl (tl (tl V1899)))))) (and (= and (hd (tl (tl (tl (tl (tl V1899))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1899))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1899)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1899)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1899)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1899)))))))))) ((and (cons? V1899) (and (= shen.rename (hd V1899)) (and (cons? (tl V1899)) (and (= shen.the (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.variables (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (= in (hd (tl (tl (tl V1899))))) (and (cons? (tl (tl (tl (tl V1899))))) (and (cons? (hd (tl (tl (tl (tl V1899)))))) (and (cons? (tl (tl (tl (tl (tl V1899)))))) (and (= and (hd (tl (tl (tl (tl (tl V1899))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1899))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1899)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1899)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1899)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1899)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1899)))))) (tl (tl (tl (tl (tl V1899))))))))))) ()))))) ((and (cons? V1899) (and (= bind (hd V1899)) (and (cons? (tl V1899)) (and (cons? (tl (tl V1899))) (and (= shen.to (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (cons? (tl (tl (tl (tl V1899))))) (and (= in (hd (tl (tl (tl (tl V1899)))))) (and (cons? (tl (tl (tl (tl (tl V1899)))))) (= () (tl (tl (tl (tl (tl (tl V1899)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1899)) (cons (shen.chwild (hd (tl (tl (tl V1899))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1899))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1899)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1899) (and (cons? (tl V1899)) (and (= is (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= identical (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (and (= shen.to (hd (tl (tl (tl V1899))))) (and (cons? (tl (tl (tl (tl V1899))))) (= () (tl (tl (tl (tl (tl V1899)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1899))))) (cons (hd V1899) ())))) ((= shen.failed! V1899) false) ((and (cons? V1899) (and (= shen.the (hd V1899)) (and (cons? (tl V1899)) (and (= head (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.of (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (= () (tl (tl (tl (tl V1899)))))))))))) (cons hd (tl (tl (tl V1899))))) ((and (cons? V1899) (and (= shen.the (hd V1899)) (and (cons? (tl V1899)) (and (= tail (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.of (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (= () (tl (tl (tl (tl V1899)))))))))))) (cons tl (tl (tl (tl V1899))))) ((and (cons? V1899) (and (= shen.pop (hd V1899)) (and (cons? (tl V1899)) (and (= shen.the (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.stack (hd (tl (tl V1899)))) (= () (tl (tl (tl V1899)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1899) (and (= call (hd V1899)) (and (cons? (tl V1899)) (and (= shen.the (hd (tl V1899))) (and (cons? (tl (tl V1899))) (and (= shen.continuation (hd (tl (tl V1899)))) (and (cons? (tl (tl (tl V1899)))) (= () (tl (tl (tl (tl V1899)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1899))))) ProcessN Continuation) ())))) (true V1899)))

(defun shen.chwild (V1901) (cond ((= V1901 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1901) (map (lambda Z (shen.chwild Z)) V1901)) (true V1901)))

(defun shen.newpv (V1903) (let Count+1 (+ (<-address (value shen.*varcounter*) V1903) 1) (let IncVar (address-> (value shen.*varcounter*) V1903 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1903) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1903 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1906 V1907) (let Vector (<-address (value shen.*prologvectors*) V1906) (let BigVector (shen.resize-vector Vector (+ V1907 V1907) shen.-null-) (address-> (value shen.*prologvectors*) V1906 BigVector))))

(defun shen.resize-vector (V1911 V1912 V1913) (let BigVector (address-> (absvector (+ 1 V1912)) 0 V1912) (shen.copy-vector V1911 BigVector (limit V1911) V1912 V1913)))

(defun shen.copy-vector (V1919 V1920 V1921 V1922 V1923) (shen.copy-vector-stage-2 (+ 1 V1921) (+ V1922 1) V1923 (shen.copy-vector-stage-1 1 V1919 V1920 (+ 1 V1921))))

(defun shen.copy-vector-stage-1 (V1931 V1932 V1933 V1934) (cond ((= V1934 V1931) V1933) (true (shen.copy-vector-stage-1 (+ 1 V1931) V1932 (address-> V1933 V1931 (<-address V1932 V1931)) V1934))))

(defun shen.copy-vector-stage-2 (V1942 V1943 V1944 V1945) (cond ((= V1943 V1942) V1945) (true (shen.copy-vector-stage-2 (+ V1942 1) V1943 V1944 (address-> V1945 V1942 V1944)))))

(defun shen.mk-pvar (V1947) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1947))

(defun shen.pvar? (V1949) (trap-error (and (absvector? V1949) (= (<-address V1949 0) shen.pvar)) (lambda E false)))

(defun shen.bindv (V1953 V1954 V1955) (let Vector (<-address (value shen.*prologvectors*) V1955) (address-> Vector (<-address V1953 1) V1954)))

(defun shen.unbindv (V1958 V1959) (let Vector (<-address (value shen.*prologvectors*) V1959) (address-> Vector (<-address V1958 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1963 V1964 V1965) (cond ((and (cons? V1963) (and (cons? (hd V1963)) (= () (tl V1963)))) (cons (hd (hd V1963)) (append (tl (hd V1963)) (cons V1964 (cons V1965 ()))))) ((and (cons? V1963) (cons? (hd V1963))) (let NewContinuation (shen.newcontinuation (tl V1963) V1964 V1965) (cons (hd (hd V1963)) (append (tl (hd V1963)) (cons V1964 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1969 V1970 V1971) (cond ((= () V1969) V1971) ((and (cons? V1969) (cons? (hd V1969))) (cons freeze (cons (cons (hd (hd V1969)) (append (tl (hd V1969)) (cons V1970 (cons (shen.newcontinuation (tl V1969) V1970 V1971) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1979 V1980 V1981) (shen.deref V1979 V1980))

(defun shen.measure&return (V1989 V1990 V1991) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1989 V1990)))

(defun unify (V1996 V1997 V1998 V1999) (shen.lzy= (shen.lazyderef V1996 V1998) (shen.lazyderef V1997 V1998) V1998 V1999))

(defun shen.lzy= (V2021 V2022 V2023 V2024) (cond ((= V2022 V2021) (thaw V2024)) ((shen.pvar? V2021) (bind V2021 V2022 V2023 V2024)) ((shen.pvar? V2022) (bind V2022 V2021 V2023 V2024)) ((and (cons? V2021) (cons? V2022)) (shen.lzy= (shen.lazyderef (hd V2021) V2023) (shen.lazyderef (hd V2022) V2023) V2023 (freeze (shen.lzy= (shen.lazyderef (tl V2021) V2023) (shen.lazyderef (tl V2022) V2023) V2023 V2024)))) (true false)))

(defun shen.deref (V2027 V2028) (cond ((cons? V2027) (cons (shen.deref (hd V2027) V2028) (shen.deref (tl V2027) V2028))) (true (if (shen.pvar? V2027) (let Value (shen.valvector V2027 V2028) (if (= Value shen.-null-) V2027 (shen.deref Value V2028))) V2027))))

(defun shen.lazyderef (V2031 V2032) (if (shen.pvar? V2031) (let Value (shen.valvector V2031 V2032) (if (= Value shen.-null-) V2031 (shen.lazyderef Value V2032))) V2031))

(defun shen.valvector (V2035 V2036) (<-address (<-address (value shen.*prologvectors*) V2036) (<-address V2035 1)))

(defun unify! (V2041 V2042 V2043 V2044) (shen.lzy=! (shen.lazyderef V2041 V2043) (shen.lazyderef V2042 V2043) V2043 V2044))

(defun shen.lzy=! (V2066 V2067 V2068 V2069) (cond ((= V2067 V2066) (thaw V2069)) ((and (shen.pvar? V2066) (not (shen.occurs? V2066 (shen.deref V2067 V2068)))) (bind V2066 V2067 V2068 V2069)) ((and (shen.pvar? V2067) (not (shen.occurs? V2067 (shen.deref V2066 V2068)))) (bind V2067 V2066 V2068 V2069)) ((and (cons? V2066) (cons? V2067)) (shen.lzy=! (shen.lazyderef (hd V2066) V2068) (shen.lazyderef (hd V2067) V2068) V2068 (freeze (shen.lzy=! (shen.lazyderef (tl V2066) V2068) (shen.lazyderef (tl V2067) V2068) V2068 V2069)))) (true false)))

(defun shen.occurs? (V2081 V2082) (cond ((= V2082 V2081) true) ((cons? V2082) (or (shen.occurs? V2081 (hd V2082)) (shen.occurs? V2081 (tl V2082)))) (true false)))

(defun identical (V2087 V2088 V2089 V2090) (shen.lzy== (shen.lazyderef V2087 V2089) (shen.lazyderef V2088 V2089) V2089 V2090))

(defun shen.lzy== (V2112 V2113 V2114 V2115) (cond ((= V2113 V2112) (thaw V2115)) ((and (cons? V2112) (cons? V2113)) (shen.lzy== (shen.lazyderef (hd V2112) V2114) (shen.lazyderef (hd V2113) V2114) V2114 (freeze (shen.lzy== (tl V2112) (tl V2113) V2114 V2115)))) (true false)))

(defun shen.pvar (V2117) (cn "Var" (shen.app (<-address V2117 1) "" shen.a)))

(defun bind (V2122 V2123 V2124 V2125) (do (shen.bindv V2122 V2123 V2124) (let Result (thaw V2125) (do (shen.unbindv V2122 V2124) Result))))

(defun fwhen (V2143 V2144 V2145) (cond ((= true V2143) (thaw V2145)) ((= false V2143) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V2143 "%" shen.s))))))

(defun call (V2161 V2162 V2163) (cond ((cons? V2161) (shen.call-help (function (shen.lazyderef (hd V2161) V2162)) (tl V2161) V2162 V2163)) (true false)))

(defun shen.call-help (V2168 V2169 V2170 V2171) (cond ((= () V2169) (V2168 V2170 V2171)) ((cons? V2169) (shen.call-help (V2168 (hd V2169)) (tl V2169) V2170 V2171)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V2173) (cond ((and (cons? V2173) (cons? (hd V2173))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V2173)) (shen.insert-prolog-variables (cons (tl (hd V2173)) (cons (tl V2173) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V2177 V2178 V2179) (cond ((and (cons? V2178) (and (cons? (tl V2178)) (= () (tl (tl V2178))))) (shen.intprolog-help-help V2177 (hd V2178) (hd (tl V2178)) V2179)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V2184 V2185 V2186 V2187) (cond ((= () V2185) (V2184 V2187 (freeze (shen.call-rest V2186 V2187)))) ((cons? V2185) (shen.intprolog-help-help (V2184 (hd V2185)) (tl V2185) V2186 V2187)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V2192 V2193) (cond ((= () V2192) true) ((and (cons? V2192) (and (cons? (hd V2192)) (cons? (tl (hd V2192))))) (shen.call-rest (cons (cons ((hd (hd V2192)) (hd (tl (hd V2192)))) (tl (tl (hd V2192)))) (tl V2192)) V2193)) ((and (cons? V2192) (and (cons? (hd V2192)) (= () (tl (hd V2192))))) ((hd (hd V2192)) V2193 (freeze (shen.call-rest (tl V2192) V2193)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V2196 V2197) (shen.insert-prolog-variables-help V2196 (shen.flatten V2196) V2197))

(defun shen.insert-prolog-variables-help (V2205 V2206 V2207) (cond ((= () V2206) V2205) ((and (cons? V2206) (variable? (hd V2206))) (let V (shen.newpv V2207) (let XV/Y (subst V (hd V2206) V2205) (let Z-Y (remove (hd V2206) (tl V2206)) (shen.insert-prolog-variables-help XV/Y Z-Y V2207))))) ((cons? V2206) (shen.insert-prolog-variables-help V2205 (tl V2206) V2207)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V2209) (let Vector (address-> (value shen.*prologvectors*) V2209 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V2209 1) V2209)))



