"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.<defprolog> (V828) (let Parse_shen.<predicate*> (shen.<predicate*> V828) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))))

(defun shen.prolog-error (V835 V836) (cond ((and (cons? V836) (and (cons? (tl V836)) (= () (tl (tl V836))))) (simple-error (cn "prolog syntax error in " (shen.app V835 (cn " here:

 " (shen.app (shen.next-50 50 (hd V836)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V835 "
" shen.a))))))

(defun shen.next-50 (V841 V842) (cond ((= () V842) "") ((= 0 V841) "") ((cons? V842) (cn (shen.decons-string (hd V842)) (shen.next-50 (- V841 1) (tl V842)))) (true (shen.f_error shen.next-50))))

(defun shen.decons-string (V843) (cond ((and (cons? V843) (and (= cons (hd V843)) (and (cons? (tl V843)) (and (cons? (tl (tl V843))) (= () (tl (tl (tl V843)))))))) (shen.app (shen.eval-cons V843) " " shen.s)) (true (shen.app V843 " " shen.r))))

(defun shen.insert-predicate (V844 V845) (cond ((and (cons? V845) (and (cons? (tl V845)) (= () (tl (tl V845))))) (cons (cons V844 (hd V845)) (cons :- (tl V845)))) (true (shen.f_error shen.insert-predicate))))

(defun shen.<predicate*> (V846) (if (cons? (hd V846)) (let Parse_X (hd (hd V846)) (shen.pair (hd (shen.pair (tl (hd V846)) (shen.hdtl V846))) Parse_X)) (fail)))

(defun shen.<clauses*> (V847) (let YaccParse (let Parse_shen.<clause*> (shen.<clause*> V847) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V847) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (shen.hdtl Parse_<e>)) (fail))) YaccParse)))

(defun shen.<clause*> (V848) (let Parse_shen.<head*> (shen.<head*> V848) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))))

(defun shen.<head*> (V849) (let YaccParse (let Parse_shen.<term*> (shen.<term*> V849) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V849) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (shen.hdtl Parse_<e>)) (fail))) YaccParse)))

(defun shen.<term*> (V850) (if (cons? (hd V850)) (let Parse_X (hd (hd V850)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V850)) (shen.hdtl V850))) (shen.eval-cons Parse_X)) (fail))) (fail)))

(defun shen.legitimate-term? (V855) (cond ((and (cons? V855) (and (= cons (hd V855)) (and (cons? (tl V855)) (and (cons? (tl (tl V855))) (= () (tl (tl (tl V855)))))))) (and (shen.legitimate-term? (hd (tl V855))) (shen.legitimate-term? (hd (tl (tl V855)))))) ((and (cons? V855) (and (= mode (hd V855)) (and (cons? (tl V855)) (and (cons? (tl (tl V855))) (and (= + (hd (tl (tl V855)))) (= () (tl (tl (tl V855))))))))) (shen.legitimate-term? (hd (tl V855)))) ((and (cons? V855) (and (= mode (hd V855)) (and (cons? (tl V855)) (and (cons? (tl (tl V855))) (and (= - (hd (tl (tl V855)))) (= () (tl (tl (tl V855))))))))) (shen.legitimate-term? (hd (tl V855)))) ((cons? V855) false) (true true)))

(defun shen.eval-cons (V856) (cond ((and (cons? V856) (and (= cons (hd V856)) (and (cons? (tl V856)) (and (cons? (tl (tl V856))) (= () (tl (tl (tl V856)))))))) (cons (shen.eval-cons (hd (tl V856))) (shen.eval-cons (hd (tl (tl V856)))))) ((and (cons? V856) (and (= mode (hd V856)) (and (cons? (tl V856)) (and (cons? (tl (tl V856))) (= () (tl (tl (tl V856)))))))) (cons mode (cons (shen.eval-cons (hd (tl V856))) (tl (tl V856))))) (true V856)))

(defun shen.<body*> (V857) (let YaccParse (let Parse_shen.<literal*> (shen.<literal*> V857) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V857) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (shen.hdtl Parse_<e>)) (fail))) YaccParse)))

(defun shen.<literal*> (V858) (let YaccParse (if (and (cons? (hd V858)) (= ! (hd (hd V858)))) (shen.pair (hd (shen.pair (tl (hd V858)) (shen.hdtl V858))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= YaccParse (fail)) (if (cons? (hd V858)) (let Parse_X (hd (hd V858)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V858)) (shen.hdtl V858))) Parse_X) (fail))) (fail)) YaccParse)))

(defun shen.<end*> (V859) (if (cons? (hd V859)) (let Parse_X (hd (hd V859)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V859)) (shen.hdtl V859))) Parse_X) (fail))) (fail)))

(defun cut (V860 V861 V862) (let Result (thaw V862) (if (= Result false) V860 Result)))

(defun shen.insert_modes (V863) (cond ((and (cons? V863) (and (= mode (hd V863)) (and (cons? (tl V863)) (and (cons? (tl (tl V863))) (= () (tl (tl (tl V863)))))))) V863) ((= () V863) ()) ((cons? V863) (cons (cons mode (cons (hd V863) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V863)) (cons - ()))))) (true V863)))

(defun shen.s-prolog (V864) (map (lambda V817 (eval V817)) (shen.prolog->shen V864)))

(defun shen.prolog->shen (V865) (map (lambda V820 (shen.compile_prolog_procedure V820)) (shen.group_clauses (map (lambda V819 (shen.s-prolog_clause V819)) (mapcan (lambda V818 (shen.head_abstraction V818)) V865)))))

(defun shen.s-prolog_clause (V866) (cond ((and (cons? V866) (and (cons? (tl V866)) (and (= :- (hd (tl V866))) (and (cons? (tl (tl V866))) (= () (tl (tl (tl V866)))))))) (cons (hd V866) (cons :- (cons (map (lambda V821 (shen.s-prolog_literal V821)) (hd (tl (tl V866)))) ())))) (true (shen.f_error shen.s-prolog_clause))))

(defun shen.head_abstraction (V867) (cond ((and (cons? V867) (and (cons? (tl V867)) (and (= :- (hd (tl V867))) (and (cons? (tl (tl V867))) (and (= () (tl (tl (tl V867)))) (< (shen.complexity_head (hd V867)) (value shen.*maxcomplexity*))))))) (cons V867 ())) ((and (cons? V867) (and (cons? (hd V867)) (and (cons? (tl V867)) (and (= :- (hd (tl V867))) (and (cons? (tl (tl V867))) (= () (tl (tl (tl V867))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V867))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V867)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V867)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V867)))) ()))) (cons Clause ())))))) (true (shen.f_error shen.head_abstraction))))

(defun shen.complexity_head (V872) (cond ((cons? V872) (shen.product (map (lambda V822 (shen.complexity V822)) (tl V872)))) (true (shen.f_error shen.complexity_head))))

(defun shen.complexity (V880) (cond ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (hd (tl V880))) (and (= mode (hd (hd (tl V880)))) (and (cons? (tl (hd (tl V880)))) (and (cons? (tl (tl (hd (tl V880))))) (and (= () (tl (tl (tl (hd (tl V880)))))) (and (cons? (tl (tl V880))) (= () (tl (tl (tl V880))))))))))))) (shen.complexity (hd (tl V880)))) ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (hd (tl V880))) (and (cons? (tl (tl V880))) (and (= + (hd (tl (tl V880)))) (= () (tl (tl (tl V880)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V880))) (tl (tl V880))))) (shen.complexity (cons mode (cons (tl (hd (tl V880))) (tl (tl V880)))))))) ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (hd (tl V880))) (and (cons? (tl (tl V880))) (and (= - (hd (tl (tl V880)))) (= () (tl (tl (tl V880)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V880))) (tl (tl V880))))) (shen.complexity (cons mode (cons (tl (hd (tl V880))) (tl (tl V880))))))) ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (and (= () (tl (tl (tl V880)))) (variable? (hd (tl V880)))))))) 1) ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (and (= + (hd (tl (tl V880)))) (= () (tl (tl (tl V880))))))))) 2) ((and (cons? V880) (and (= mode (hd V880)) (and (cons? (tl V880)) (and (cons? (tl (tl V880))) (and (= - (hd (tl (tl V880)))) (= () (tl (tl (tl V880))))))))) 1) (true (shen.complexity (cons mode (cons V880 (cons + ())))))))

(defun shen.product (V881) (cond ((= () V881) 1) ((cons? V881) (* (hd V881) (shen.product (tl V881)))) (true (shen.f_error shen.product))))

(defun shen.s-prolog_literal (V882) (cond ((and (cons? V882) (and (= is (hd V882)) (and (cons? (tl V882)) (and (cons? (tl (tl V882))) (= () (tl (tl (tl V882)))))))) (cons bind (cons (hd (tl V882)) (cons (shen.insert_deref (hd (tl (tl V882)))) ())))) ((and (cons? V882) (and (= when (hd V882)) (and (cons? (tl V882)) (= () (tl (tl V882)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V882))) ()))) ((and (cons? V882) (and (= bind (hd V882)) (and (cons? (tl V882)) (and (cons? (tl (tl V882))) (= () (tl (tl (tl V882)))))))) (cons bind (cons (hd (tl V882)) (cons (shen.insert_lazyderef (hd (tl (tl V882)))) ())))) ((and (cons? V882) (and (= fwhen (hd V882)) (and (cons? (tl V882)) (= () (tl (tl V882)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V882))) ()))) ((cons? V882) V882) (true (shen.f_error shen.s-prolog_literal))))

(defun shen.insert_deref (V883) (cond ((variable? V883) (cons shen.deref (cons V883 (cons ProcessN ())))) ((cons? V883) (cons (shen.insert_deref (hd V883)) (shen.insert_deref (tl V883)))) (true V883)))

(defun shen.insert_lazyderef (V884) (cond ((variable? V884) (cons shen.lazyderef (cons V884 (cons ProcessN ())))) ((cons? V884) (cons (shen.insert_lazyderef (hd V884)) (shen.insert_lazyderef (tl V884)))) (true V884)))

(defun shen.m_prolog_to_s-prolog_predicate (V885) (cond ((= = V885) unify) ((= =! V885) unify!) ((= == V885) identical) (true V885)))

(defun shen.group_clauses (V886) (cond ((= () V886) ()) ((cons? V886) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V886) X)) V886) (let Rest (difference V886 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.f_error shen.group_clauses))))

(defun shen.collect (V889 V890) (cond ((= () V890) ()) ((cons? V890) (if (V889 (hd V890)) (cons (hd V890) (shen.collect V889 (tl V890))) (shen.collect V889 (tl V890)))) (true (shen.f_error shen.collect))))

(defun shen.same_predicate? (V907 V908) (cond ((and (cons? V907) (and (cons? (hd V907)) (and (cons? V908) (cons? (hd V908))))) (= (hd (hd V907)) (hd (hd V908)))) (true (shen.f_error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V909) (let F (shen.procedure_name V909) (let Shen (shen.clauses-to-shen F V909) Shen)))

(defun shen.procedure_name (V922) (cond ((and (cons? V922) (and (cons? (hd V922)) (cons? (hd (hd V922))))) (hd (hd (hd V922)))) (true (shen.f_error shen.procedure_name))))

(defun shen.clauses-to-shen (V923 V924) (let Linear (map (lambda V823 (shen.linearise-clause V823)) V924) (let Arity (shen.prolog-aritycheck V923 (map (lambda V824 (head V824)) V924)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map (lambda V825 (shen.aum_to_shen V825)) AUM_instructions))) (let ShenDef (cons define (cons V923 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V925) (cond ((not (shen.occurs? cut V925)) V925) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V925 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V931 V932) (cond ((= V932 V931) false) (true V932)))

(defun shen.nest-disjunct (V933) (cond ((and (cons? V933) (= () (tl V933))) (hd V933)) ((cons? V933) (shen.lisp-or (hd V933) (shen.nest-disjunct (tl V933)))) (true (shen.f_error shen.nest-disjunct))))

(defun shen.lisp-or (V934 V935) (cons let (cons Case (cons V934 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V935 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V938 V939) (cond ((and (cons? V939) (= () (tl V939))) (- (length (hd V939)) 1)) ((and (cons? V939) (cons? (tl V939))) (if (= (length (hd V939)) (length (hd (tl V939)))) (shen.prolog-aritycheck V938 (tl V939)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V938 ()) "
" shen.a))))) (true (shen.f_error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V940) (cond ((and (cons? V940) (and (cons? (tl V940)) (and (= :- (hd (tl V940))) (and (cons? (tl (tl V940))) (= () (tl (tl (tl V940)))))))) (let Linear (shen.linearise (cons (hd V940) (tl (tl V940)))) (shen.clause_form Linear))) (true (shen.f_error shen.linearise-clause))))

(defun shen.clause_form (V941) (cond ((and (cons? V941) (and (cons? (tl V941)) (= () (tl (tl V941))))) (cons (shen.explicit_modes (hd V941)) (cons :- (cons (shen.cf_help (hd (tl V941))) ())))) (true (shen.f_error shen.clause_form))))

(defun shen.explicit_modes (V942) (cond ((cons? V942) (cons (hd V942) (map (lambda V826 (shen.em_help V826)) (tl V942)))) (true (shen.f_error shen.explicit_modes))))

(defun shen.em_help (V943) (cond ((and (cons? V943) (and (= mode (hd V943)) (and (cons? (tl V943)) (and (cons? (tl (tl V943))) (= () (tl (tl (tl V943)))))))) V943) (true (cons mode (cons V943 (cons + ()))))))

(defun shen.cf_help (V944) (cond ((and (cons? V944) (and (= where (hd V944)) (and (cons? (tl V944)) (and (cons? (hd (tl V944))) (and (= = (hd (hd (tl V944)))) (and (cons? (tl (hd (tl V944)))) (and (cons? (tl (tl (hd (tl V944))))) (and (= () (tl (tl (tl (hd (tl V944)))))) (and (cons? (tl (tl V944))) (= () (tl (tl (tl V944))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V944)))) (shen.cf_help (hd (tl (tl V944)))))) (true V944)))

(defun occurs-check (V949) (cond ((= + V949) (set shen.*occurs* true)) ((= - V949) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V950 V951) (cond ((and (cons? V950) (and (cons? (hd V950)) (and (cons? (tl V950)) (and (= :- (hd (tl V950))) (and (cons? (tl (tl V950))) (= () (tl (tl (tl V950))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V950)) (cons (shen.continuation_call (tl (hd V950)) (hd (tl (tl V950)))) ()))) V951) (shen.mu_reduction MuApplication +))) (true (shen.f_error shen.aum))))

(defun shen.continuation_call (V952 V953) (let VTerms (cons ProcessN (shen.extract_vars V952)) (let VBody (shen.extract_vars V953) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V953)))))

(defun remove (V954 V955) (shen.remove-h V954 V955 ()))

(defun shen.remove-h (V959 V960 V961) (cond ((= () V960) (reverse V961)) ((and (cons? V960) (= (hd V960) V959)) (shen.remove-h (hd V960) (tl V960) V961)) ((cons? V960) (shen.remove-h V959 (tl V960) (cons (hd V960) V961))) (true (shen.f_error shen.remove-h))))

(defun shen.cc_help (V962 V963) (cond ((and (= () V962) (= () V963)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V963) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V962 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V962) (cons call (cons shen.the (cons shen.continuation (cons V963 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V962 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V963 ())))) ())))))))))))

(defun shen.make_mu_application (V964 V965) (cond ((and (cons? V964) (and (= shen.mu (hd V964)) (and (cons? (tl V964)) (and (= () (hd (tl V964))) (and (cons? (tl (tl V964))) (and (= () (tl (tl (tl V964)))) (= () V965))))))) (hd (tl (tl V964)))) ((and (cons? V964) (and (= shen.mu (hd V964)) (and (cons? (tl V964)) (and (cons? (hd (tl V964))) (and (cons? (tl (tl V964))) (and (= () (tl (tl (tl V964)))) (cons? V965))))))) (cons (cons shen.mu (cons (hd (hd (tl V964))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V964))) (tl (tl V964)))) (tl V965)) ()))) (cons (hd V965) ()))) (true (shen.f_error shen.make_mu_application))))

(defun shen.mu_reduction (V972 V973) (cond ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (hd (tl (hd V972)))) (and (= mode (hd (hd (tl (hd V972))))) (and (cons? (tl (hd (tl (hd V972))))) (and (cons? (tl (tl (hd (tl (hd V972)))))) (and (= () (tl (tl (tl (hd (tl (hd V972))))))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (= () (tl (tl V972))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V972))))) (tl (tl (hd V972))))) (tl V972)) (hd (tl (tl (hd (tl (hd V972)))))))) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (= _ (hd (tl (hd V972)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V972)))) V973)) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (shen.ephemeral_variable? (hd (tl (hd V972))) (hd (tl V972))))))))))) (subst (hd (tl V972)) (hd (tl (hd V972))) (shen.mu_reduction (hd (tl (tl (hd V972)))) V973))) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (variable? (hd (tl (hd V972)))))))))))) (cons let (cons (hd (tl (hd V972))) (cons shen.be (cons (hd (tl V972)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V972)))) V973) ()))))))) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (and (= - V973) (shen.prolog_constant? (hd (tl (hd V972))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V972))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V972))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V972)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (and (= + V973) (shen.prolog_constant? (hd (tl (hd V972))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V972))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V972))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V972)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V972))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V972)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (hd (tl (hd V972)))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (= - V973)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V972))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V972)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V972)))) (tl (tl (hd V972))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V972) (and (cons? (hd V972)) (and (= shen.mu (hd (hd V972))) (and (cons? (tl (hd V972))) (and (cons? (hd (tl (hd V972)))) (and (cons? (tl (tl (hd V972)))) (and (= () (tl (tl (tl (hd V972))))) (and (cons? (tl V972)) (and (= () (tl (tl V972))) (= + V973)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V972))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V972)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V972)))) (tl (tl (hd V972))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V972)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V972))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V972)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V972)))

(defun shen.rcons_form (V974) (cond ((cons? V974) (cons cons (cons (shen.rcons_form (hd V974)) (cons (shen.rcons_form (tl V974)) ())))) (true V974)))

(defun shen.remove_modes (V975) (cond ((and (cons? V975) (and (= mode (hd V975)) (and (cons? (tl V975)) (and (cons? (tl (tl V975))) (and (= + (hd (tl (tl V975)))) (= () (tl (tl (tl V975))))))))) (shen.remove_modes (hd (tl V975)))) ((and (cons? V975) (and (= mode (hd V975)) (and (cons? (tl V975)) (and (cons? (tl (tl V975))) (and (= - (hd (tl (tl V975)))) (= () (tl (tl (tl V975))))))))) (shen.remove_modes (hd (tl V975)))) ((cons? V975) (cons (shen.remove_modes (hd V975)) (shen.remove_modes (tl V975)))) (true V975)))

(defun shen.ephemeral_variable? (V976 V977) (and (variable? V976) (variable? V977)))

(defun shen.prolog_constant? (V986) (cond ((cons? V986) false) (true true)))

(defun shen.aum_to_shen (V987) (cond ((and (cons? V987) (and (= let (hd V987)) (and (cons? (tl V987)) (and (cons? (tl (tl V987))) (and (= shen.be (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (cons? (tl (tl (tl (tl V987))))) (and (= in (hd (tl (tl (tl (tl V987)))))) (and (cons? (tl (tl (tl (tl (tl V987)))))) (= () (tl (tl (tl (tl (tl (tl V987)))))))))))))))) (cons let (cons (hd (tl V987)) (cons (shen.aum_to_shen (hd (tl (tl (tl V987))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V987))))))) ()))))) ((and (cons? V987) (and (= shen.the (hd V987)) (and (cons? (tl V987)) (and (= shen.result (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.of (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (= shen.dereferencing (hd (tl (tl (tl V987))))) (and (cons? (tl (tl (tl (tl V987))))) (= () (tl (tl (tl (tl (tl V987))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V987)))))) (cons ProcessN ())))) ((and (cons? V987) (and (= if (hd V987)) (and (cons? (tl V987)) (and (cons? (tl (tl V987))) (and (= shen.then (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (cons? (tl (tl (tl (tl V987))))) (and (= shen.else (hd (tl (tl (tl (tl V987)))))) (and (cons? (tl (tl (tl (tl (tl V987)))))) (= () (tl (tl (tl (tl (tl (tl V987)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V987))) (cons (shen.aum_to_shen (hd (tl (tl (tl V987))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V987))))))) ()))))) ((and (cons? V987) (and (cons? (tl V987)) (and (= is (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.a (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (= shen.variable (hd (tl (tl (tl V987))))) (= () (tl (tl (tl (tl V987)))))))))))) (cons shen.pvar? (cons (hd V987) ()))) ((and (cons? V987) (and (cons? (tl V987)) (and (= is (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.a (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (= shen.non-empty (hd (tl (tl (tl V987))))) (and (cons? (tl (tl (tl (tl V987))))) (and (= list (hd (tl (tl (tl (tl V987)))))) (= () (tl (tl (tl (tl (tl V987))))))))))))))) (cons cons? (cons (hd V987) ()))) ((and (cons? V987) (and (= shen.rename (hd V987)) (and (cons? (tl V987)) (and (= shen.the (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.variables (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (= in (hd (tl (tl (tl V987))))) (and (cons? (tl (tl (tl (tl V987))))) (and (= () (hd (tl (tl (tl (tl V987)))))) (and (cons? (tl (tl (tl (tl (tl V987)))))) (and (= and (hd (tl (tl (tl (tl (tl V987))))))) (and (cons? (tl (tl (tl (tl (tl (tl V987))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V987)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V987)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V987)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V987)))))))))) ((and (cons? V987) (and (= shen.rename (hd V987)) (and (cons? (tl V987)) (and (= shen.the (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.variables (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (= in (hd (tl (tl (tl V987))))) (and (cons? (tl (tl (tl (tl V987))))) (and (cons? (hd (tl (tl (tl (tl V987)))))) (and (cons? (tl (tl (tl (tl (tl V987)))))) (and (= and (hd (tl (tl (tl (tl (tl V987))))))) (and (cons? (tl (tl (tl (tl (tl (tl V987))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V987)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V987)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V987)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V987)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V987)))))) (tl (tl (tl (tl (tl V987))))))))))) ()))))) ((and (cons? V987) (and (= bind (hd V987)) (and (cons? (tl V987)) (and (cons? (tl (tl V987))) (and (= shen.to (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (cons? (tl (tl (tl (tl V987))))) (and (= in (hd (tl (tl (tl (tl V987)))))) (and (cons? (tl (tl (tl (tl (tl V987)))))) (= () (tl (tl (tl (tl (tl (tl V987)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V987)) (cons (shen.chwild (hd (tl (tl (tl V987))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V987))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V987)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V987) (and (cons? (tl V987)) (and (= is (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= identical (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (and (= shen.to (hd (tl (tl (tl V987))))) (and (cons? (tl (tl (tl (tl V987))))) (= () (tl (tl (tl (tl (tl V987)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V987))))) (cons (hd V987) ())))) ((= shen.failed! V987) false) ((and (cons? V987) (and (= shen.the (hd V987)) (and (cons? (tl V987)) (and (= head (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.of (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (= () (tl (tl (tl (tl V987)))))))))))) (cons hd (tl (tl (tl V987))))) ((and (cons? V987) (and (= shen.the (hd V987)) (and (cons? (tl V987)) (and (= tail (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.of (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (= () (tl (tl (tl (tl V987)))))))))))) (cons tl (tl (tl (tl V987))))) ((and (cons? V987) (and (= shen.pop (hd V987)) (and (cons? (tl V987)) (and (= shen.the (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.stack (hd (tl (tl V987)))) (= () (tl (tl (tl V987)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V987) (and (= call (hd V987)) (and (cons? (tl V987)) (and (= shen.the (hd (tl V987))) (and (cons? (tl (tl V987))) (and (= shen.continuation (hd (tl (tl V987)))) (and (cons? (tl (tl (tl V987)))) (= () (tl (tl (tl (tl V987)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V987))))) ProcessN Continuation) ())))) (true V987)))

(defun shen.chwild (V988) (cond ((= V988 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V988) (map (lambda V827 (shen.chwild V827)) V988)) (true V988)))

(defun shen.newpv (V989) (let Count+1 (+ (<-address (value shen.*varcounter*) V989) 1) (let IncVar (address-> (value shen.*varcounter*) V989 Count+1) (let Vector (<-address (value shen.*prologvectors*) V989) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V989 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V990 V991) (let Vector (<-address (value shen.*prologvectors*) V990) (let BigVector (shen.resize-vector Vector (+ V991 V991) shen.-null-) (address-> (value shen.*prologvectors*) V990 BigVector))))

(defun shen.resize-vector (V992 V993 V994) (let BigVector (address-> (absvector (+ 1 V993)) 0 V993) (shen.copy-vector V992 BigVector (limit V992) V993 V994)))

(defun shen.copy-vector (V995 V996 V997 V998 V999) (shen.copy-vector-stage-2 (+ 1 V997) (+ V998 1) V999 (shen.copy-vector-stage-1 1 V995 V996 (+ 1 V997))))

(defun shen.copy-vector-stage-1 (V1003 V1004 V1005 V1006) (cond ((= V1006 V1003) V1005) (true (shen.copy-vector-stage-1 (+ 1 V1003) V1004 (address-> V1005 V1003 (<-address V1004 V1003)) V1006))))

(defun shen.copy-vector-stage-2 (V1010 V1011 V1012 V1013) (cond ((= V1011 V1010) V1013) (true (shen.copy-vector-stage-2 (+ V1010 1) V1011 V1012 (address-> V1013 V1010 V1012)))))

(defun shen.mk-pvar (V1014) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1014))

(defun shen.pvar? (V1015) (trap-error (and (absvector? V1015) (= (<-address V1015 0) shen.pvar)) (lambda E false)))

(defun shen.bindv (V1016 V1017 V1018) (let Vector (<-address (value shen.*prologvectors*) V1018) (address-> Vector (<-address V1016 1) V1017)))

(defun shen.unbindv (V1019 V1020) (let Vector (<-address (value shen.*prologvectors*) V1020) (address-> Vector (<-address V1019 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1021 V1022 V1023) (cond ((and (cons? V1021) (and (cons? (hd V1021)) (= () (tl V1021)))) (cons (hd (hd V1021)) (append (tl (hd V1021)) (cons V1022 (cons V1023 ()))))) ((and (cons? V1021) (cons? (hd V1021))) (let NewContinuation (shen.newcontinuation (tl V1021) V1022 V1023) (cons (hd (hd V1021)) (append (tl (hd V1021)) (cons V1022 (cons NewContinuation ())))))) (true (shen.f_error shen.call_the_continuation))))

(defun shen.newcontinuation (V1024 V1025 V1026) (cond ((= () V1024) V1026) ((and (cons? V1024) (cons? (hd V1024))) (cons freeze (cons (cons (hd (hd V1024)) (append (tl (hd V1024)) (cons V1025 (cons (shen.newcontinuation (tl V1024) V1025 V1026) ())))) ()))) (true (shen.f_error shen.newcontinuation))))

(defun return (V1031 V1032 V1033) (shen.deref V1031 V1032))

(defun shen.measure&return (V1038 V1039 V1040) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1038 V1039)))

(defun unify (V1041 V1042 V1043 V1044) (shen.lzy= (shen.lazyderef V1041 V1043) (shen.lazyderef V1042 V1043) V1043 V1044))

(defun shen.lzy= (V1062 V1063 V1064 V1065) (cond ((= V1063 V1062) (thaw V1065)) ((shen.pvar? V1062) (bind V1062 V1063 V1064 V1065)) ((shen.pvar? V1063) (bind V1063 V1062 V1064 V1065)) ((and (cons? V1062) (cons? V1063)) (shen.lzy= (shen.lazyderef (hd V1062) V1064) (shen.lazyderef (hd V1063) V1064) V1064 (freeze (shen.lzy= (shen.lazyderef (tl V1062) V1064) (shen.lazyderef (tl V1063) V1064) V1064 V1065)))) (true false)))

(defun shen.deref (V1066 V1067) (cond ((cons? V1066) (cons (shen.deref (hd V1066) V1067) (shen.deref (tl V1066) V1067))) (true (if (shen.pvar? V1066) (let Value (shen.valvector V1066 V1067) (if (= Value shen.-null-) V1066 (shen.deref Value V1067))) V1066))))

(defun shen.lazyderef (V1068 V1069) (if (shen.pvar? V1068) (let Value (shen.valvector V1068 V1069) (if (= Value shen.-null-) V1068 (shen.lazyderef Value V1069))) V1068))

(defun shen.valvector (V1070 V1071) (<-address (<-address (value shen.*prologvectors*) V1071) (<-address V1070 1)))

(defun unify! (V1072 V1073 V1074 V1075) (shen.lzy=! (shen.lazyderef V1072 V1074) (shen.lazyderef V1073 V1074) V1074 V1075))

(defun shen.lzy=! (V1093 V1094 V1095 V1096) (cond ((= V1094 V1093) (thaw V1096)) ((and (shen.pvar? V1093) (not (shen.occurs? V1093 (shen.deref V1094 V1095)))) (bind V1093 V1094 V1095 V1096)) ((and (shen.pvar? V1094) (not (shen.occurs? V1094 (shen.deref V1093 V1095)))) (bind V1094 V1093 V1095 V1096)) ((and (cons? V1093) (cons? V1094)) (shen.lzy=! (shen.lazyderef (hd V1093) V1095) (shen.lazyderef (hd V1094) V1095) V1095 (freeze (shen.lzy=! (shen.lazyderef (tl V1093) V1095) (shen.lazyderef (tl V1094) V1095) V1095 V1096)))) (true false)))

(defun shen.occurs? (V1106 V1107) (cond ((= V1107 V1106) true) ((cons? V1107) (or (shen.occurs? V1106 (hd V1107)) (shen.occurs? V1106 (tl V1107)))) (true false)))

(defun identical (V1108 V1109 V1110 V1111) (shen.lzy== (shen.lazyderef V1108 V1110) (shen.lazyderef V1109 V1110) V1110 V1111))

(defun shen.lzy== (V1129 V1130 V1131 V1132) (cond ((= V1130 V1129) (thaw V1132)) ((and (cons? V1129) (cons? V1130)) (shen.lzy== (shen.lazyderef (hd V1129) V1131) (shen.lazyderef (hd V1130) V1131) V1131 (freeze (shen.lzy== (tl V1129) (tl V1130) V1131 V1132)))) (true false)))

(defun shen.pvar (V1133) (cn "Var" (shen.app (<-address V1133 1) "" shen.a)))

(defun bind (V1134 V1135 V1136 V1137) (do (shen.bindv V1134 V1135 V1136) (let Result (thaw V1137) (do (shen.unbindv V1134 V1136) Result))))

(defun fwhen (V1152 V1153 V1154) (cond ((= true V1152) (thaw V1154)) ((= false V1152) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1152 "%" shen.s))))))

(defun call (V1167 V1168 V1169) (cond ((cons? V1167) (shen.call-help (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1167) V1168)) (tl V1167) V1168 V1169)) (true false)))

(defun shen.call-help (V1170 V1171 V1172 V1173) (cond ((= () V1171) (V1170 V1172 V1173)) ((cons? V1171) (shen.call-help (V1170 (hd V1171)) (tl V1171) V1172 V1173)) (true (shen.f_error shen.call-help))))

(defun shen.intprolog (V1174) (cond ((and (cons? V1174) (cons? (hd V1174))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1174)) (shen.insert-prolog-variables (cons (tl (hd V1174)) (cons (tl V1174) ())) ProcessN) ProcessN))) (true (shen.f_error shen.intprolog))))

(defun shen.intprolog-help (V1175 V1176 V1177) (cond ((and (cons? V1176) (and (cons? (tl V1176)) (= () (tl (tl V1176))))) (shen.intprolog-help-help V1175 (hd V1176) (hd (tl V1176)) V1177)) (true (shen.f_error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1178 V1179 V1180 V1181) (cond ((= () V1179) (V1178 V1181 (freeze (shen.call-rest V1180 V1181)))) ((cons? V1179) (shen.intprolog-help-help (V1178 (hd V1179)) (tl V1179) V1180 V1181)) (true (shen.f_error shen.intprolog-help-help))))

(defun shen.call-rest (V1184 V1185) (cond ((= () V1184) true) ((and (cons? V1184) (and (cons? (hd V1184)) (cons? (tl (hd V1184))))) (shen.call-rest (cons (cons ((hd (hd V1184)) (hd (tl (hd V1184)))) (tl (tl (hd V1184)))) (tl V1184)) V1185)) ((and (cons? V1184) (and (cons? (hd V1184)) (= () (tl (hd V1184))))) ((hd (hd V1184)) V1185 (freeze (shen.call-rest (tl V1184) V1185)))) (true (shen.f_error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1186 V1187) (shen.insert-prolog-variables-help V1186 (shen.flatten V1186) V1187))

(defun shen.insert-prolog-variables-help (V1192 V1193 V1194) (cond ((= () V1193) V1192) ((and (cons? V1193) (variable? (hd V1193))) (let V (shen.newpv V1194) (let XV/Y (subst V (hd V1193) V1192) (let Z-Y (remove (hd V1193) (tl V1193)) (shen.insert-prolog-variables-help XV/Y Z-Y V1194))))) ((cons? V1193) (shen.insert-prolog-variables-help V1192 (tl V1193) V1194)) (true (shen.f_error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1195) (let Vector (address-> (value shen.*prologvectors*) V1195 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1195 1) V1195)))



