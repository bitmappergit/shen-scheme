"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-file-as-bytelist (V1207) (let Stream (open V1207 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V1208 V1209 V1210) (cond ((= -1 V1209) V1210) (true (shen.read-file-as-bytelist-help V1208 (read-byte V1208) (cons V1209 V1210)))))

(defun read-file-as-string (V1211) (let Stream (open V1211 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V1212 V1213 V1214) (cond ((= -1 V1213) (do (close V1212) V1214)) (true (shen.rfas-h V1212 (read-byte V1212) (cn V1214 (n->string V1213))))))

(defun input (V1215) (eval-kl (read V1215)))

(defun input+ (V1216 V1217) (let Mono? (shen.monotype V1216) (let Input (read V1217) (if (= false (shen.typecheck Input (shen.demodulate V1216))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V1216 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V1218) (cond ((cons? V1218) (map (lambda V1196 (shen.monotype V1196)) V1218)) (true (if (variable? V1218) (simple-error (cn "input+ expects a monotype: not " (shen.app V1218 "
" shen.a))) V1218))))

(defun read (V1219) (hd (shen.read-loop V1219 (read-byte V1219) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V1224 V1225 V1226) (cond ((= 94 V1225) (simple-error "read aborted")) ((= -1 V1225) (if (empty? V1226) (simple-error "error: empty stream") (compile (lambda V1197 (shen.<st_input> V1197)) V1226 (lambda E E)))) ((shen.terminator? V1225) (let AllBytes (append V1226 (cons V1225 ())) (let It (shen.record-it AllBytes) (let Read (compile (lambda V1198 (shen.<st_input> V1198)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V1224 (read-byte V1224) AllBytes) Read))))) (true (shen.read-loop V1224 (read-byte V1224) (append V1226 (cons V1225 ()))))))

(defun shen.terminator? (V1227) (element? V1227 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V1228) (shen.lineread-loop (read-byte V1228) () V1228))

(defun shen.lineread-loop (V1230 V1231 V1232) (cond ((= -1 V1230) (if (empty? V1231) (simple-error "empty stream") (compile (lambda V1199 (shen.<st_input> V1199)) V1231 (lambda E E)))) ((= V1230 (shen.hat)) (simple-error "line read aborted")) ((element? V1230 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda V1200 (shen.<st_input> V1200)) V1231 (lambda E shen.nextline)) (let It (shen.record-it V1231) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V1232) (append V1231 (cons V1230 ())) V1232) Line)))) (true (shen.lineread-loop (read-byte V1232) (append V1231 (cons V1230 ())) V1232))))

(defun shen.record-it (V1233) (let TrimLeft (shen.trim-whitespace V1233) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V1234) (cond ((and (cons? V1234) (element? (hd V1234) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V1234))) (true V1234)))

(defun shen.record-it-h (V1235) (do (set shen.*it* (shen.cn-all (map (lambda V1201 (n->string V1201)) V1235))) V1235))

(defun shen.cn-all (V1236) (cond ((= () V1236) "") ((cons? V1236) (cn (hd V1236) (shen.cn-all (tl V1236)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V1237) (let Bytelist (read-file-as-bytelist V1237) (compile (lambda V1203 (shen.<st_input> V1203)) Bytelist (lambda V1202 (shen.read-error V1202)))))

(defun read-from-string (V1238) (let Ns (map (lambda V1204 (string->n V1204)) (explode V1238)) (compile (lambda V1206 (shen.<st_input> V1206)) Ns (lambda V1205 (shen.read-error V1205)))))

(defun shen.read-error (V1245) (cond ((and (cons? V1245) (and (cons? (hd V1245)) (and (cons? (tl V1245)) (= () (tl (tl V1245)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V1245)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V1250 V1251) (cond ((= () V1251) "") ((= 0 V1250) "") ((cons? V1251) (cn (n->string (hd V1251)) (shen.compress-50 (- V1250 1) (tl V1251)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V1252) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V1252) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V1252) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V1252) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V1252) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V1252) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V1252) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V1252) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V1252) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V1252) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V1252) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V1252) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V1252) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V1252) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1252) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V1253) (if (and (cons? (hd V1253)) (= 91 (hd (hd V1253)))) (shen.pair (hd (shen.pair (tl (hd V1253)) (shen.hdtl V1253))) shen.skip) (fail)))

(defun shen.<rsb> (V1254) (if (and (cons? (hd V1254)) (= 93 (hd (hd V1254)))) (shen.pair (hd (shen.pair (tl (hd V1254)) (shen.hdtl V1254))) shen.skip) (fail)))

(defun shen.<lcurly> (V1255) (if (and (cons? (hd V1255)) (= 123 (hd (hd V1255)))) (shen.pair (hd (shen.pair (tl (hd V1255)) (shen.hdtl V1255))) shen.skip) (fail)))

(defun shen.<rcurly> (V1256) (if (and (cons? (hd V1256)) (= 125 (hd (hd V1256)))) (shen.pair (hd (shen.pair (tl (hd V1256)) (shen.hdtl V1256))) shen.skip) (fail)))

(defun shen.<bar> (V1257) (if (and (cons? (hd V1257)) (= 124 (hd (hd V1257)))) (shen.pair (hd (shen.pair (tl (hd V1257)) (shen.hdtl V1257))) shen.skip) (fail)))

(defun shen.<semicolon> (V1258) (if (and (cons? (hd V1258)) (= 59 (hd (hd V1258)))) (shen.pair (hd (shen.pair (tl (hd V1258)) (shen.hdtl V1258))) shen.skip) (fail)))

(defun shen.<colon> (V1259) (if (and (cons? (hd V1259)) (= 58 (hd (hd V1259)))) (shen.pair (hd (shen.pair (tl (hd V1259)) (shen.hdtl V1259))) shen.skip) (fail)))

(defun shen.<comma> (V1260) (if (and (cons? (hd V1260)) (= 44 (hd (hd V1260)))) (shen.pair (hd (shen.pair (tl (hd V1260)) (shen.hdtl V1260))) shen.skip) (fail)))

(defun shen.<equal> (V1261) (if (and (cons? (hd V1261)) (= 61 (hd (hd V1261)))) (shen.pair (hd (shen.pair (tl (hd V1261)) (shen.hdtl V1261))) shen.skip) (fail)))

(defun shen.<minus> (V1262) (if (and (cons? (hd V1262)) (= 45 (hd (hd V1262)))) (shen.pair (hd (shen.pair (tl (hd V1262)) (shen.hdtl V1262))) shen.skip) (fail)))

(defun shen.<lrb> (V1263) (if (and (cons? (hd V1263)) (= 40 (hd (hd V1263)))) (shen.pair (hd (shen.pair (tl (hd V1263)) (shen.hdtl V1263))) shen.skip) (fail)))

(defun shen.<rrb> (V1264) (if (and (cons? (hd V1264)) (= 41 (hd (hd V1264)))) (shen.pair (hd (shen.pair (tl (hd V1264)) (shen.hdtl V1264))) shen.skip) (fail)))

(defun shen.<atom> (V1265) (let YaccParse (let Parse_shen.<str> (shen.<str> V1265) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V1265) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V1265) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V1266) (cond ((= () V1266) "") ((and (cons? V1266) (and (= "c" (hd V1266)) (and (cons? (tl V1266)) (= "#" (hd (tl V1266)))))) (let CodePoint (shen.code-point (tl (tl V1266))) (let AfterCodePoint (shen.after-codepoint (tl (tl V1266))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V1266) (@s (hd V1266) (shen.control-chars (tl V1266)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V1269) (cond ((and (cons? V1269) (= ";" (hd V1269))) "") ((and (cons? V1269) (element? (hd V1269) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V1269) (shen.code-point (tl V1269)))) (true (simple-error (cn "code point parse error " (shen.app V1269 "
" shen.a))))))

(defun shen.after-codepoint (V1274) (cond ((= () V1274) ()) ((and (cons? V1274) (= ";" (hd V1274))) (tl V1274)) ((cons? V1274) (shen.after-codepoint (tl V1274))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V1275) (shen.pre (reverse (shen.digits->integers V1275)) 0))

(defun shen.digits->integers (V1280) (cond ((and (cons? V1280) (= "0" (hd V1280))) (cons 0 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "1" (hd V1280))) (cons 1 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "2" (hd V1280))) (cons 2 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "3" (hd V1280))) (cons 3 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "4" (hd V1280))) (cons 4 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "5" (hd V1280))) (cons 5 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "6" (hd V1280))) (cons 6 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "7" (hd V1280))) (cons 7 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "8" (hd V1280))) (cons 8 (shen.digits->integers (tl V1280)))) ((and (cons? V1280) (= "9" (hd V1280))) (cons 9 (shen.digits->integers (tl V1280)))) (true ())))

(defun shen.<sym> (V1281) (let Parse_shen.<alpha> (shen.<alpha> V1281) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V1282) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V1282) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1282) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V1283) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V1283) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V1283) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V1284) (if (cons? (hd V1284)) (let Parse_Byte (hd (hd V1284)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1284)) (shen.hdtl V1284))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.numbyte? (V1289) (cond ((= 48 V1289) true) ((= 49 V1289) true) ((= 50 V1289) true) ((= 51 V1289) true) ((= 52 V1289) true) ((= 53 V1289) true) ((= 54 V1289) true) ((= 55 V1289) true) ((= 56 V1289) true) ((= 57 V1289) true) (true false)))

(defun shen.<alpha> (V1290) (if (cons? (hd V1290)) (let Parse_Byte (hd (hd V1290)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1290)) (shen.hdtl V1290))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.symbol-code? (V1291) (or (= V1291 126) (or (and (> V1291 94) (< V1291 123)) (or (and (> V1291 59) (< V1291 91)) (or (and (> V1291 41) (and (< V1291 58) (not (= V1291 44)))) (or (and (> V1291 34) (< V1291 40)) (= V1291 33)))))))

(defun shen.<str> (V1292) (let Parse_shen.<dbq> (shen.<dbq> V1292) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V1293) (if (cons? (hd V1293)) (let Parse_Byte (hd (hd V1293)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V1293)) (shen.hdtl V1293))) Parse_Byte) (fail))) (fail)))

(defun shen.<strcontents> (V1294) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V1294) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1294) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V1295) (if (cons? (hd V1295)) (let Parse_Byte (hd (hd V1295)) (shen.pair (hd (shen.pair (tl (hd V1295)) (shen.hdtl V1295))) (n->string Parse_Byte))) (fail)))

(defun shen.<strc> (V1296) (if (cons? (hd V1296)) (let Parse_Byte (hd (hd V1296)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V1296)) (shen.hdtl V1296))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.<number> (V1297) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V1297) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V1297) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V1297) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V1297) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V1297) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V1297) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V1298) (if (and (cons? (hd V1298)) (= 101 (hd (hd V1298)))) (shen.pair (hd (shen.pair (tl (hd V1298)) (shen.hdtl V1298))) shen.skip) (fail)))

(defun shen.<log10> (V1299) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V1299) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V1299) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V1300) (if (cons? (hd V1300)) (let Parse_Byte (hd (hd V1300)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V1300)) (shen.hdtl V1300))) Parse_Byte) (fail))) (fail)))

(defun shen.<stop> (V1301) (if (cons? (hd V1301)) (let Parse_Byte (hd (hd V1301)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V1301)) (shen.hdtl V1301))) Parse_Byte) (fail))) (fail)))

(defun shen.<predigits> (V1302) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V1302) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1302) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V1303) (let Parse_shen.<digits> (shen.<digits> V1303) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V1304) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V1304) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V1304) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V1305) (if (cons? (hd V1305)) (let Parse_X (hd (hd V1305)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1305)) (shen.hdtl V1305))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V1306) (cond ((= 48 V1306) 0) ((= 49 V1306) 1) ((= 50 V1306) 2) ((= 51 V1306) 3) ((= 52 V1306) 4) ((= 53 V1306) 5) ((= 54 V1306) 6) ((= 55 V1306) 7) ((= 56 V1306) 8) ((= 57 V1306) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V1309 V1310) (cond ((= () V1309) 0) ((cons? V1309) (+ (* (shen.expt 10 V1310) (hd V1309)) (shen.pre (tl V1309) (+ V1310 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V1313 V1314) (cond ((= () V1313) 0) ((cons? V1313) (+ (* (shen.expt 10 (- 0 V1314)) (hd V1313)) (shen.post (tl V1313) (+ V1314 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V1317 V1318) (cond ((= 0 V1318) 1) ((> V1318 0) (* V1317 (shen.expt V1317 (- V1318 1)))) (true (* 1 (/ (shen.expt V1317 (+ V1318 1)) V1317)))))

(defun shen.<st_input1> (V1319) (let Parse_shen.<st_input> (shen.<st_input> V1319) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V1320) (let Parse_shen.<st_input> (shen.<st_input> V1320) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V1321) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V1321) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V1321) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V1322) (let Parse_shen.<backslash> (shen.<backslash> V1322) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V1323) (if (and (cons? (hd V1323)) (= 92 (hd (hd V1323)))) (shen.pair (hd (shen.pair (tl (hd V1323)) (shen.hdtl V1323))) shen.skip) (fail)))

(defun shen.<anysingle> (V1324) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V1324) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1324) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V1325) (if (cons? (hd V1325)) (let Parse_X (hd (hd V1325)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V1325)) (shen.hdtl V1325))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V1326) (if (cons? (hd V1326)) (let Parse_X (hd (hd V1326)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V1326)) (shen.hdtl V1326))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V1327) (let Parse_shen.<backslash> (shen.<backslash> V1327) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V1328) (if (and (cons? (hd V1328)) (= 42 (hd (hd V1328)))) (shen.pair (hd (shen.pair (tl (hd V1328)) (shen.hdtl V1328))) shen.skip) (fail)))

(defun shen.<anymulti> (V1329) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V1329) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V1329) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V1329)) (let Parse_X (hd (hd V1329)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V1329)) (shen.hdtl V1329))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V1330) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V1330) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V1330) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V1331) (if (cons? (hd V1331)) (let Parse_X (hd (hd V1331)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V1331)) (shen.hdtl V1331))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V1332) (cond ((= () V1332) ()) ((and (cons? V1332) (and (cons? (tl V1332)) (and (cons? (tl (tl V1332))) (and (= () (tl (tl (tl V1332)))) (= (hd (tl V1332)) bar!))))) (cons cons (cons (hd V1332) (tl (tl V1332))))) ((cons? V1332) (cons cons (cons (hd V1332) (cons (shen.cons_form (tl V1332)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V1335 V1336) (cond ((and (cons? V1335) (and (= $ (hd V1335)) (and (cons? (tl V1335)) (= () (tl (tl V1335)))))) (append (explode (hd (tl V1335))) V1336)) ((and (cons? V1335) (and (= package (hd V1335)) (and (cons? (tl V1335)) (and (= null (hd (tl V1335))) (cons? (tl (tl V1335))))))) (append (tl (tl (tl V1335))) V1336)) ((and (cons? V1335) (and (= package (hd V1335)) (and (cons? (tl V1335)) (cons? (tl (tl V1335)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V1335)))) (let Record (shen.record-exceptions ListofExceptions (hd (tl V1335))) (let PackageNameDot (intern (cn (str (hd (tl V1335))) ".")) (append (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V1335)))) V1336))))) (true (cons V1335 V1336))))

(defun shen.record-exceptions (V1337 V1338) (let CurrExceptions (trap-error (get V1338 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V1337 CurrExceptions) (put V1338 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.packageh (V1347 V1348 V1349) (cond ((cons? V1349) (cons (shen.packageh V1347 V1348 (hd V1349)) (shen.packageh V1347 V1348 (tl V1349)))) ((or (shen.sysfunc? V1349) (or (variable? V1349) (or (element? V1349 V1348) (or (shen.doubleunderline? V1349) (shen.singleunderline? V1349))))) V1349) ((and (symbol? V1349) (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) (explode V1349)))) (concat V1347 V1349)) (true V1349)))



