"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-file-as-bytelist (V1205) (let Stream (open V1205 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V1206 V1207 V1208) (cond ((= -1 V1207) V1208) (true (shen.read-file-as-bytelist-help V1206 (read-byte V1206) (cons V1207 V1208)))))

(defun read-file-as-string (V1209) (let Stream (open V1209 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V1210 V1211 V1212) (cond ((= -1 V1211) (do (close V1210) V1212)) (true (shen.rfas-h V1210 (read-byte V1210) (cn V1212 (n->string V1211))))))

(defun input (V1213) (eval-kl (read V1213)))

(defun input+ (V1214 V1215) (let Mono? (shen.monotype V1214) (let Input (read V1215) (if (= false (shen.typecheck Input (shen.demodulate V1214))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V1214 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V1216) (cond ((cons? V1216) (map (lambda V1194 (shen.monotype V1194)) V1216)) (true (if (variable? V1216) (simple-error (cn "input+ expects a monotype: not " (shen.app V1216 "
" shen.a))) V1216))))

(defun read (V1217) (hd (shen.read-loop V1217 (read-byte V1217) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V1222 V1223 V1224) (cond ((= 94 V1223) (simple-error "read aborted")) ((= -1 V1223) (if (empty? V1224) (simple-error "error: empty stream") (compile (lambda V1195 (shen.<st_input> V1195)) V1224 (lambda E E)))) ((shen.terminator? V1223) (let AllBytes (append V1224 (cons V1223 ())) (let It (shen.record-it AllBytes) (let Read (compile (lambda V1196 (shen.<st_input> V1196)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V1222 (read-byte V1222) AllBytes) Read))))) (true (shen.read-loop V1222 (read-byte V1222) (append V1224 (cons V1223 ()))))))

(defun shen.terminator? (V1225) (element? V1225 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V1226) (shen.lineread-loop (read-byte V1226) () V1226))

(defun shen.lineread-loop (V1228 V1229 V1230) (cond ((= -1 V1228) (if (empty? V1229) (simple-error "empty stream") (compile (lambda V1197 (shen.<st_input> V1197)) V1229 (lambda E E)))) ((= V1228 (shen.hat)) (simple-error "line read aborted")) ((element? V1228 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda V1198 (shen.<st_input> V1198)) V1229 (lambda E shen.nextline)) (let It (shen.record-it V1229) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V1230) (append V1229 (cons V1228 ())) V1230) Line)))) (true (shen.lineread-loop (read-byte V1230) (append V1229 (cons V1228 ())) V1230))))

(defun shen.record-it (V1231) (let TrimLeft (shen.trim-whitespace V1231) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V1232) (cond ((and (cons? V1232) (element? (hd V1232) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V1232))) (true V1232)))

(defun shen.record-it-h (V1233) (do (set shen.*it* (shen.cn-all (map (lambda V1199 (n->string V1199)) V1233))) V1233))

(defun shen.cn-all (V1234) (cond ((= () V1234) "") ((cons? V1234) (cn (hd V1234) (shen.cn-all (tl V1234)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V1235) (let Bytelist (read-file-as-bytelist V1235) (compile (lambda V1201 (shen.<st_input> V1201)) Bytelist (lambda V1200 (shen.read-error V1200)))))

(defun read-from-string (V1236) (let Ns (map (lambda V1202 (string->n V1202)) (explode V1236)) (compile (lambda V1204 (shen.<st_input> V1204)) Ns (lambda V1203 (shen.read-error V1203)))))

(defun shen.read-error (V1243) (cond ((and (cons? V1243) (and (cons? (hd V1243)) (and (cons? (tl V1243)) (= () (tl (tl V1243)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V1243)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V1248 V1249) (cond ((= () V1249) "") ((= 0 V1248) "") ((cons? V1249) (cn (n->string (hd V1249)) (shen.compress-50 (- V1248 1) (tl V1249)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V1250) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V1250) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V1250) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V1250) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V1250) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V1250) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V1250) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V1250) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V1250) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V1250) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V1250) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V1250) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V1250) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V1250) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1250) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V1251) (if (and (cons? (hd V1251)) (= 91 (hd (hd V1251)))) (shen.pair (hd (shen.pair (tl (hd V1251)) (shen.hdtl V1251))) shen.skip) (fail)))

(defun shen.<rsb> (V1252) (if (and (cons? (hd V1252)) (= 93 (hd (hd V1252)))) (shen.pair (hd (shen.pair (tl (hd V1252)) (shen.hdtl V1252))) shen.skip) (fail)))

(defun shen.<lcurly> (V1253) (if (and (cons? (hd V1253)) (= 123 (hd (hd V1253)))) (shen.pair (hd (shen.pair (tl (hd V1253)) (shen.hdtl V1253))) shen.skip) (fail)))

(defun shen.<rcurly> (V1254) (if (and (cons? (hd V1254)) (= 125 (hd (hd V1254)))) (shen.pair (hd (shen.pair (tl (hd V1254)) (shen.hdtl V1254))) shen.skip) (fail)))

(defun shen.<bar> (V1255) (if (and (cons? (hd V1255)) (= 124 (hd (hd V1255)))) (shen.pair (hd (shen.pair (tl (hd V1255)) (shen.hdtl V1255))) shen.skip) (fail)))

(defun shen.<semicolon> (V1256) (if (and (cons? (hd V1256)) (= 59 (hd (hd V1256)))) (shen.pair (hd (shen.pair (tl (hd V1256)) (shen.hdtl V1256))) shen.skip) (fail)))

(defun shen.<colon> (V1257) (if (and (cons? (hd V1257)) (= 58 (hd (hd V1257)))) (shen.pair (hd (shen.pair (tl (hd V1257)) (shen.hdtl V1257))) shen.skip) (fail)))

(defun shen.<comma> (V1258) (if (and (cons? (hd V1258)) (= 44 (hd (hd V1258)))) (shen.pair (hd (shen.pair (tl (hd V1258)) (shen.hdtl V1258))) shen.skip) (fail)))

(defun shen.<equal> (V1259) (if (and (cons? (hd V1259)) (= 61 (hd (hd V1259)))) (shen.pair (hd (shen.pair (tl (hd V1259)) (shen.hdtl V1259))) shen.skip) (fail)))

(defun shen.<minus> (V1260) (if (and (cons? (hd V1260)) (= 45 (hd (hd V1260)))) (shen.pair (hd (shen.pair (tl (hd V1260)) (shen.hdtl V1260))) shen.skip) (fail)))

(defun shen.<lrb> (V1261) (if (and (cons? (hd V1261)) (= 40 (hd (hd V1261)))) (shen.pair (hd (shen.pair (tl (hd V1261)) (shen.hdtl V1261))) shen.skip) (fail)))

(defun shen.<rrb> (V1262) (if (and (cons? (hd V1262)) (= 41 (hd (hd V1262)))) (shen.pair (hd (shen.pair (tl (hd V1262)) (shen.hdtl V1262))) shen.skip) (fail)))

(defun shen.<atom> (V1263) (let YaccParse (let Parse_shen.<str> (shen.<str> V1263) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V1263) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V1263) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V1264) (cond ((= () V1264) "") ((and (cons? V1264) (and (= "c" (hd V1264)) (and (cons? (tl V1264)) (= "#" (hd (tl V1264)))))) (let CodePoint (shen.code-point (tl (tl V1264))) (let AfterCodePoint (shen.after-codepoint (tl (tl V1264))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V1264) (@s (hd V1264) (shen.control-chars (tl V1264)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V1267) (cond ((and (cons? V1267) (= ";" (hd V1267))) "") ((and (cons? V1267) (element? (hd V1267) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V1267) (shen.code-point (tl V1267)))) (true (simple-error (cn "code point parse error " (shen.app V1267 "
" shen.a))))))

(defun shen.after-codepoint (V1272) (cond ((= () V1272) ()) ((and (cons? V1272) (= ";" (hd V1272))) (tl V1272)) ((cons? V1272) (shen.after-codepoint (tl V1272))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V1273) (shen.pre (reverse (shen.digits->integers V1273)) 0))

(defun shen.digits->integers (V1278) (cond ((and (cons? V1278) (= "0" (hd V1278))) (cons 0 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "1" (hd V1278))) (cons 1 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "2" (hd V1278))) (cons 2 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "3" (hd V1278))) (cons 3 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "4" (hd V1278))) (cons 4 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "5" (hd V1278))) (cons 5 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "6" (hd V1278))) (cons 6 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "7" (hd V1278))) (cons 7 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "8" (hd V1278))) (cons 8 (shen.digits->integers (tl V1278)))) ((and (cons? V1278) (= "9" (hd V1278))) (cons 9 (shen.digits->integers (tl V1278)))) (true ())))

(defun shen.<sym> (V1279) (let Parse_shen.<alpha> (shen.<alpha> V1279) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V1280) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V1280) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1280) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V1281) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V1281) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V1281) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V1282) (if (cons? (hd V1282)) (let Parse_Byte (hd (hd V1282)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1282)) (shen.hdtl V1282))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.numbyte? (V1287) (cond ((= 48 V1287) true) ((= 49 V1287) true) ((= 50 V1287) true) ((= 51 V1287) true) ((= 52 V1287) true) ((= 53 V1287) true) ((= 54 V1287) true) ((= 55 V1287) true) ((= 56 V1287) true) ((= 57 V1287) true) (true false)))

(defun shen.<alpha> (V1288) (if (cons? (hd V1288)) (let Parse_Byte (hd (hd V1288)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1288)) (shen.hdtl V1288))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.symbol-code? (V1289) (or (= V1289 126) (or (and (> V1289 94) (< V1289 123)) (or (and (> V1289 59) (< V1289 91)) (or (and (> V1289 41) (and (< V1289 58) (not (= V1289 44)))) (or (and (> V1289 34) (< V1289 40)) (= V1289 33)))))))

(defun shen.<str> (V1290) (let Parse_shen.<dbq> (shen.<dbq> V1290) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V1291) (if (cons? (hd V1291)) (let Parse_Byte (hd (hd V1291)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V1291)) (shen.hdtl V1291))) Parse_Byte) (fail))) (fail)))

(defun shen.<strcontents> (V1292) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V1292) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1292) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V1293) (if (cons? (hd V1293)) (let Parse_Byte (hd (hd V1293)) (shen.pair (hd (shen.pair (tl (hd V1293)) (shen.hdtl V1293))) (n->string Parse_Byte))) (fail)))

(defun shen.<strc> (V1294) (if (cons? (hd V1294)) (let Parse_Byte (hd (hd V1294)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V1294)) (shen.hdtl V1294))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.<number> (V1295) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V1295) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V1295) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V1295) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V1295) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V1295) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V1295) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V1296) (if (and (cons? (hd V1296)) (= 101 (hd (hd V1296)))) (shen.pair (hd (shen.pair (tl (hd V1296)) (shen.hdtl V1296))) shen.skip) (fail)))

(defun shen.<log10> (V1297) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V1297) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V1297) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V1298) (if (cons? (hd V1298)) (let Parse_Byte (hd (hd V1298)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V1298)) (shen.hdtl V1298))) Parse_Byte) (fail))) (fail)))

(defun shen.<stop> (V1299) (if (cons? (hd V1299)) (let Parse_Byte (hd (hd V1299)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V1299)) (shen.hdtl V1299))) Parse_Byte) (fail))) (fail)))

(defun shen.<predigits> (V1300) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V1300) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1300) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V1301) (let Parse_shen.<digits> (shen.<digits> V1301) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V1302) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V1302) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V1302) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V1303) (if (cons? (hd V1303)) (let Parse_X (hd (hd V1303)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1303)) (shen.hdtl V1303))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V1304) (cond ((= 48 V1304) 0) ((= 49 V1304) 1) ((= 50 V1304) 2) ((= 51 V1304) 3) ((= 52 V1304) 4) ((= 53 V1304) 5) ((= 54 V1304) 6) ((= 55 V1304) 7) ((= 56 V1304) 8) ((= 57 V1304) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V1307 V1308) (cond ((= () V1307) 0) ((cons? V1307) (+ (* (shen.expt 10 V1308) (hd V1307)) (shen.pre (tl V1307) (+ V1308 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V1311 V1312) (cond ((= () V1311) 0) ((cons? V1311) (+ (* (shen.expt 10 (- 0 V1312)) (hd V1311)) (shen.post (tl V1311) (+ V1312 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V1315 V1316) (cond ((= 0 V1316) 1) ((> V1316 0) (* V1315 (shen.expt V1315 (- V1316 1)))) (true (* 1 (/ (shen.expt V1315 (+ V1316 1)) V1315)))))

(defun shen.<st_input1> (V1317) (let Parse_shen.<st_input> (shen.<st_input> V1317) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V1318) (let Parse_shen.<st_input> (shen.<st_input> V1318) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V1319) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V1319) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V1319) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V1320) (let Parse_shen.<backslash> (shen.<backslash> V1320) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V1321) (if (and (cons? (hd V1321)) (= 92 (hd (hd V1321)))) (shen.pair (hd (shen.pair (tl (hd V1321)) (shen.hdtl V1321))) shen.skip) (fail)))

(defun shen.<anysingle> (V1322) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V1322) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V1322) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V1323) (if (cons? (hd V1323)) (let Parse_X (hd (hd V1323)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V1323)) (shen.hdtl V1323))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V1324) (if (cons? (hd V1324)) (let Parse_X (hd (hd V1324)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V1324)) (shen.hdtl V1324))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V1325) (let Parse_shen.<backslash> (shen.<backslash> V1325) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V1326) (if (and (cons? (hd V1326)) (= 42 (hd (hd V1326)))) (shen.pair (hd (shen.pair (tl (hd V1326)) (shen.hdtl V1326))) shen.skip) (fail)))

(defun shen.<anymulti> (V1327) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V1327) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V1327) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V1327)) (let Parse_X (hd (hd V1327)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V1327)) (shen.hdtl V1327))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V1328) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V1328) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V1328) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V1329) (if (cons? (hd V1329)) (let Parse_X (hd (hd V1329)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V1329)) (shen.hdtl V1329))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V1330) (cond ((= () V1330) ()) ((and (cons? V1330) (and (cons? (tl V1330)) (and (cons? (tl (tl V1330))) (and (= () (tl (tl (tl V1330)))) (= (hd (tl V1330)) bar!))))) (cons cons (cons (hd V1330) (tl (tl V1330))))) ((cons? V1330) (cons cons (cons (hd V1330) (cons (shen.cons_form (tl V1330)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V1333 V1334) (cond ((and (cons? V1333) (and (= $ (hd V1333)) (and (cons? (tl V1333)) (= () (tl (tl V1333)))))) (append (explode (hd (tl V1333))) V1334)) ((and (cons? V1333) (and (= package (hd V1333)) (and (cons? (tl V1333)) (and (= null (hd (tl V1333))) (cons? (tl (tl V1333))))))) (append (tl (tl (tl V1333))) V1334)) ((and (cons? V1333) (and (= package (hd V1333)) (and (cons? (tl V1333)) (cons? (tl (tl V1333)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V1333)))) (let Record (shen.record-exceptions ListofExceptions (hd (tl V1333))) (let PackageNameDot (intern (cn (str (hd (tl V1333))) ".")) (append (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V1333)))) V1334))))) (true (cons V1333 V1334))))

(defun shen.record-exceptions (V1335 V1336) (let CurrExceptions (trap-error (get V1336 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V1335 CurrExceptions) (put V1336 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.packageh (V1345 V1346 V1347) (cond ((cons? V1347) (cons (shen.packageh V1345 V1346 (hd V1347)) (shen.packageh V1345 V1346 (tl V1347)))) ((or (shen.sysfunc? V1347) (or (variable? V1347) (or (element? V1347 V1346) (or (shen.doubleunderline? V1347) (shen.singleunderline? V1347))))) V1347) ((and (symbol? V1347) (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) (explode V1347)))) (concat V1345 V1347)) (true V1347)))



