"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-file-as-bytelist (V16928) (let Stream (open V16928 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V16932 V16933 V16934) (cond ((= -1 V16933) V16934) (true (shen.read-file-as-bytelist-help V16932 (read-byte V16932) (cons V16933 V16934)))))

(defun read-file-as-string (V16936) (let Stream (open V16936 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V16940 V16941 V16942) (cond ((= -1 V16941) (do (close V16940) V16942)) (true (shen.rfas-h V16940 (read-byte V16940) (cn V16942 (n->string V16941))))))

(defun input (V16944) (eval-kl (read V16944)))

(defun input+ (V16947 V16948) (let Mono? (shen.monotype V16947) (let Input (read V16948) (if (= false (shen.typecheck Input (shen.demodulate V16947))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V16947 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V16950) (cond ((cons? V16950) (map (lambda Z (shen.monotype Z)) V16950)) (true (if (variable? V16950) (simple-error (cn "input+ expects a monotype: not " (shen.app V16950 "
" shen.a))) V16950))))

(defun read (V16952) (hd (shen.read-loop V16952 (read-byte V16952) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V16960 V16961 V16962) (cond ((= 94 V16961) (simple-error "read aborted")) ((= -1 V16961) (if (empty? V16962) (simple-error "error: empty stream") (compile (lambda X (shen.<st_input> X)) V16962 (lambda E E)))) ((shen.terminator? V16961) (let AllBytes (append V16962 (cons V16961 ())) (let It (shen.record-it AllBytes) (let Read (compile (lambda X (shen.<st_input> X)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V16960 (read-byte V16960) AllBytes) Read))))) (true (shen.read-loop V16960 (read-byte V16960) (append V16962 (cons V16961 ()))))))

(defun shen.terminator? (V16964) (element? V16964 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V16966) (shen.lineread-loop (read-byte V16966) () V16966))

(defun shen.lineread-loop (V16971 V16972 V16973) (cond ((= -1 V16971) (if (empty? V16972) (simple-error "empty stream") (compile (lambda X (shen.<st_input> X)) V16972 (lambda E E)))) ((= V16971 (shen.hat)) (simple-error "line read aborted")) ((element? V16971 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V16972 (lambda E shen.nextline)) (let It (shen.record-it V16972) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V16973) (append V16972 (cons V16971 ())) V16973) Line)))) (true (shen.lineread-loop (read-byte V16973) (append V16972 (cons V16971 ())) V16973))))

(defun shen.record-it (V16975) (let TrimLeft (shen.trim-whitespace V16975) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V16977) (cond ((and (cons? V16977) (element? (hd V16977) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V16977))) (true V16977)))

(defun shen.record-it-h (V16979) (do (set shen.*it* (shen.cn-all (map (lambda X (n->string X)) V16979))) V16979))

(defun shen.cn-all (V16981) (cond ((= () V16981) "") ((cons? V16981) (cn (hd V16981) (shen.cn-all (tl V16981)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V16983) (let Bytelist (read-file-as-bytelist V16983) (compile (lambda X (shen.<st_input> X)) Bytelist (lambda X (shen.read-error X)))))

(defun read-from-string (V16985) (let Ns (map (lambda X (string->n X)) (explode V16985)) (compile (lambda X (shen.<st_input> X)) Ns (lambda X (shen.read-error X)))))

(defun shen.read-error (V16993) (cond ((and (cons? V16993) (and (cons? (hd V16993)) (and (cons? (tl V16993)) (= () (tl (tl V16993)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V16993)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V17000 V17001) (cond ((= () V17001) "") ((= 0 V17000) "") ((cons? V17001) (cn (n->string (hd V17001)) (shen.compress-50 (- V17000 1) (tl V17001)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V17003) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V17003) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V17003) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V17003) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V17003) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V17003) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V17003) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V17003) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V17003) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V17003) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V17003) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V17003) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V17003) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V17003) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V17003) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V17005) (if (and (cons? (hd V17005)) (= 91 (hd (hd V17005)))) (shen.pair (hd (shen.pair (tl (hd V17005)) (shen.hdtl V17005))) shen.skip) (fail)))

(defun shen.<rsb> (V17007) (if (and (cons? (hd V17007)) (= 93 (hd (hd V17007)))) (shen.pair (hd (shen.pair (tl (hd V17007)) (shen.hdtl V17007))) shen.skip) (fail)))

(defun shen.<lcurly> (V17009) (if (and (cons? (hd V17009)) (= 123 (hd (hd V17009)))) (shen.pair (hd (shen.pair (tl (hd V17009)) (shen.hdtl V17009))) shen.skip) (fail)))

(defun shen.<rcurly> (V17011) (if (and (cons? (hd V17011)) (= 125 (hd (hd V17011)))) (shen.pair (hd (shen.pair (tl (hd V17011)) (shen.hdtl V17011))) shen.skip) (fail)))

(defun shen.<bar> (V17013) (if (and (cons? (hd V17013)) (= 124 (hd (hd V17013)))) (shen.pair (hd (shen.pair (tl (hd V17013)) (shen.hdtl V17013))) shen.skip) (fail)))

(defun shen.<semicolon> (V17015) (if (and (cons? (hd V17015)) (= 59 (hd (hd V17015)))) (shen.pair (hd (shen.pair (tl (hd V17015)) (shen.hdtl V17015))) shen.skip) (fail)))

(defun shen.<colon> (V17017) (if (and (cons? (hd V17017)) (= 58 (hd (hd V17017)))) (shen.pair (hd (shen.pair (tl (hd V17017)) (shen.hdtl V17017))) shen.skip) (fail)))

(defun shen.<comma> (V17019) (if (and (cons? (hd V17019)) (= 44 (hd (hd V17019)))) (shen.pair (hd (shen.pair (tl (hd V17019)) (shen.hdtl V17019))) shen.skip) (fail)))

(defun shen.<equal> (V17021) (if (and (cons? (hd V17021)) (= 61 (hd (hd V17021)))) (shen.pair (hd (shen.pair (tl (hd V17021)) (shen.hdtl V17021))) shen.skip) (fail)))

(defun shen.<minus> (V17023) (if (and (cons? (hd V17023)) (= 45 (hd (hd V17023)))) (shen.pair (hd (shen.pair (tl (hd V17023)) (shen.hdtl V17023))) shen.skip) (fail)))

(defun shen.<lrb> (V17025) (if (and (cons? (hd V17025)) (= 40 (hd (hd V17025)))) (shen.pair (hd (shen.pair (tl (hd V17025)) (shen.hdtl V17025))) shen.skip) (fail)))

(defun shen.<rrb> (V17027) (if (and (cons? (hd V17027)) (= 41 (hd (hd V17027)))) (shen.pair (hd (shen.pair (tl (hd V17027)) (shen.hdtl V17027))) shen.skip) (fail)))

(defun shen.<atom> (V17029) (let YaccParse (let Parse_shen.<str> (shen.<str> V17029) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V17029) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V17029) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V17031) (cond ((= () V17031) "") ((and (cons? V17031) (and (= "c" (hd V17031)) (and (cons? (tl V17031)) (= "#" (hd (tl V17031)))))) (let CodePoint (shen.code-point (tl (tl V17031))) (let AfterCodePoint (shen.after-codepoint (tl (tl V17031))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V17031) (@s (hd V17031) (shen.control-chars (tl V17031)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V17035) (cond ((and (cons? V17035) (= ";" (hd V17035))) "") ((and (cons? V17035) (element? (hd V17035) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V17035) (shen.code-point (tl V17035)))) (true (simple-error (cn "code point parse error " (shen.app V17035 "
" shen.a))))))

(defun shen.after-codepoint (V17041) (cond ((= () V17041) ()) ((and (cons? V17041) (= ";" (hd V17041))) (tl V17041)) ((cons? V17041) (shen.after-codepoint (tl V17041))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V17043) (shen.pre (reverse (shen.digits->integers V17043)) 0))

(defun shen.digits->integers (V17049) (cond ((and (cons? V17049) (= "0" (hd V17049))) (cons 0 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "1" (hd V17049))) (cons 1 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "2" (hd V17049))) (cons 2 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "3" (hd V17049))) (cons 3 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "4" (hd V17049))) (cons 4 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "5" (hd V17049))) (cons 5 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "6" (hd V17049))) (cons 6 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "7" (hd V17049))) (cons 7 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "8" (hd V17049))) (cons 8 (shen.digits->integers (tl V17049)))) ((and (cons? V17049) (= "9" (hd V17049))) (cons 9 (shen.digits->integers (tl V17049)))) (true ())))

(defun shen.<sym> (V17051) (let Parse_shen.<alpha> (shen.<alpha> V17051) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V17053) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V17053) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V17053) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V17055) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V17055) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V17055) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V17057) (if (cons? (hd V17057)) (let Parse_Byte (hd (hd V17057)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V17057)) (shen.hdtl V17057))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.numbyte? (V17063) (cond ((= 48 V17063) true) ((= 49 V17063) true) ((= 50 V17063) true) ((= 51 V17063) true) ((= 52 V17063) true) ((= 53 V17063) true) ((= 54 V17063) true) ((= 55 V17063) true) ((= 56 V17063) true) ((= 57 V17063) true) (true false)))

(defun shen.<alpha> (V17065) (if (cons? (hd V17065)) (let Parse_Byte (hd (hd V17065)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V17065)) (shen.hdtl V17065))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.symbol-code? (V17067) (or (= V17067 126) (or (and (> V17067 94) (< V17067 123)) (or (and (> V17067 59) (< V17067 91)) (or (and (> V17067 41) (and (< V17067 58) (not (= V17067 44)))) (or (and (> V17067 34) (< V17067 40)) (= V17067 33)))))))

(defun shen.<str> (V17069) (let Parse_shen.<dbq> (shen.<dbq> V17069) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V17071) (if (cons? (hd V17071)) (let Parse_Byte (hd (hd V17071)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V17071)) (shen.hdtl V17071))) Parse_Byte) (fail))) (fail)))

(defun shen.<strcontents> (V17073) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V17073) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V17073) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V17075) (if (cons? (hd V17075)) (let Parse_Byte (hd (hd V17075)) (shen.pair (hd (shen.pair (tl (hd V17075)) (shen.hdtl V17075))) (n->string Parse_Byte))) (fail)))

(defun shen.<strc> (V17077) (if (cons? (hd V17077)) (let Parse_Byte (hd (hd V17077)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V17077)) (shen.hdtl V17077))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.<number> (V17079) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V17079) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V17079) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V17079) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V17079) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V17079) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V17079) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V17081) (if (and (cons? (hd V17081)) (= 101 (hd (hd V17081)))) (shen.pair (hd (shen.pair (tl (hd V17081)) (shen.hdtl V17081))) shen.skip) (fail)))

(defun shen.<log10> (V17083) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V17083) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V17083) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V17085) (if (cons? (hd V17085)) (let Parse_Byte (hd (hd V17085)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V17085)) (shen.hdtl V17085))) Parse_Byte) (fail))) (fail)))

(defun shen.<stop> (V17087) (if (cons? (hd V17087)) (let Parse_Byte (hd (hd V17087)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V17087)) (shen.hdtl V17087))) Parse_Byte) (fail))) (fail)))

(defun shen.<predigits> (V17089) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V17089) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V17089) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V17091) (let Parse_shen.<digits> (shen.<digits> V17091) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V17093) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V17093) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V17093) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V17095) (if (cons? (hd V17095)) (let Parse_X (hd (hd V17095)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V17095)) (shen.hdtl V17095))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V17097) (cond ((= 48 V17097) 0) ((= 49 V17097) 1) ((= 50 V17097) 2) ((= 51 V17097) 3) ((= 52 V17097) 4) ((= 53 V17097) 5) ((= 54 V17097) 6) ((= 55 V17097) 7) ((= 56 V17097) 8) ((= 57 V17097) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V17102 V17103) (cond ((= () V17102) 0) ((cons? V17102) (+ (* (shen.expt 10 V17103) (hd V17102)) (shen.pre (tl V17102) (+ V17103 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V17108 V17109) (cond ((= () V17108) 0) ((cons? V17108) (+ (* (shen.expt 10 (- 0 V17109)) (hd V17108)) (shen.post (tl V17108) (+ V17109 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V17114 V17115) (cond ((= 0 V17115) 1) ((> V17115 0) (* V17114 (shen.expt V17114 (- V17115 1)))) (true (* 1.0 (/ (shen.expt V17114 (+ V17115 1)) V17114)))))

(defun shen.<st_input1> (V17117) (let Parse_shen.<st_input> (shen.<st_input> V17117) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V17119) (let Parse_shen.<st_input> (shen.<st_input> V17119) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V17121) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V17121) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V17121) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V17123) (let Parse_shen.<backslash> (shen.<backslash> V17123) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V17125) (if (and (cons? (hd V17125)) (= 92 (hd (hd V17125)))) (shen.pair (hd (shen.pair (tl (hd V17125)) (shen.hdtl V17125))) shen.skip) (fail)))

(defun shen.<anysingle> (V17127) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V17127) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V17127) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V17129) (if (cons? (hd V17129)) (let Parse_X (hd (hd V17129)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V17129)) (shen.hdtl V17129))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V17131) (if (cons? (hd V17131)) (let Parse_X (hd (hd V17131)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V17131)) (shen.hdtl V17131))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V17133) (let Parse_shen.<backslash> (shen.<backslash> V17133) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V17135) (if (and (cons? (hd V17135)) (= 42 (hd (hd V17135)))) (shen.pair (hd (shen.pair (tl (hd V17135)) (shen.hdtl V17135))) shen.skip) (fail)))

(defun shen.<anymulti> (V17137) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V17137) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V17137) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V17137)) (let Parse_X (hd (hd V17137)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V17137)) (shen.hdtl V17137))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V17139) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V17139) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V17139) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V17141) (if (cons? (hd V17141)) (let Parse_X (hd (hd V17141)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V17141)) (shen.hdtl V17141))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V17143) (cond ((= () V17143) ()) ((and (cons? V17143) (and (cons? (tl V17143)) (and (cons? (tl (tl V17143))) (and (= () (tl (tl (tl V17143)))) (= (hd (tl V17143)) bar!))))) (cons cons (cons (hd V17143) (tl (tl V17143))))) ((cons? V17143) (cons cons (cons (hd V17143) (cons (shen.cons_form (tl V17143)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V17148 V17149) (cond ((and (cons? V17148) (and (= $ (hd V17148)) (and (cons? (tl V17148)) (= () (tl (tl V17148)))))) (append (explode (hd (tl V17148))) V17149)) ((and (cons? V17148) (and (= package (hd V17148)) (and (cons? (tl V17148)) (and (= null (hd (tl V17148))) (cons? (tl (tl V17148))))))) (append (tl (tl (tl V17148))) V17149)) ((and (cons? V17148) (and (= package (hd V17148)) (and (cons? (tl V17148)) (cons? (tl (tl V17148)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V17148)))) (let Record (shen.record-exceptions ListofExceptions (hd (tl V17148))) (let PackageNameDot (intern (cn (str (hd (tl V17148))) ".")) (append (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V17148)))) V17149))))) (true (cons V17148 V17149))))

(defun shen.record-exceptions (V17152 V17153) (let CurrExceptions (trap-error (get V17153 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V17152 CurrExceptions) (put V17153 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.packageh (V17165 V17166 V17167) (cond ((cons? V17167) (cons (shen.packageh V17165 V17166 (hd V17167)) (shen.packageh V17165 V17166 (tl V17167)))) ((or (shen.sysfunc? V17167) (or (variable? V17167) (or (element? V17167 V17166) (or (shen.doubleunderline? V17167) (shen.singleunderline? V17167))))) V17167) ((and (symbol? V17167) (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) (explode V17167)))) (concat V17165 V17167)) (true V17167)))



