"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun read-file-as-bytelist (V2211) (let Stream (open V2211 in) (let Byte (read-byte Stream) (let Bytes (shen.read-file-as-bytelist-help Stream Byte ()) (let Close (close Stream) (reverse Bytes))))))

(defun shen.read-file-as-bytelist-help (V2215 V2216 V2217) (cond ((= -1 V2216) V2217) (true (shen.read-file-as-bytelist-help V2215 (read-byte V2215) (cons V2216 V2217)))))

(defun read-file-as-string (V2219) (let Stream (open V2219 in) (shen.rfas-h Stream (read-byte Stream) "")))

(defun shen.rfas-h (V2223 V2224 V2225) (cond ((= -1 V2224) (do (close V2223) V2225)) (true (shen.rfas-h V2223 (read-byte V2223) (cn V2225 (n->string V2224))))))

(defun input (V2227) (eval-kl (read V2227)))

(defun input+ (V2230 V2231) (let Mono? (shen.monotype V2230) (let Input (read V2231) (if (= false (shen.typecheck Input (shen.demodulate V2230))) (simple-error (cn "type error: " (shen.app Input (cn " is not of type " (shen.app V2230 "
" shen.r)) shen.r))) (eval-kl Input)))))

(defun shen.monotype (V2233) (cond ((cons? V2233) (map (lambda Z (shen.monotype Z)) V2233)) (true (if (variable? V2233) (simple-error (cn "input+ expects a monotype: not " (shen.app V2233 "
" shen.a))) V2233))))

(defun read (V2235) (hd (shen.read-loop V2235 (read-byte V2235) ())))

(defun it () (value shen.*it*))

(defun shen.read-loop (V2243 V2244 V2245) (cond ((= 94 V2244) (simple-error "read aborted")) ((= -1 V2244) (if (empty? V2245) (simple-error "error: empty stream") (compile (lambda X (shen.<st_input> X)) V2245 (lambda E E)))) ((shen.terminator? V2244) (let AllBytes (append V2245 (cons V2244 ())) (let It (shen.record-it AllBytes) (let Read (compile (lambda X (shen.<st_input> X)) AllBytes (lambda E shen.nextbyte)) (if (or (= Read shen.nextbyte) (empty? Read)) (shen.read-loop V2243 (read-byte V2243) AllBytes) Read))))) (true (shen.read-loop V2243 (read-byte V2243) (append V2245 (cons V2244 ()))))))

(defun shen.terminator? (V2247) (element? V2247 (cons 9 (cons 10 (cons 13 (cons 32 (cons 34 (cons 41 (cons 93 ())))))))))

(defun lineread (V2249) (shen.lineread-loop (read-byte V2249) () V2249))

(defun shen.lineread-loop (V2254 V2255 V2256) (cond ((= -1 V2254) (if (empty? V2255) (simple-error "empty stream") (compile (lambda X (shen.<st_input> X)) V2255 (lambda E E)))) ((= V2254 (shen.hat)) (simple-error "line read aborted")) ((element? V2254 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V2255 (lambda E shen.nextline)) (let It (shen.record-it V2255) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte V2256) (append V2255 (cons V2254 ())) V2256) Line)))) (true (shen.lineread-loop (read-byte V2256) (append V2255 (cons V2254 ())) V2256))))

(defun shen.record-it (V2258) (let TrimLeft (shen.trim-whitespace V2258) (let TrimRight (shen.trim-whitespace (reverse TrimLeft)) (let Trimmed (reverse TrimRight) (shen.record-it-h Trimmed)))))

(defun shen.trim-whitespace (V2260) (cond ((and (cons? V2260) (element? (hd V2260) (cons 9 (cons 10 (cons 13 (cons 32 ())))))) (shen.trim-whitespace (tl V2260))) (true V2260)))

(defun shen.record-it-h (V2262) (do (set shen.*it* (shen.cn-all (map (lambda X (n->string X)) V2262))) V2262))

(defun shen.cn-all (V2264) (cond ((= () V2264) "") ((cons? V2264) (cn (hd V2264) (shen.cn-all (tl V2264)))) (true (shen.f_error shen.cn-all))))

(defun read-file (V2266) (let Bytelist (read-file-as-bytelist V2266) (compile (lambda X (shen.<st_input> X)) Bytelist (lambda X (shen.read-error X)))))

(defun read-from-string (V2268) (let Ns (map (lambda X (string->n X)) (explode V2268)) (compile (lambda X (shen.<st_input> X)) Ns (lambda X (shen.read-error X)))))

(defun shen.read-error (V2276) (cond ((and (cons? V2276) (and (cons? (hd V2276)) (and (cons? (tl V2276)) (= () (tl (tl V2276)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V2276)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V2283 V2284) (cond ((= () V2284) "") ((= 0 V2283) "") ((cons? V2284) (cn (n->string (hd V2284)) (shen.compress-50 (- V2283 1) (tl V2284)))) (true (shen.f_error shen.compress-50))))

(defun shen.<st_input> (V2286) (let YaccParse (let Parse_shen.<lsb> (shen.<lsb> V2286) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lrb> (shen.<lrb> V2286) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<lcurly> (shen.<lcurly> V2286) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<rcurly> (shen.<rcurly> V2286) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<bar> (shen.<bar> V2286) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<semicolon> (shen.<semicolon> V2286) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2286) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2286) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<colon> (shen.<colon> V2286) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comma> (shen.<comma> V2286) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2286) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<atom> (shen.<atom> V2286) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<whitespaces> (shen.<whitespaces> V2286) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2286) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<lsb> (V2288) (if (and (cons? (hd V2288)) (= 91 (hd (hd V2288)))) (shen.pair (hd (shen.pair (tl (hd V2288)) (shen.hdtl V2288))) shen.skip) (fail)))

(defun shen.<rsb> (V2290) (if (and (cons? (hd V2290)) (= 93 (hd (hd V2290)))) (shen.pair (hd (shen.pair (tl (hd V2290)) (shen.hdtl V2290))) shen.skip) (fail)))

(defun shen.<lcurly> (V2292) (if (and (cons? (hd V2292)) (= 123 (hd (hd V2292)))) (shen.pair (hd (shen.pair (tl (hd V2292)) (shen.hdtl V2292))) shen.skip) (fail)))

(defun shen.<rcurly> (V2294) (if (and (cons? (hd V2294)) (= 125 (hd (hd V2294)))) (shen.pair (hd (shen.pair (tl (hd V2294)) (shen.hdtl V2294))) shen.skip) (fail)))

(defun shen.<bar> (V2296) (if (and (cons? (hd V2296)) (= 124 (hd (hd V2296)))) (shen.pair (hd (shen.pair (tl (hd V2296)) (shen.hdtl V2296))) shen.skip) (fail)))

(defun shen.<semicolon> (V2298) (if (and (cons? (hd V2298)) (= 59 (hd (hd V2298)))) (shen.pair (hd (shen.pair (tl (hd V2298)) (shen.hdtl V2298))) shen.skip) (fail)))

(defun shen.<colon> (V2300) (if (and (cons? (hd V2300)) (= 58 (hd (hd V2300)))) (shen.pair (hd (shen.pair (tl (hd V2300)) (shen.hdtl V2300))) shen.skip) (fail)))

(defun shen.<comma> (V2302) (if (and (cons? (hd V2302)) (= 44 (hd (hd V2302)))) (shen.pair (hd (shen.pair (tl (hd V2302)) (shen.hdtl V2302))) shen.skip) (fail)))

(defun shen.<equal> (V2304) (if (and (cons? (hd V2304)) (= 61 (hd (hd V2304)))) (shen.pair (hd (shen.pair (tl (hd V2304)) (shen.hdtl V2304))) shen.skip) (fail)))

(defun shen.<minus> (V2306) (if (and (cons? (hd V2306)) (= 45 (hd (hd V2306)))) (shen.pair (hd (shen.pair (tl (hd V2306)) (shen.hdtl V2306))) shen.skip) (fail)))

(defun shen.<lrb> (V2308) (if (and (cons? (hd V2308)) (= 40 (hd (hd V2308)))) (shen.pair (hd (shen.pair (tl (hd V2308)) (shen.hdtl V2308))) shen.skip) (fail)))

(defun shen.<rrb> (V2310) (if (and (cons? (hd V2310)) (= 41 (hd (hd V2310)))) (shen.pair (hd (shen.pair (tl (hd V2310)) (shen.hdtl V2310))) shen.skip) (fail)))

(defun shen.<atom> (V2312) (let YaccParse (let Parse_shen.<str> (shen.<str> V2312) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<number> (shen.<number> V2312) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<sym> (shen.<sym> V2312) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) YaccParse)) YaccParse)))

(defun shen.control-chars (V2314) (cond ((= () V2314) "") ((and (cons? V2314) (and (= "c" (hd V2314)) (and (cons? (tl V2314)) (= "#" (hd (tl V2314)))))) (let CodePoint (shen.code-point (tl (tl V2314))) (let AfterCodePoint (shen.after-codepoint (tl (tl V2314))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V2314) (@s (hd V2314) (shen.control-chars (tl V2314)))) (true (shen.f_error shen.control-chars))))

(defun shen.code-point (V2318) (cond ((and (cons? V2318) (= ";" (hd V2318))) "") ((and (cons? V2318) (element? (hd V2318) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V2318) (shen.code-point (tl V2318)))) (true (simple-error (cn "code point parse error " (shen.app V2318 "
" shen.a))))))

(defun shen.after-codepoint (V2324) (cond ((= () V2324) ()) ((and (cons? V2324) (= ";" (hd V2324))) (tl V2324)) ((cons? V2324) (shen.after-codepoint (tl V2324))) (true (shen.f_error shen.after-codepoint))))

(defun shen.decimalise (V2326) (shen.pre (reverse (shen.digits->integers V2326)) 0))

(defun shen.digits->integers (V2332) (cond ((and (cons? V2332) (= "0" (hd V2332))) (cons 0 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "1" (hd V2332))) (cons 1 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "2" (hd V2332))) (cons 2 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "3" (hd V2332))) (cons 3 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "4" (hd V2332))) (cons 4 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "5" (hd V2332))) (cons 5 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "6" (hd V2332))) (cons 6 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "7" (hd V2332))) (cons 7 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "8" (hd V2332))) (cons 8 (shen.digits->integers (tl V2332)))) ((and (cons? V2332) (= "9" (hd V2332))) (cons 9 (shen.digits->integers (tl V2332)))) (true ())))

(defun shen.<sym> (V2334) (let Parse_shen.<alpha> (shen.<alpha> V2334) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))))

(defun shen.<alphanums> (V2336) (let YaccParse (let Parse_shen.<alphanum> (shen.<alphanum> V2336) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2336) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) YaccParse)))

(defun shen.<alphanum> (V2338) (let YaccParse (let Parse_shen.<alpha> (shen.<alpha> V2338) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<num> (shen.<num> V2338) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) YaccParse)))

(defun shen.<num> (V2340) (if (cons? (hd V2340)) (let Parse_Byte (hd (hd V2340)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V2340)) (shen.hdtl V2340))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.numbyte? (V2346) (cond ((= 48 V2346) true) ((= 49 V2346) true) ((= 50 V2346) true) ((= 51 V2346) true) ((= 52 V2346) true) ((= 53 V2346) true) ((= 54 V2346) true) ((= 55 V2346) true) ((= 56 V2346) true) ((= 57 V2346) true) (true false)))

(defun shen.<alpha> (V2348) (if (cons? (hd V2348)) (let Parse_Byte (hd (hd V2348)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V2348)) (shen.hdtl V2348))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.symbol-code? (V2350) (or (= V2350 126) (or (and (> V2350 94) (< V2350 123)) (or (and (> V2350 59) (< V2350 91)) (or (and (> V2350 41) (and (< V2350 58) (not (= V2350 44)))) (or (and (> V2350 34) (< V2350 40)) (= V2350 33)))))))

(defun shen.<str> (V2352) (let Parse_shen.<dbq> (shen.<dbq> V2352) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))))

(defun shen.<dbq> (V2354) (if (cons? (hd V2354)) (let Parse_Byte (hd (hd V2354)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V2354)) (shen.hdtl V2354))) Parse_Byte) (fail))) (fail)))

(defun shen.<strcontents> (V2356) (let YaccParse (let Parse_shen.<strc> (shen.<strc> V2356) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2356) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<byte> (V2358) (if (cons? (hd V2358)) (let Parse_Byte (hd (hd V2358)) (shen.pair (hd (shen.pair (tl (hd V2358)) (shen.hdtl V2358))) (n->string Parse_Byte))) (fail)))

(defun shen.<strc> (V2360) (if (cons? (hd V2360)) (let Parse_Byte (hd (hd V2360)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V2360)) (shen.hdtl V2360))) (n->string Parse_Byte)) (fail))) (fail)))

(defun shen.<number> (V2362) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2362) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<plus> (shen.<plus> V2362) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2362) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2362) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<predigits> (shen.<predigits> V2362) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2362) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)) YaccParse)) YaccParse)) YaccParse)) YaccParse)))

(defun shen.<E> (V2364) (if (and (cons? (hd V2364)) (= 101 (hd (hd V2364)))) (shen.pair (hd (shen.pair (tl (hd V2364)) (shen.hdtl V2364))) shen.skip) (fail)))

(defun shen.<log10> (V2366) (let YaccParse (let Parse_shen.<minus> (shen.<minus> V2366) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digits> (shen.<digits> V2366) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) YaccParse)))

(defun shen.<plus> (V2368) (if (cons? (hd V2368)) (let Parse_Byte (hd (hd V2368)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V2368)) (shen.hdtl V2368))) Parse_Byte) (fail))) (fail)))

(defun shen.<stop> (V2370) (if (cons? (hd V2370)) (let Parse_Byte (hd (hd V2370)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V2370)) (shen.hdtl V2370))) Parse_Byte) (fail))) (fail)))

(defun shen.<predigits> (V2372) (let YaccParse (let Parse_shen.<digits> (shen.<digits> V2372) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2372) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) YaccParse)))

(defun shen.<postdigits> (V2374) (let Parse_shen.<digits> (shen.<digits> V2374) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))))

(defun shen.<digits> (V2376) (let YaccParse (let Parse_shen.<digit> (shen.<digit> V2376) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<digit> (shen.<digit> V2376) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) YaccParse)))

(defun shen.<digit> (V2378) (if (cons? (hd V2378)) (let Parse_X (hd (hd V2378)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V2378)) (shen.hdtl V2378))) (shen.byte->digit Parse_X)) (fail))) (fail)))

(defun shen.byte->digit (V2380) (cond ((= 48 V2380) 0) ((= 49 V2380) 1) ((= 50 V2380) 2) ((= 51 V2380) 3) ((= 52 V2380) 4) ((= 53 V2380) 5) ((= 54 V2380) 6) ((= 55 V2380) 7) ((= 56 V2380) 8) ((= 57 V2380) 9) (true (shen.f_error shen.byte->digit))))

(defun shen.pre (V2385 V2386) (cond ((= () V2385) 0) ((cons? V2385) (+ (* (shen.expt 10 V2386) (hd V2385)) (shen.pre (tl V2385) (+ V2386 1)))) (true (shen.f_error shen.pre))))

(defun shen.post (V2391 V2392) (cond ((= () V2391) 0) ((cons? V2391) (+ (* (shen.expt 10 (- 0 V2392)) (hd V2391)) (shen.post (tl V2391) (+ V2392 1)))) (true (shen.f_error shen.post))))

(defun shen.expt (V2397 V2398) (cond ((= 0 V2398) 1) ((> V2398 0) (* V2397 (shen.expt V2397 (- V2398 1)))) (true (* 1 (/ (shen.expt V2397 (+ V2398 1)) V2397)))))

(defun shen.<st_input1> (V2400) (let Parse_shen.<st_input> (shen.<st_input> V2400) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<st_input2> (V2402) (let Parse_shen.<st_input> (shen.<st_input> V2402) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))))

(defun shen.<comment> (V2404) (let YaccParse (let Parse_shen.<singleline> (shen.<singleline> V2404) (if (not (= (fail) Parse_shen.<singleline>)) (shen.pair (hd Parse_shen.<singleline>) shen.skip) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<multiline> (shen.<multiline> V2404) (if (not (= (fail) Parse_shen.<multiline>)) (shen.pair (hd Parse_shen.<multiline>) shen.skip) (fail))) YaccParse)))

(defun shen.<singleline> (V2406) (let Parse_shen.<backslash> (shen.<backslash> V2406) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<anysingle>)) (let Parse_shen.<return> (shen.<return> Parse_shen.<anysingle>) (if (not (= (fail) Parse_shen.<return>)) (shen.pair (hd Parse_shen.<return>) shen.skip) (fail))) (fail))) (fail))) (fail))))

(defun shen.<backslash> (V2408) (if (and (cons? (hd V2408)) (= 92 (hd (hd V2408)))) (shen.pair (hd (shen.pair (tl (hd V2408)) (shen.hdtl V2408))) shen.skip) (fail)))

(defun shen.<anysingle> (V2410) (let YaccParse (let Parse_shen.<non-return> (shen.<non-return> V2410) (if (not (= (fail) Parse_shen.<non-return>)) (let Parse_shen.<anysingle> (shen.<anysingle> Parse_shen.<non-return>) (if (not (= (fail) Parse_shen.<anysingle>)) (shen.pair (hd Parse_shen.<anysingle>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_<e> (<e> V2410) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) YaccParse)))

(defun shen.<non-return> (V2412) (if (cons? (hd V2412)) (let Parse_X (hd (hd V2412)) (if (not (element? Parse_X (cons 10 (cons 13 ())))) (shen.pair (hd (shen.pair (tl (hd V2412)) (shen.hdtl V2412))) shen.skip) (fail))) (fail)))

(defun shen.<return> (V2414) (if (cons? (hd V2414)) (let Parse_X (hd (hd V2414)) (if (element? Parse_X (cons 10 (cons 13 ()))) (shen.pair (hd (shen.pair (tl (hd V2414)) (shen.hdtl V2414))) shen.skip) (fail))) (fail)))

(defun shen.<multiline> (V2416) (let Parse_shen.<backslash> (shen.<backslash> V2416) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (fail))))

(defun shen.<times> (V2418) (if (and (cons? (hd V2418)) (= 42 (hd (hd V2418)))) (shen.pair (hd (shen.pair (tl (hd V2418)) (shen.hdtl V2418))) shen.skip) (fail)))

(defun shen.<anymulti> (V2420) (let YaccParse (let Parse_shen.<comment> (shen.<comment> V2420) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<anymulti> (shen.<anymulti> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let YaccParse (let Parse_shen.<times> (shen.<times> V2420) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (if (cons? (hd V2420)) (let Parse_X (hd (hd V2420)) (let Parse_shen.<anymulti> (shen.<anymulti> (shen.pair (tl (hd V2420)) (shen.hdtl V2420))) (if (not (= (fail) Parse_shen.<anymulti>)) (shen.pair (hd Parse_shen.<anymulti>) shen.skip) (fail)))) (fail)) YaccParse)) YaccParse)))

(defun shen.<whitespaces> (V2422) (let YaccParse (let Parse_shen.<whitespace> (shen.<whitespace> V2422) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= YaccParse (fail)) (let Parse_shen.<whitespace> (shen.<whitespace> V2422) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) YaccParse)))

(defun shen.<whitespace> (V2424) (if (cons? (hd V2424)) (let Parse_X (hd (hd V2424)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V2424)) (shen.hdtl V2424))) shen.skip) (fail))) (fail)))

(defun shen.cons_form (V2426) (cond ((= () V2426) ()) ((and (cons? V2426) (and (cons? (tl V2426)) (and (cons? (tl (tl V2426))) (and (= () (tl (tl (tl V2426)))) (= (hd (tl V2426)) bar!))))) (cons cons (cons (hd V2426) (tl (tl V2426))))) ((cons? V2426) (cons cons (cons (hd V2426) (cons (shen.cons_form (tl V2426)) ())))) (true (shen.f_error shen.cons_form))))

(defun shen.package-macro (V2431 V2432) (cond ((and (cons? V2431) (and (= $ (hd V2431)) (and (cons? (tl V2431)) (= () (tl (tl V2431)))))) (append (explode (hd (tl V2431))) V2432)) ((and (cons? V2431) (and (= package (hd V2431)) (and (cons? (tl V2431)) (and (= null (hd (tl V2431))) (cons? (tl (tl V2431))))))) (append (tl (tl (tl V2431))) V2432)) ((and (cons? V2431) (and (= package (hd V2431)) (and (cons? (tl V2431)) (cons? (tl (tl V2431)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V2431)))) (let External (shen.record-exceptions ListofExceptions (hd (tl V2431))) (let PackageNameDot (intern (cn (str (hd (tl V2431))) ".")) (let ExpPackageName (explode (hd (tl V2431))) (let Packaged (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V2431))) ExpPackageName) (let Internal (shen.record-internal (hd (tl V2431)) (shen.internal-symbols ExpPackageName Packaged)) (append Packaged V2432)))))))) (true (cons V2431 V2432))))

(defun shen.record-exceptions (V2435 V2436) (let CurrExceptions (trap-error (get V2436 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V2435 CurrExceptions) (put V2436 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.record-internal (V2439 V2440) (put V2439 shen.internal-symbols (union V2440 (trap-error (get V2439 shen.internal-symbols (value *property-vector*)) (lambda E ()))) (value *property-vector*)))

(defun shen.internal-symbols (V2451 V2452) (cond ((and (symbol? V2452) (shen.prefix? V2451 (explode V2452))) (cons V2452 ())) ((cons? V2452) (union (shen.internal-symbols V2451 (hd V2452)) (shen.internal-symbols V2451 (tl V2452)))) (true ())))

(defun shen.packageh (V2469 V2470 V2471 V2472) (cond ((cons? V2471) (cons (shen.packageh V2469 V2470 (hd V2471) V2472) (shen.packageh V2469 V2470 (tl V2471) V2472))) ((or (shen.sysfunc? V2471) (or (variable? V2471) (or (element? V2471 V2470) (or (shen.doubleunderline? V2471) (shen.singleunderline? V2471))))) V2471) ((and (symbol? V2471) (let ExplodeX (explode V2471) (and (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) ExplodeX)) (not (shen.prefix? V2472 ExplodeX))))) (concat V2469 V2471)) (true V2471)))



