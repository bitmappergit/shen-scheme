"Copyright (c) 2015, Mark Tarver

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. The name of Mark Tarver may not be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mark Tarver ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mark Tarver BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

(defun shen.shen () (do (shen.credits) (shen.loop)))

(defun shen.loop () (do (shen.initialise_environment) (do (shen.prompt) (do (trap-error (shen.read-evaluate-print) (lambda E (pr (error-to-string E) (stoutput)))) (shen.loop)))))

(defun shen.credits () (do (shen.prhush "
Shen, copyright (C) 2010-2015 Mark Tarver
" (stoutput)) (do (shen.prhush (cn "www.shenlanguage.org, " (shen.app (value *version*) "
" shen.a)) (stoutput)) (do (shen.prhush (cn "running under " (shen.app (value *language*) (cn ", implementation: " (shen.app (value *implementation*) "" shen.a)) shen.a)) (stoutput)) (shen.prhush (cn "
port " (shen.app (value *port*) (cn " ported by " (shen.app (value *porters*) "
" shen.a)) shen.a)) (stoutput))))))

(defun shen.initialise_environment () (shen.multiple-set (cons shen.*call* (cons 0 (cons shen.*infs* (cons 0 (cons shen.*process-counter* (cons 0 (cons shen.*catch* (cons 0 ()))))))))))

(defun shen.multiple-set (V18411) (cond ((= () V18411) ()) ((and (cons? V18411) (cons? (tl V18411))) (do (set (hd V18411) (hd (tl V18411))) (shen.multiple-set (tl (tl V18411))))) (true (shen.f_error shen.multiple-set))))

(defun destroy (V18413) (declare V18413 symbol))

(set shen.*history* ())

(defun shen.read-evaluate-print () (let Lineread (shen.toplineread) (let History (value shen.*history*) (let NewLineread (shen.retrieve-from-history-if-needed Lineread History) (let NewHistory (shen.update_history NewLineread History) (let Parsed (fst NewLineread) (shen.toplevel Parsed)))))))

(defun shen.retrieve-from-history-if-needed (V18425 V18426) (cond ((and (tuple? V18425) (and (cons? (snd V18425)) (element? (hd (snd V18425)) (cons (shen.space) (cons (shen.newline) ()))))) (shen.retrieve-from-history-if-needed (@p (fst V18425) (tl (snd V18425))) V18426)) ((and (tuple? V18425) (and (cons? (snd V18425)) (and (cons? (tl (snd V18425))) (and (= () (tl (tl (snd V18425)))) (and (cons? V18426) (and (= (hd (snd V18425)) (shen.exclamation)) (= (hd (tl (snd V18425))) (shen.exclamation)))))))) (let PastPrint (shen.prbytes (snd (hd V18426))) (hd V18426))) ((and (tuple? V18425) (and (cons? (snd V18425)) (= (hd (snd V18425)) (shen.exclamation)))) (let Key? (shen.make-key (tl (snd V18425)) V18426) (let Find (head (shen.find-past-inputs Key? V18426)) (let PastPrint (shen.prbytes (snd Find)) Find)))) ((and (tuple? V18425) (and (cons? (snd V18425)) (and (= () (tl (snd V18425))) (= (hd (snd V18425)) (shen.percent))))) (do (shen.print-past-inputs (lambda X true) (reverse V18426) 0) (abort))) ((and (tuple? V18425) (and (cons? (snd V18425)) (= (hd (snd V18425)) (shen.percent)))) (let Key? (shen.make-key (tl (snd V18425)) V18426) (let Pastprint (shen.print-past-inputs Key? (reverse V18426) 0) (abort)))) (true V18425)))

(defun shen.percent () 37)

(defun shen.exclamation () 33)

(defun shen.prbytes (V18428) (do (map (lambda Byte (pr (n->string Byte) (stoutput))) V18428) (nl 1)))

(defun shen.update_history (V18431 V18432) (set shen.*history* (cons V18431 V18432)))

(defun shen.toplineread () (shen.toplineread_loop (read-byte (stinput)) ()))

(defun shen.toplineread_loop (V18436 V18437) (cond ((= V18436 (shen.hat)) (simple-error "line read aborted")) ((element? V18436 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile (lambda X (shen.<st_input> X)) V18437 (lambda E shen.nextline)) (let It (shen.record-it V18437) (if (or (= Line shen.nextline) (empty? Line)) (shen.toplineread_loop (read-byte (stinput)) (append V18437 (cons V18436 ()))) (@p Line V18437))))) (true (shen.toplineread_loop (read-byte (stinput)) (append V18437 (cons V18436 ()))))))

(defun shen.hat () 94)

(defun shen.newline () 10)

(defun shen.carriage-return () 13)

(defun tc (V18443) (cond ((= + V18443) (set shen.*tc* true)) ((= - V18443) (set shen.*tc* false)) (true (simple-error "tc expects a + or -"))))

(defun shen.prompt () (if (value shen.*tc*) (shen.prhush (cn "

(" (shen.app (length (value shen.*history*)) "+) " shen.a)) (stoutput)) (shen.prhush (cn "

(" (shen.app (length (value shen.*history*)) "-) " shen.a)) (stoutput))))

(defun shen.toplevel (V18445) (shen.toplevel_evaluate V18445 (value shen.*tc*)))

(defun shen.find-past-inputs (V18448 V18449) (let F (shen.find V18448 V18449) (if (empty? F) (simple-error "input not found
") F)))

(defun shen.make-key (V18452 V18453) (let Atom (hd (compile (lambda X (shen.<st_input> X)) V18452 (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
"))))) (if (integer? Atom) (lambda X (= X (nth (+ Atom 1) (reverse V18453)))) (lambda X (shen.prefix? V18452 (shen.trim-gubbins (snd X)))))))

(defun shen.trim-gubbins (V18455) (cond ((and (cons? V18455) (= (hd V18455) (shen.space))) (shen.trim-gubbins (tl V18455))) ((and (cons? V18455) (= (hd V18455) (shen.newline))) (shen.trim-gubbins (tl V18455))) ((and (cons? V18455) (= (hd V18455) (shen.carriage-return))) (shen.trim-gubbins (tl V18455))) ((and (cons? V18455) (= (hd V18455) (shen.tab))) (shen.trim-gubbins (tl V18455))) ((and (cons? V18455) (= (hd V18455) (shen.left-round))) (shen.trim-gubbins (tl V18455))) (true V18455)))

(defun shen.space () 32)

(defun shen.tab () 9)

(defun shen.left-round () 40)

(defun shen.find (V18464 V18465) (cond ((= () V18465) ()) ((and (cons? V18465) (V18464 (hd V18465))) (cons (hd V18465) (shen.find V18464 (tl V18465)))) ((cons? V18465) (shen.find V18464 (tl V18465))) (true (shen.f_error shen.find))))

(defun shen.prefix? (V18479 V18480) (cond ((= () V18479) true) ((and (cons? V18479) (and (cons? V18480) (= (hd V18480) (hd V18479)))) (shen.prefix? (tl V18479) (tl V18480))) (true false)))

(defun shen.print-past-inputs (V18492 V18493 V18494) (cond ((= () V18493) _) ((and (cons? V18493) (not (V18492 (hd V18493)))) (shen.print-past-inputs V18492 (tl V18493) (+ V18494 1))) ((and (cons? V18493) (tuple? (hd V18493))) (do (shen.prhush (shen.app V18494 ". " shen.a) (stoutput)) (do (shen.prbytes (snd (hd V18493))) (shen.print-past-inputs V18492 (tl V18493) (+ V18494 1))))) (true (shen.f_error shen.print-past-inputs))))

(defun shen.toplevel_evaluate (V18497 V18498) (cond ((and (cons? V18497) (and (cons? (tl V18497)) (and (= : (hd (tl V18497))) (and (cons? (tl (tl V18497))) (and (= () (tl (tl (tl V18497)))) (= true V18498)))))) (shen.typecheck-and-evaluate (hd V18497) (hd (tl (tl V18497))))) ((and (cons? V18497) (cons? (tl V18497))) (do (shen.toplevel_evaluate (cons (hd V18497) ()) V18498) (do (nl 1) (shen.toplevel_evaluate (tl V18497) V18498)))) ((and (cons? V18497) (and (= () (tl V18497)) (= true V18498))) (shen.typecheck-and-evaluate (hd V18497) (gensym A))) ((and (cons? V18497) (and (= () (tl V18497)) (= false V18498))) (let Eval (shen.eval-without-macros (hd V18497)) (print Eval))) (true (shen.f_error shen.toplevel_evaluate))))

(defun shen.typecheck-and-evaluate (V18501 V18502) (let Typecheck (shen.typecheck V18501 V18502) (if (= Typecheck false) (simple-error "type error
") (let Eval (shen.eval-without-macros V18501) (let Type (shen.pretty-type Typecheck) (shen.prhush (shen.app Eval (cn " : " (shen.app Type "" shen.r)) shen.s) (stoutput)))))))

(defun shen.pretty-type (V18504) (shen.mult_subst (value shen.*alphabet*) (shen.extract-pvars V18504) V18504))

(defun shen.extract-pvars (V18510) (cond ((shen.pvar? V18510) (cons V18510 ())) ((cons? V18510) (union (shen.extract-pvars (hd V18510)) (shen.extract-pvars (tl V18510)))) (true ())))

(defun shen.mult_subst (V18518 V18519 V18520) (cond ((= () V18518) V18520) ((= () V18519) V18520) ((and (cons? V18518) (cons? V18519)) (shen.mult_subst (tl V18518) (tl V18519) (subst (hd V18518) (hd V18519) V18520))) (true (shen.f_error shen.mult_subst))))



